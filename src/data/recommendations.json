{
  "version": "2.0",
  "lastUpdated": "2026-02-16",
  "totalRecommendations": 13,
  "recommendations": {
    "rec-001": {
      "id": "rec-001",
      "title": "Sistema Crítico → Estables → Grande",
      "path": [
        "Crítico",
        "Estables",
        "Grande"
      ],
      "pathDescription": "Sistema Crítico de Seguridad → Requisitos Estables → Equipo Grande (>20)",
      "process": {
        "name": "Cascada + RUP",
        "chapter": 2,
        "why": [
          "Requisitos estables permiten especificación completa",
          "Criticidad requiere documentación exhaustiva y trazabilidad",
          "Equipo grande necesita proceso disciplinado",
          "Regulaciones (FDA, aviación) exigen cumplimiento formal"
        ],
        "how": [
          "Fase 1: Análisis y Definición de Requerimientos → Documento de Especificación",
          "Fase 2: Diseño del Sistema y Software → Arquitectura + Diseño Detallado",
          "Fase 3: Implementación y Prueba de Unidad → Código + Verificación",
          "Fase 4: Integración y Prueba de Sistema → Sistema Completo Probado",
          "Fase 5: Operación y Mantenimiento → Instalación + Soporte"
        ],
        "phases": [
          {
            "name": "Análisis y Definición de Requerimientos",
            "duration": "3-6 semanas",
            "activities": [
              "Estudio de factibilidad técnica y económica",
              "Identificación de stakeholders y usuarios finales",
              "Obtención de requerimientos (entrevistas, observación, análisis de sistemas existentes)",
              "Análisis de requerimientos funcionales y no funcionales",
              "Especificación formal según IEEE 830 o estándar regulatorio aplicable",
              "Modelado de casos de uso completos",
              "Análisis de riesgos preliminar",
              "Definición de criterios de aceptación medibles"
            ],
            "inputs": [
              "Solicitud del proyecto con justificación de negocio",
              "Documentación de sistemas legados (si aplica)",
              "Estándares regulatorios aplicables (FDA 21 CFR Part 11, DO-178C aviación, ISO 26262 automotriz)",
              "Restricciones de hardware conocidas"
            ],
            "outputs": [
              "Documento de Especificación de Requerimientos de Software (SRS) según IEEE 830",
              "Matriz de trazabilidad de requerimientos",
              "Casos de uso formales documentados",
              "Informe de factibilidad aprobado",
              "Plan de gestión de requerimientos",
              "Registro de riesgos inicial"
            ],
            "gate": {
              "name": "Requirements Review Gate",
              "criteria": [
                "SRS completo y aprobado por stakeholders",
                "Todos los requerimientos tienen criterios de aceptación medibles",
                "Trazabilidad completa establecida",
                "Cumplimiento regulatorio verificado",
                "Presupuesto y cronograma aprobados"
              ],
              "approvers": [
                "Cliente/Sponsor",
                "Arquitecto Principal",
                "Gerente de Proyecto",
                "Equipo de Calidad",
                "Compliance Officer (si aplica)"
              ]
            }
          },
          {
            "name": "Diseño del Sistema y Software",
            "duration": "4-8 semanas",
            "activities": [
              "Diseño arquitectónico de alto nivel (estructura en capas)",
              "Diseño de interfaces entre componentes",
              "Diseño de componentes individuales (clases, módulos)",
              "Diseño de base de datos (si aplica)",
              "Diseño de seguridad y mecanismos de protección",
              "Análisis de modos de fallo (FMEA - Failure Mode and Effects Analysis)",
              "Diseño de algoritmos críticos",
              "Especificación de protocolos de comunicación",
              "Definición de estándares de codificación",
              "Planificación de pruebas (estrategia de verificación y validación)"
            ],
            "inputs": [
              "SRS aprobado",
              "Matriz de trazabilidad de requerimientos",
              "Restricciones de arquitectura (hardware, rendimiento, seguridad)",
              "Estándares de diseño organizacionales"
            ],
            "outputs": [
              "Documento de Diseño Arquitectónico (ADD - Architecture Design Document)",
              "Diagramas UML: Clases, Componentes, Despliegue, Secuencia",
              "Especificación de interfaces (APIs, protocolos)",
              "Documento de Diseño Detallado (DDD)",
              "Análisis FMEA completo",
              "Plan de Verificación y Validación (V&V Plan)",
              "Matriz de trazabilidad actualizada (requerimiento → diseño)"
            ],
            "gate": {
              "name": "Design Review Gate (Critical Design Review - CDR)",
              "criteria": [
                "Arquitectura satisface todos los requerimientos no funcionales",
                "Diseño pasa peer review formal",
                "FMEA identifica y mitiga riesgos críticos",
                "Interfaces bien definidas y documentadas",
                "Compliance con estándares de diseño verificado",
                "Trazabilidad completa de requerimiento a diseño"
              ],
              "approvers": [
                "Arquitecto Principal",
                "Equipo de Diseño",
                "Equipo de Calidad",
                "Gerente de Proyecto",
                "Cliente (si contrato lo requiere)"
              ]
            }
          },
          {
            "name": "Implementación y Prueba de Unidad",
            "duration": "14-20 semanas",
            "activities": [
              "Codificación siguiendo estándares definidos (MISRA C para embebidos, etc.)",
              "Desarrollo capa por capa (bottom-up o por criticidad)",
              "Pruebas unitarias exhaustivas (cobertura >95% en código crítico)",
              "Code reviews formales (inspecciones)",
              "Análisis estático de código (herramientas SAST)",
              "Gestión de configuración estricta (control de versiones)",
              "Documentación inline (comentarios, doxygen)",
              "Depuración (debugging) continua",
              "Integración continua en ambiente de desarrollo"
            ],
            "inputs": [
              "Documento de Diseño Detallado aprobado",
              "Estándares de codificación",
              "Ambiente de desarrollo configurado",
              "Plan de pruebas unitarias",
              "Herramientas de análisis estático"
            ],
            "outputs": [
              "Código fuente versionado y documentado",
              "Pruebas unitarias automatizadas",
              "Reportes de code reviews",
              "Reportes de análisis estático",
              "Métricas de cobertura de código",
              "Matriz de trazabilidad actualizada (diseño → código → prueba unitaria)"
            ],
            "gate": {
              "name": "Code Complete Gate",
              "criteria": [
                "100% del código implementado según diseño",
                "Cobertura de pruebas unitarias >95% en código crítico, >80% en no crítico",
                "Cero defectos críticos abiertos",
                "Code reviews completados para 100% del código",
                "Análisis estático sin violaciones críticas",
                "Documentación inline completa"
              ],
              "approvers": [
                "Líder Técnico",
                "Equipo de Calidad",
                "Gerente de Proyecto"
              ]
            }
          },
          {
            "name": "Integración y Prueba de Sistema",
            "duration": "6-10 semanas",
            "activities": [
              "Integración incremental de componentes (no Big Bang)",
              "Pruebas de integración entre componentes",
              "Pruebas de sistema completo (funcionales y no funcionales)",
              "Pruebas de regresión automatizadas",
              "Pruebas de rendimiento y stress",
              "Pruebas de seguridad y penetración",
              "Pruebas de confiabilidad (MTBF - Mean Time Between Failures)",
              "Pruebas de aceptación con cliente/usuarios",
              "Corrección de defectos encontrados",
              "Preparación de documentación de usuario"
            ],
            "inputs": [
              "Código completo e integrado",
              "Plan de V&V",
              "Casos de prueba derivados de requerimientos",
              "Ambiente de pruebas (que simula producción)"
            ],
            "outputs": [
              "Sistema completamente integrado y probado",
              "Reportes de pruebas (integración, sistema, aceptación)",
              "Defectos corregidos y cerrados",
              "Manual de usuario",
              "Manual de instalación y deployment",
              "Manual de mantenimiento",
              "Matriz de trazabilidad final (requerimiento → diseño → código → prueba)",
              "Certificación regulatoria (si aplica)"
            ],
            "gate": {
              "name": "System Acceptance Gate",
              "criteria": [
                "Todas las pruebas de sistema pasan",
                "Criterios de aceptación de requerimientos satisfechos",
                "Cero defectos críticos, <5 defectos menores",
                "Rendimiento y confiabilidad dentro de especificación",
                "Compliance regulatorio verificado",
                "Cliente/Sponsor aprueba sistema",
                "Documentación completa y revisada"
              ],
              "approvers": [
                "Cliente/Sponsor",
                "Equipo de Calidad",
                "Gerente de Proyecto",
                "Regulador (si aplica)"
              ]
            }
          },
          {
            "name": "Operación y Mantenimiento",
            "duration": "Continuo (vida útil del sistema)",
            "activities": [
              "Instalación en ambiente de producción",
              "Capacitación de usuarios y operadores",
              "Monitoreo de sistema en producción",
              "Soporte técnico 24/7 (si criticidad lo requiere)",
              "Mantenimiento correctivo (bug fixes)",
              "Mantenimiento adaptativo (cambios de entorno)",
              "Mantenimiento perfectivo (mejoras)",
              "Mantenimiento preventivo",
              "Actualizaciones de seguridad",
              "Auditorías periódicas de cumplimiento"
            ],
            "inputs": [
              "Sistema aprobado y documentado",
              "Manuales de usuario y mantenimiento",
              "Plan de soporte y mantenimiento",
              "Equipo de soporte capacitado"
            ],
            "outputs": [
              "Sistema operando en producción",
              "Logs de operación y monitoreo",
              "Reportes de incidentes y resoluciones",
              "Actualizaciones y parches",
              "Reportes de auditoría",
              "Lecciones aprendidas documentadas"
            ],
            "gate": {
              "name": "Go-Live Gate",
              "criteria": [
                "Sistema instalado y configurado correctamente",
                "Usuarios capacitados",
                "Soporte disponible",
                "Plan de rollback preparado",
                "Monitoreo en tiempo real funcionando",
                "Compliance verificado en producción"
              ],
              "approvers": [
                "Cliente/Sponsor",
                "Gerente de Operaciones",
                "Equipo de Soporte"
              ]
            }
          }
        ],
        "whenToUse": {
          "systemType": [
            "Sistemas críticos de seguridad (vidas humanas en riesgo)",
            "Sistemas médicos (dispositivos implantables, equipos de diagnóstico)",
            "Sistemas aviónicos (control de vuelo, navegación)",
            "Sistemas automotrices de seguridad (frenos ABS, airbags, ADAS)",
            "Sistemas de control industrial (plantas nucleares, químicas)",
            "Sistemas ferroviarios (señalización, control de trenes)"
          ],
          "requirements": [
            "Requerimientos estables y bien entendidos desde el inicio",
            "Requerimientos sujetos a regulación externa estricta",
            "Necesidad de especificación completa anticipada (contratos formales)",
            "Alta trazabilidad requerida (regulaciones)",
            "Requerimientos con poca probabilidad de cambio durante desarrollo"
          ],
          "team": [
            "Equipo grande (>20 personas) que requiere coordinación formal",
            "Equipos distribuidos geográficamente",
            "Múltiples stakeholders que requieren documentación formal",
            "Organización madura con procesos establecidos"
          ],
          "constraints": [
            "Desarrollo conjunto de hardware y software (co-design)",
            "Dependencias de hardware fijas",
            "Contratos de precio fijo que requieren especificación completa",
            "Necesidad de cumplimiento regulatorio estricto (FDA, FAA, ISO)"
          ]
        },
        "whenNotToUse": {
          "avoid": [
            "Requerimientos volátiles o mal entendidos",
            "Startups o innovación rápida (time-to-market crítico)",
            "Interfaces de usuario que necesitan experimentación",
            "Proyectos exploratorios o de investigación",
            "Sistemas donde la interfaz de usuario es el diferenciador clave",
            "Equipos pequeños ágiles (overhead excesivo)",
            "Proyectos de corta duración (<6 meses)",
            "Sistemas web/móviles con feedback de usuario continuo"
          ],
          "alternatives": [
            "Si requerimientos volátiles → Modelo Espiral o Incremental",
            "Si startup/MVP → Scrum o XP",
            "Si UI crítica → Desarrollo Incremental con prototipos",
            "Si equipo pequeño → Cascada Adaptado (menos overhead)"
          ]
        },
        "advantages": [
          "Documentación exhaustiva facilita mantenimiento a largo plazo (sistemas con vida útil de 10-20 años)",
          "Progreso medible y visible a través de documentos aprobados (ideal para contratos)",
          "Apropiado para equipos distribuidos (documentación compensa falta de comunicación directa)",
          "Cumplimiento regulatorio incorporado en cada fase",
          "Trazabilidad completa desde requerimiento hasta código y prueba",
          "Revisiones formales detectan errores temprano",
          "Adecuado para certificación (DO-178C, IEC 62304, ISO 26262)",
          "Reducción de riesgos en sistemas críticos (análisis exhaustivo antes de implementar)"
        ],
        "disadvantages": [
          "Difícil acomodar cambios una vez iniciada una fase (cambios son costosos)",
          "Iteraciones entre fases requieren rehacer documentos (overhead significativo)",
          "Cliente ve sistema funcionando solo al final (feedback tardío)",
          "Riesgo de 'congelamiento prematuro' de especificación → sistema puede no satisfacer necesidades reales",
          "Problemas de diseño pueden descubrirse tarde (en implementación o integración)",
          "No apto para sistemas donde la experimentación es necesaria",
          "Proceso pesado para equipos pequeños o proyectos cortos",
          "Dificultad para innovar o pivotar durante el desarrollo"
        ],
        "changeManagement": {
          "process": "Change Control Board (CCB) Formal",
          "description": "Todos los cambios a requerimientos, diseño o código después de baseline deben pasar por CCB",
          "steps": [
            "1. Solicitud de Cambio (CR - Change Request) formal con justificación",
            "2. Análisis de impacto (costo, tiempo, riesgo, trazabilidad)",
            "3. Evaluación por CCB (comité multidisciplinario)",
            "4. Aprobación/rechazo formal con justificación escrita",
            "5. Si aprobado: actualizar documentos (SRS, diseño, plan de pruebas)",
            "6. Implementar cambio siguiendo proceso estándar",
            "7. Verificar que el cambio satisface la solicitud",
            "8. Actualizar matriz de trazabilidad",
            "9. Comunicar a todos los afectados"
          ],
          "ccbComposition": [
            "Gerente de Proyecto (chair)",
            "Arquitecto Principal",
            "Líder de Calidad",
            "Representante del Cliente",
            "Compliance Officer (en proyectos regulados)"
          ],
          "frequency": "Reuniones semanales o según demanda (cambios críticos)",
          "tools": [
            "Jira con workflow de aprobación",
            "Azure DevOps Work Items",
            "IBM DOORS (trazabilidad)",
            "Sistema de gestión de configuración (Git con ramas protegidas)"
          ]
        },
        "tooling": {
          "requirements": [
            "IBM DOORS",
            "Jama Connect",
            "Polarion Requirements",
            "Azure DevOps"
          ],
          "design": [
            "Enterprise Architect",
            "Visual Paradigm",
            "IBM Rational Software Architect",
            "Sparx Systems"
          ],
          "development": [
            "Git (control de versiones)",
            "Jenkins/GitLab CI (integración continua)",
            "SonarQube (análisis estático)",
            "MISRA Checker (si C/C++)"
          ],
          "testing": [
            "VectorCAST (pruebas embebidas)",
            "LDRA (cobertura de código)",
            "Cantata (pruebas unitarias)",
            "Selenium (si tiene UI web)"
          ],
          "projectManagement": [
            "Microsoft Project",
            "Jira",
            "Azure DevOps",
            "Primavera P6"
          ],
          "documentation": [
            "Confluence",
            "SharePoint",
            "Doxygen (código)",
            "LaTeX/Word (documentos formales)"
          ]
        },
        "references": {
          "book": "Sommerville, Capítulo 2: Procesos de Software (Modelo en Cascada, sección 2.1.1)",
          "standards": [
            "IEEE 830-1998: Especificación de Requerimientos de Software",
            "DO-178C: Software Considerations in Airborne Systems (aviación)",
            "IEC 62304: Medical Device Software Lifecycle (dispositivos médicos)",
            "ISO 26262: Road Vehicles Functional Safety (automotriz)",
            "FDA 21 CFR Part 11: Electronic Records (farmacéutica)"
          ]
        }
      },
      "methodology": {
        "name": "Waterfall for Critical Systems (Plan-Driven with Safety Focus)",
        "description": "Variante del modelo Waterfall tradicional específicamente adaptada para sistemas críticos de alta seguridad (safety-critical, mission-critical) con requisitos estables y bien definidos. Énfasis en especificación formal exhaustiva mediante estándares como IEEE 830, análisis de seguridad y confiabilidad (FMEA - Failure Mode and Effects Analysis, FTA - Fault Tree Analysis), verificación y validación formal independiente (V&V), y gestión de configuración estricta con auditorías regulatorias. Cada fase incluye revisiones formales obligatorias con stakeholders y autoridades regulatorias (FDA, FAA, DoD dependiendo del dominio). Apropiado para proyectos donde fallas pueden resultar en pérdida de vidas, daño ambiental catastrófico o pérdidas económicas masivas (ej: control de reactores nucleares, sistemas de vuelo, dispositivos médicos implantables, sistemas financieros críticos).",
        "origin": {
          "creator": "Adaptación de Waterfall tradicional (Royce, 1970) con estándares de seguridad de industrias reguladas",
          "year": 1980,
          "context": "Evolucionó en industrias de alta seguridad (nuclear, aviación, defensa, medicina) en los años 1980s cuando reguladores (NRC, FAA, FDA) comenzaron a exigir documentación formal exhaustiva y trazabilidad completa para certificación de sistemas críticos. Estándares como DO-178B (aviación software, 1982), IEC 61508 (seguridad funcional, 1998), ISO 26262 (automotriz, 2011) formalizaron procesos de desarrollo rigurosos basados en Waterfall con énfasis en análisis de riesgos, hazard analysis y verificación independiente."
        },
        "principles": [
          "Especificación Formal de Requisitos exhaustiva usando estándares (IEEE 830, ISO/IEC 29148) con validación de stakeholders y revisión regulatoria",
          "Análisis de seguridad y confiabilidad obligatorio: FMEA (Failure Mode and Effects Analysis), FTA (Fault Tree Analysis), HAZOP (Hazard and Operability Study)",
          "Verificación y Validación (V&V) independiente: equipo separado del development team realiza testing formal sin conflicto de interés",
          "Gestión de Configuración estricta: control de cambios formal con CCB (Change Control Board), baseline management, traceability matrix completa",
          "Revisiones de diseño formales en cada fase: PDR (Preliminary Design Review), CDR (Critical Design Review) con aprobación de stakeholders/reguladores",
          "Certificación regulatoria: cumplimiento con estándares de seguridad (DO-178C, IEC 61508, ISO 26262) y auditorías de autoridades regulatorias (FAA, FDA, NRC)"
        ],
        "differentiators": [
          "vs Waterfall estándar: Mayor énfasis en análisis de seguridad (FMEA, FTA), V&V independiente obligatoria y certificación regulatoria formal",
          "vs Ágil: Cambios están altamente restringidos después de aprobación de requisitos (change control estricto) para mantener integridad de análisis de seguridad",
          "vs Híbrido Regulado (rec-013): Puramente secuencial sin iteraciones en implementación, mientras rec-013 permite desarrollo incremental controlado"
        ],
        "references": {
          "chapter": "chapter-2, chapter-24",
          "sections": [
            "2.1 Plan-driven and agile development",
            "2.2 The waterfall model",
            "24.3 Safety and dependability requirements",
            "24.4 Safety engineering"
          ],
          "externalResources": [
            "IEEE 830-1998: IEEE Recommended Practice for Software Requirements Specifications",
            "DO-178C: Software Considerations in Airborne Systems and Equipment Certification",
            "IEC 61508: Functional Safety of Electrical/Electronic/Programmable Electronic Safety-related Systems",
            "ISO 26262: Road vehicles - Functional safety",
            "Leveson, N. G. (2011). Engineering a Safer World: Systems Thinking Applied to Safety. MIT Press"
          ]
        }
      },
      "modeling": {
        "notations": [
          {
            "name": "UML",
            "description": "Unified Modeling Language para modelado estructural y comportamental completo con énfasis en trazabilidad.",
            "diagrams": [
              "Use Case Diagram",
              "Class Diagram",
              "Sequence Diagram",
              "State Machine Diagram",
              "Deployment Diagram"
            ],
            "whenToUse": "Sistemas críticos requieren documentación formal exhaustiva de requisitos (use cases), diseño (class/sequence) y deployment para certificación regulatoria",
            "tools": [
              "Enterprise Architect",
              "IBM Rational",
              "Visual Paradigm",
              "PlantUML"
            ]
          },
          {
            "name": "Traceability Matrix",
            "description": "Matriz que liga requisitos → diseño → código → tests para compliance regulatorio.",
            "diagrams": [
              "Traceability Matrix (tabla/diagrama)",
              "Requirements Coverage Matrix"
            ],
            "whenToUse": "Sistemas críticos regulados (FDA, FAA, DO-178C) que requieren demostrar trazabilidad completa",
            "tools": [
              "IBM DOORS",
              "Jama Connect",
              "Polarion",
              "Excel con macros"
            ]
          },
          {
            "name": "FMEA (Failure Mode and Effects Analysis)",
            "description": "Análisis de modos de falla: qué puede fallar, probabilidad, severidad, detección, mitigación.",
            "diagrams": [
              "FMEA Table",
              "FTA (Fault Tree Analysis)",
              "HAZOP"
            ],
            "whenToUse": "Análisis obligatorio en sistemas críticos para identificar y mitigar riesgos de seguridad (safety)",
            "tools": [
              "Relyence",
              "XFMEA",
              "RAM Commander",
              "Excel"
            ]
          }
        ],
        "primaryFocus": "Documentación formal exhaustiva con trazabilidad completa (requisitos → diseño → código → tests) y análisis de riesgos (FMEA/FTA)",
        "references": {
          "chapter": "chapter-24",
          "sections": [
            "24.2 Dependability engineering",
            "24.3 Safety and dependability requirements"
          ]
        }
      },
      "architecture": {
        "patterns": [
          {
            "name": "Layered (N-Tier)",
            "description": "Arquitectura en capas (Presentation, Business Logic, Data Access) con separación clara de responsabilidades.",
            "advantages": [
              "Separación de concerns (UI, lógica de negocio, datos)",
              "Facilita testing de cada capa independientemente",
              "Reusabilidad de lógica de negocio entre diferentes interfaces",
              "Facilita mantenimiento (cambios en UI no afectan datos)",
              "Facilita auditorías regulatorias (cada capa auditable independientemente)"
            ],
            "disadvantages": [
              "Performance overhead (múltiples capas añaden latencia)",
              "Over-engineering para sistemas simples",
              "Acoplamiento entre capas puede generar rigidez"
            ],
            "whenToUse": "Sistemas críticos con lógica de negocio compleja y necesidad de auditoría por capa",
            "tradeoffs": "Mantenibilidad y separación de concerns vs Performance (latencia de múltiples capas)"
          },
          {
            "name": "Redundancy Patterns (High Availability)",
            "description": "Redundancia de componentes críticos (active-active, active-passive, N+1) para alta disponibilidad.",
            "advantages": [
              "Alta disponibilidad (99.9%+ uptime)",
              "Tolerancia a fallos (failover automático)",
              "Mantenimiento sin downtime (rolling updates)",
              "Cumple requisitos de sistemas críticos (no single point of failure)"
            ],
            "disadvantages": [
              "Costo de infraestructura (servidores/componentes redundantes)",
              "Complejidad de configuración y failover",
              "Sincronización de estado entre réplicas (consistency challenges)"
            ],
            "whenToUse": "Sistemas críticos donde downtime no es aceptable (healthcare, control industrial, finanzas)",
            "tradeoffs": "Alta disponibilidad y tolerancia a fallos vs Costo de infraestructura"
          }
        ],
        "style": "Monolito modular con redundancia y auditoría completa",
        "qualityAttributes": {
          "scalability": "Medium - Prioridad es compliance y disponibilidad, no escalamiento masivo. Vertical scaling suficiente con redundancia N+1.",
          "maintainability": "Very High - Documentación formal exhaustiva (SRS, SDD, traceability matrix) facilita mantenimiento. Código auditado regularmente.",
          "performance": "Medium - Overhead de logging/auditoría. Optimización secundaria a safety y compliance. Latencia aceptable en sistemas críticos.",
          "security": "Very High - Controles estrictos (autenticación multi-factor, autorización granular, encriptación AES-256, auditoría completa). Cumple DO-178C, IEC 61508."
        },
        "references": {
          "chapter": "chapter-24",
          "sections": [
            "24.4 Safety assurance",
            "24.5 Security and dependability"
          ]
        }
      },
      "timeline": [
        {
          "week": "1-2",
          "phase": "Inicio y Planificación",
          "tasks": [
            "Kickoff con stakeholders principales",
            "Identificar todos los módulos del sistema",
            "Definir criterios de aceptación",
            "Establecer equipo y roles",
            "Setup de infraestructura"
          ]
        },
        {
          "week": "3-6",
          "phase": "Especificación Completa",
          "tasks": [
            "Documento de requerimientos IEEE 830",
            "Revisión formal con stakeholders",
            "Validación contra estándares regulatorios",
            "Casos de uso detallados",
            "Especificación de interfaces"
          ]
        },
        {
          "week": "7-10",
          "phase": "Diseño Arquitectónico",
          "tasks": [
            "Arquitectura en capas completa",
            "Diseño de componentes críticos",
            "Análisis FMEA",
            "Revisión formal de diseño",
            "Prototipo técnico (si es necesario)"
          ]
        },
        {
          "week": "11-24",
          "phase": "Implementación",
          "tasks": [
            "Desarrollo capa por capa",
            "Pruebas unitarias exhaustivas",
            "Code reviews formales",
            "Documentación inline",
            "Gestión de configuración estricta"
          ]
        },
        {
          "week": "25-30",
          "phase": "Integración y Pruebas",
          "tasks": [
            "Integración incremental",
            "Pruebas de sistema exhaustivas",
            "Pruebas de seguridad",
            "Validación con regulador",
            "Documentación de usuario"
          ]
        },
        {
          "week": "31+",
          "phase": "Deployment y Mantenimiento",
          "tasks": [
            "Instalación controlada",
            "Capacitación",
            "Soporte 24/7",
            "Mantenimiento correctivo",
            "Updates de seguridad"
          ]
        }
      ],
      "avoid": [
        "Ágil puro (requisitos críticos deben estar completamente especificados)",
        "Big Bang Integration (integrar todo al final es riesgoso)",
        "Sin trazabilidad (requisito → diseño → código → prueba)",
        "Skipping formal reviews (requerido por regulaciones)",
        "Cambios no documentados",
        "Testing insuficiente"
      ],
      "templates": [
        "tpl-001",
        "tpl-003",
        "tpl-006",
        "tpl-009",
        "tpl-011"
      ],
      "chapters": [
        1,
        2,
        3,
        4,
        5,
        6
      ]
    },
    "rec-002": {
      "id": "rec-002",
      "title": "Sistema Crítico → Estables → Pequeño",
      "path": [
        "Crítico",
        "Estables",
        "Pequeño"
      ],
      "pathDescription": "Sistema Crítico de Seguridad → Requisitos Estables → Equipo Pequeño (<10)",
      "process": {
        "name": "Cascada Adaptado",
        "type": "sequential-phases",
        "description": "Modelo en Cascada adaptado para equipos pequeños: mantiene la especificación completa y verificación rigurosa necesarias para sistemas críticos, pero con documentación más concisa y procesos menos burocráticos aprovechando la comunicación directa de equipos pequeños.",
        "chapter": 2,
        "why": [
          "Equipo pequeño permite documentación menos pesada",
          "Comunicación directa reduce necesidad de documentos extensos",
          "Mantiene verificación rigurosa pero con menos overhead",
          "Criticidad sigue requiriendo especificación completa"
        ],
        "how": [
          "Fase 1: Especificación (2-3 semanas) → Documento conciso",
          "Fase 2: Diseño (2-3 semanas) → Arquitectura + diseño componentes críticos",
          "Fase 3: Implementación (8-12 semanas) → Código con estándares + testing continuo",
          "Fase 4: Integración y Pruebas (3-4 semanas) → Testing exhaustivo",
          "Fase 5: Deployment → Instalación y documentación"
        ],
        "phases": [
          {
            "id": "phase-spec",
            "name": "Especificación de Requerimientos",
            "order": 1,
            "description": "Definir requerimientos completos de manera concisa, enfocándose en lo esencial sin sacrificar claridad ni rigor",
            "duration": "10-15% del proyecto (2-3 semanas)",
            "activities": [
              "Entrevistas con stakeholders clave (equipo pequeño permite acceso directo)",
              "Especificación de requerimientos funcionales y no funcionales",
              "Identificación de casos de uso críticos (5-8 principales)",
              "Análisis de riesgos de seguridad inicial",
              "Definición de criterios de aceptación medibles",
              "Revisión colaborativa del equipo (sesión conjunta)"
            ],
            "inputs": [
              "Necesidad del negocio y alcance inicial",
              "Estándares de seguridad aplicables (ISO, IEC, etc.)",
              "Restricciones de hardware (si aplica)",
              "Lecciones aprendidas de proyectos similares"
            ],
            "outputs": [
              "Documento de Requerimientos (10-15 páginas, formato conciso)",
              "Casos de uso principales documentados",
              "Análisis de riesgos de seguridad",
              "Criterios de aceptación por requerimiento"
            ],
            "deliverables": [
              {
                "name": "Especificación de Requerimientos Concisa",
                "template": "tpl-002",
                "required": true,
                "reviewedBy": [
                  "Líder Técnico",
                  "Stakeholder Principal"
                ]
              }
            ],
            "gate": {
              "name": "Requirements Approval",
              "criteria": [
                "Todos los requerimientos críticos de seguridad identificados",
                "Criterios de aceptación definidos y medibles",
                "Riesgos de seguridad documentados",
                "Consenso del equipo completo sobre el alcance"
              ],
              "decision": "GO / NO-GO / CLARIFICAR"
            },
            "keyStakeholders": [
              "Líder Técnico",
              "Cliente/Usuario Final",
              "Equipo Completo"
            ]
          },
          {
            "id": "phase-design",
            "name": "Diseño del Sistema",
            "order": 2,
            "description": "Diseñar arquitectura y componentes críticos con énfasis en claridad y seguridad",
            "duration": "15-20% del proyecto (2-3 semanas)",
            "activities": [
              "Diseño arquitectónico de alto nivel (3 capas típicamente)",
              "Diseño de componentes críticos de seguridad",
              "Especificación de interfaces entre componentes",
              "Selección de tecnología y herramientas",
              "Diseño de estrategia de testing",
              "Prototipo técnico (spike) para validar arquitectura",
              "Sesión de revisión de diseño con todo el equipo"
            ],
            "inputs": [
              "Documento de Requerimientos aprobado",
              "Análisis de riesgos de seguridad",
              "Estándares de codificación organizacionales",
              "Tecnologías disponibles/aprobadas"
            ],
            "outputs": [
              "Documento de Diseño Arquitectónico (diagrama + README detallado)",
              "Especificación de interfaces",
              "Prototipo técnico validado",
              "Plan de testing",
              "Decisiones de tecnología documentadas"
            ],
            "deliverables": [
              {
                "name": "Arquitectura Documentada",
                "template": "tpl-003",
                "required": true,
                "reviewedBy": [
                  "Equipo Completo"
                ]
              },
              {
                "name": "Prototipo Técnico",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Líder Técnico"
                ]
              }
            ],
            "gate": {
              "name": "Design Review",
              "criteria": [
                "Arquitectura satisface requerimientos de seguridad",
                "Interfaces bien definidas",
                "Prototipo técnico valida decisiones arquitectónicas",
                "Equipo completo aprueba el diseño",
                "Plan de testing aprobado"
              ],
              "decision": "GO / ITERAR DISEÑO"
            },
            "keyStakeholders": [
              "Líder Técnico",
              "Equipo de Desarrollo Completo"
            ]
          },
          {
            "id": "phase-implementation",
            "name": "Implementación y Pruebas Unitarias",
            "order": 3,
            "description": "Desarrollo con estándares estrictos, testing continuo y code reviews obligatorios",
            "duration": "50-60% del proyecto (8-12 semanas)",
            "activities": [
              "Codificación siguiendo estándares (MISRA C, CERT C, etc.)",
              "Desarrollo con TDD (Test-Driven Development)",
              "Code reviews mediante Pull Requests (mínimo 1 reviewer)",
              "Pruebas unitarias automatizadas (cobertura >95% código crítico)",
              "Integración continua (CI) con testing automático",
              "Análisis estático de código automático",
              "Documentación inline y README por módulo",
              "Reuniones semanales de progreso (1 hora máximo)"
            ],
            "inputs": [
              "Diseño arquitectónico aprobado",
              "Estándares de codificación",
              "Repositorio configurado con CI/CD",
              "Plan de testing"
            ],
            "outputs": [
              "Código fuente completo y versionado",
              "Pruebas unitarias automatizadas (cobertura >95% crítico)",
              "Reportes de code reviews (todos los PRs aprobados)",
              "Reportes de análisis estático (sin defectos críticos)",
              "Documentación técnica inline"
            ],
            "deliverables": [
              {
                "name": "Código Completo con Pruebas",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Líder Técnico",
                  "Pares"
                ]
              },
              {
                "name": "Reporte de Cobertura de Pruebas",
                "template": "tpl-011",
                "required": true,
                "reviewedBy": [
                  "Líder Técnico"
                ]
              }
            ],
            "gate": {
              "name": "Code Complete",
              "criteria": [
                "100% del código implementado",
                "Cobertura de pruebas >95% en código crítico, >80% en no crítico",
                "Todos los PRs revisados y aprobados",
                "Análisis estático sin defectos críticos",
                "CI/CD pasando consistentemente"
              ],
              "decision": "GO / CORREGIR DEFECTOS"
            },
            "keyStakeholders": [
              "Líder Técnico",
              "Equipo de Desarrollo"
            ]
          },
          {
            "id": "phase-integration-testing",
            "name": "Integración y Pruebas de Sistema",
            "order": 4,
            "description": "Integración completa del sistema y testing exhaustivo incluyendo escenarios críticos de seguridad",
            "duration": "15-20% del proyecto (3-4 semanas)",
            "activities": [
              "Integración incremental de componentes",
              "Pruebas de integración entre componentes",
              "Pruebas de sistema completo (casos de uso end-to-end)",
              "Pruebas de seguridad (boundary testing, fault injection)",
              "Pruebas de rendimiento (si aplica)",
              "Pruebas de confiabilidad (stress testing limitado)",
              "Validación contra criterios de aceptación",
              "Corrección de defectos encontrados",
              "Documentación de usuario (manual conciso)"
            ],
            "inputs": [
              "Código completo y probado unitariamente",
              "Plan de testing",
              "Casos de prueba derivados de requerimientos",
              "Ambiente de testing configurado"
            ],
            "outputs": [
              "Sistema completamente integrado",
              "Reportes de pruebas (integración, sistema, seguridad)",
              "Defectos corregidos y verificados",
              "Manual de usuario conciso",
              "Documentación de deployment"
            ],
            "deliverables": [
              {
                "name": "Reporte de Pruebas del Sistema",
                "template": "tpl-011",
                "required": true,
                "reviewedBy": [
                  "Líder Técnico",
                  "Cliente"
                ]
              },
              {
                "name": "Manual de Usuario",
                "template": "tpl-006",
                "required": true,
                "reviewedBy": [
                  "Cliente/Usuario Final"
                ]
              }
            ],
            "gate": {
              "name": "System Acceptance",
              "criteria": [
                "Todas las pruebas de sistema pasan",
                "Criterios de aceptación satisfechos",
                "Cero defectos críticos abiertos",
                "Defectos menores aceptados por cliente",
                "Documentación completa y revisada",
                "Cliente aprueba el sistema"
              ],
              "decision": "GO TO PRODUCTION / FIX & RE-TEST"
            },
            "keyStakeholders": [
              "Líder Técnico",
              "Cliente/Usuario Final",
              "Equipo Completo"
            ]
          },
          {
            "id": "phase-deployment",
            "name": "Deployment y Soporte Inicial",
            "order": 5,
            "description": "Instalación en producción, capacitación y soporte post-lanzamiento",
            "duration": "10% del proyecto + soporte continuo",
            "activities": [
              "Instalación en ambiente de producción",
              "Capacitación a usuarios finales y operadores",
              "Período de supervisión post-deployment (2-4 semanas)",
              "Soporte para resolución de issues iniciales",
              "Monitoreo de sistema en producción",
              "Documentación de lecciones aprendidas",
              "Planificación de mantenimiento futuro"
            ],
            "inputs": [
              "Sistema aprobado y documentado",
              "Manual de usuario",
              "Plan de deployment",
              "Ambiente de producción preparado"
            ],
            "outputs": [
              "Sistema operando en producción",
              "Usuarios capacitados",
              "Logs de operación inicial",
              "Issues post-lanzamiento resueltos",
              "Documentación de lecciones aprendidas",
              "Plan de mantenimiento"
            ],
            "deliverables": [
              {
                "name": "Sistema en Producción",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Cliente",
                  "Operadores"
                ]
              },
              {
                "name": "Reporte de Lecciones Aprendidas",
                "template": null,
                "required": false,
                "reviewedBy": [
                  "Equipo Completo"
                ]
              }
            ],
            "gate": {
              "name": "Go-Live",
              "criteria": [
                "Sistema instalado correctamente",
                "Usuarios capacitados",
                "Plan de rollback disponible",
                "Soporte disponible durante período inicial",
                "Cliente acepta go-live"
              ],
              "decision": "GO-LIVE / POSTPONE"
            },
            "keyStakeholders": [
              "Cliente",
              "Usuarios Finales",
              "Equipo de Soporte"
            ]
          }
        ],
        "whenToUse": [
          "✅ Sistema crítico de seguridad con vidas o activos en riesgo",
          "✅ Equipo pequeño (5-10 personas) co-localizado",
          "✅ Requerimientos estables y bien entendidos",
          "✅ Necesidad de cumplimiento regulatorio (FDA, aviación, automotriz)",
          "✅ Comunicación directa posible entre todos los miembros",
          "✅ Proyecto de duración media (3-6 meses)",
          "✅ Criticidad requiere especificación completa pero equipo pequeño permite agilidad",
          "✅ Cultura de equipo que valora rigor pero rechaza burocracia excesiva",
          "✅ Tecnología conocida y estable",
          "✅ Restricciones de hardware conocidas desde el inicio"
        ],
        "whenNotToUse": [
          "❌ Equipo grande (>10 personas) que requiere coordinación formal",
          "❌ Equipo distribuido geográficamente (documentación ligera es insuficiente)",
          "❌ Requerimientos volátiles o mal entendidos",
          "❌ Startups o proyectos exploratorios (demasiado overhead)",
          "❌ Sistemas donde experimentación de UI es clave",
          "❌ Proyectos de muy corta duración (<3 meses) donde especificación completa consume mucho tiempo",
          "❌ Sistemas no críticos donde metodologías ágiles puras son más eficientes",
          "❌ Necesidad de demos frecuentes a stakeholders (cascada entrega al final)",
          "❌ Alta incertidumbre tecnológica que requiere prototipado exploratorio",
          "❌ Múltiples stakeholders con intereses conflictivos (requiere documentación más formal)"
        ],
        "advantages": [
          "✅ Especificación completa reduce ambigüedad y errores de interpretación",
          "✅ Documentación concisa pero suficiente para cumplimiento regulatorio",
          "✅ Code reviews obligatorios mejoran calidad y compartir conocimiento",
          "✅ Testing exhaustivo apropiado para criticidad del sistema",
          "✅ Menor overhead burocrático que Cascada tradicional",
          "✅ Comunicación directa del equipo pequeño compensa documentación ligera",
          "✅ CI/CD automatiza verificación continua sin sobrecarga manual",
          "✅ Proceso disciplinado pero pragmático",
          "✅ Trazabilidad de requerimiento a código y pruebas",
          "✅ Apropiado para certificación con menos costo que procesos más pesados"
        ],
        "disadvantages": [
          "❌ Cambios de requerimientos son costosos (requieren actualizar documentación)",
          "❌ Cliente ve sistema funcionando solo al final (riesgo de desalineación)",
          "❌ Requiere disciplina del equipo para mantener rigor sin burocracia",
          "❌ Documentación ligera puede ser insuficiente para proyectos muy complejos",
          "❌ No apto para innovación rápida o experimentación",
          "❌ Riesgo de sub-documentación si equipo interpreta 'ligero' como 'opcional'",
          "❌ Escalabilidad limitada: proceso no funciona bien si equipo crece >10 personas",
          "❌ Difícil onboarding de nuevos miembros con documentación concisa"
        ],
        "changeManagement": {
          "approach": "Change Control Simplificado para Equipos Pequeños",
          "description": "Gestión de cambios formal pero ágil: todos los cambios significativos se documentan y aprueban, pero el proceso es rápido aprovechando el tamaño pequeño del equipo",
          "process": [
            {
              "step": 1,
              "name": "Solicitud de Cambio",
              "action": "Cualquier miembro documenta el cambio propuesto en issue tracker (Jira, GitHub Issues)",
              "responsible": "Cualquier miembro del equipo",
              "artifacts": [
                "Issue con descripción del cambio",
                "Justificación técnica o de negocio"
              ],
              "timeframe": "5-10 minutos"
            },
            {
              "step": 2,
              "name": "Análisis de Impacto Rápido",
              "action": "Líder técnico analiza impacto en requerimientos, diseño, código, testing",
              "responsible": "Líder Técnico",
              "artifacts": [
                "Comentario en issue con análisis de impacto",
                "Estimación de esfuerzo"
              ],
              "timeframe": "30 minutos - 2 horas"
            },
            {
              "step": 3,
              "name": "Decisión del Equipo",
              "action": "Reunión rápida del equipo completo (15-30 min) o decisión asíncrona si es menor",
              "responsible": "Equipo Completo (decisión por consenso)",
              "artifacts": [
                "Decisión documentada en issue (Aprobado/Rechazado/Diferido)"
              ],
              "timeframe": "Mismo día o máximo 24 horas"
            },
            {
              "step": 4,
              "name": "Actualización de Documentación",
              "action": "Si aprobado, actualizar documentación afectada (Requerimientos, Diseño, README)",
              "responsible": "Persona que propone el cambio",
              "artifacts": [
                "Documentos actualizados",
                "Commit en control de versiones"
              ],
              "timeframe": "Antes de implementar el cambio"
            },
            {
              "step": 5,
              "name": "Implementación",
              "action": "Implementar cambio siguiendo proceso estándar (TDD, PR, code review)",
              "responsible": "Desarrollador asignado",
              "artifacts": [
                "Código",
                "Pruebas",
                "Pull Request"
              ],
              "timeframe": "Según estimación"
            },
            {
              "step": 6,
              "name": "Verificación",
              "action": "Verificar que el cambio satisface la solicitud y no introduce regresiones",
              "responsible": "Reviewer + Líder Técnico",
              "artifacts": [
                "Pruebas pasando",
                "Aprobación del PR"
              ],
              "timeframe": "1-2 días"
            }
          ],
          "tools": [
            "Jira / GitHub Issues (tracking de cambios)",
            "Git (control de versiones)",
            "Slack / MS Teams (comunicación rápida)",
            "Google Docs / Confluence (documentación)"
          ],
          "ccbComposition": [
            "Líder Técnico (facilitador)",
            "Equipo Completo (decisión por consenso)",
            "Cliente/Stakeholder (para cambios mayores de alcance)"
          ],
          "frequency": "On-demand (decisiones rápidas, típicamente <24 horas)",
          "timeExpectation": "Cambios menores: mismo día. Cambios mayores: 2-3 días desde solicitud hasta aprobación"
        },
        "iterationStrategy": {
          "type": "none",
          "description": "Modelo secuencial sin iteraciones formales, pero con retroalimentación rápida dentro de cada fase gracias al tamaño pequeño del equipo"
        },
        "tooling": {
          "required": [
            "Git (control de versiones)",
            "GitHub/GitLab (code hosting + CI/CD)",
            "Análisis estático (SonarQube, Coverity, o MISRA checker)",
            "Testing framework (JUnit, pytest, Google Test, etc.)"
          ],
          "recommended": [
            "Jira / GitHub Projects (tracking)",
            "Slack / MS Teams (comunicación)",
            "PlantUML / Mermaid (diagramas versionables)",
            "Doxygen / Sphinx (documentación de código)",
            "Confluence / Notion (documentación colaborativa)"
          ]
        },
        "references": {
          "chapter": "Capítulo 2",
          "sections": [
            "Sección 2.1.1: Modelo en Cascada",
            "Sección 2.2.1: Especificación, Desarrollo y Validación"
          ],
          "relatedConcepts": [
            "concept-waterfall",
            "concept-requirements-engineering",
            "concept-verification-validation"
          ]
        }
      },
      "methodology": {
        "name": "Waterfall Model (Plan-Driven Development)",
        "description": "Modelo secuencial lineal donde cada fase debe completarse antes de iniciar la siguiente. Cada fase tiene entradas, procesos y salidas bien definidos, con énfasis en planificación upfront, documentación exhaustiva y predictibilidad del cronograma y presupuesto. Apropiado para proyectos con requisitos bien definidos y estables desde el inicio, donde los cambios son costosos y deben minimizarse. El modelo fue originalmente propuesto por Winston Royce en 1970 como ejemplo de cómo NO hacer desarrollo (porque carecía de feedback loops), pero la industria lo adoptó como modelo estándar durante las siguientes décadas. Las fases típicas son: Requirements → Design → Implementation → Testing → Deployment → Maintenance, con verificación y validación formal al final de cada fase mediante gates de aprobación.",
        "origin": {
          "creator": "Winston W. Royce (adaptación de modelo original de ingeniería tradicional)",
          "year": 1970,
          "context": "Propuesto en el paper 'Managing the Development of Large Software Systems' presentado en IEEE WESCON. Irónicamente, Royce propuso el modelo como ejemplo de un enfoque deficiente (sin iteraciones ni feedback loops), pero la industria lo adoptó literalmente como estándar durante décadas, especialmente en proyectos gubernamentales y de defensa que requerían documentación exhaustiva y auditorías formales."
        },
        "principles": [
          "Fases secuenciales estrictas: Requirements → Design → Implementation → Testing → Deployment → Maintenance (cada fase debe completarse antes de la siguiente)",
          "Documentación formal exhaustiva en cada fase: SRS (Software Requirements Specification), SDD (Software Design Document), Test Plans, User Manuals, etc.",
          "Verificación y validación al final de cada fase mediante gates con criterios de entrada/salida (stage gates)",
          "Cambios son costosos y requieren volver a fases anteriores (change control formal con CCB - Change Control Board)",
          "Predictibilidad upfront: tiempo, costo y alcance estimados al inicio con alta precisión basada en requirements completos",
          "Entrega única al final del proyecto (big-bang deployment) después de completar todas las fases"
        ],
        "differentiators": [
          "vs Ágil: Waterfall prioriza documentación formal y planificación upfront exhaustiva, mientras Ágil prioriza working software incremental y adaptación continua a cambios",
          "vs Incremental: Waterfall entrega una sola vez al final (big-bang), mientras Incremental entrega múltiples veces con funcionalidad incremental",
          "vs Espiral: Waterfall no tiene gestión explícita de riesgos ni construcción de prototipos obligatorios, mientras Espiral centra cada ciclo en análisis de riesgos"
        ],
        "references": {
          "chapter": "chapter-2",
          "sections": [
            "2.1 Plan-driven and agile development",
            "2.2 The waterfall model"
          ],
          "externalResources": [
            "Royce, W. W. (1970). Managing the Development of Large Software Systems. Proceedings of IEEE WESCON",
            "Sommerville, I. (2016). Software Engineering (10th ed.), Chapter 2"
          ]
        }
      },
      "modeling": {
        "notations": [
          {
            "name": "UML",
            "description": "Unified Modeling Language para modelado estructural y comportamental completo.",
            "diagrams": [
              "Use Case Diagram",
              "Class Diagram",
              "Sequence Diagram",
              "State Machine Diagram",
              "Deployment Diagram"
            ],
            "whenToUse": "Sistemas transaccionales requieren documentación formal de requisitos (use cases), diseño de BD (class diagrams) y flujos transaccionales (sequence diagrams)",
            "tools": [
              "Enterprise Architect",
              "Visual Paradigm",
              "Lucidchart",
              "PlantUML"
            ]
          },
          {
            "name": "ERD (Entity-Relationship Diagram)",
            "description": "Modelado de base de datos relacional (entidades, relaciones, cardinalidad, normalización).",
            "diagrams": [
              "ERD",
              "Relational Schema",
              "Data Dictionary"
            ],
            "whenToUse": "Sistemas transaccionales con bases de datos complejas (normalización 3NF, integridad referencial, índices)",
            "tools": [
              "MySQL Workbench",
              "dbdiagram.io",
              "Lucidchart",
              "ER/Studio"
            ]
          }
        ],
        "primaryFocus": "Documentación formal completa de requisitos, diseño de base de datos y flujos transaccionales",
        "references": {
          "chapter": "chapter-5",
          "sections": [
            "5.2 UML diagrams",
            "5.3 Use case modeling"
          ]
        }
      },
      "architecture": {
        "patterns": [
          {
            "name": "Layered (N-Tier)",
            "description": "Arquitectura en capas (Presentation, Business Logic, Data Access) con separación clara de responsabilidades.",
            "advantages": [
              "Separación de concerns (UI, lógica de negocio, datos)",
              "Facilita testing de cada capa independientemente",
              "Reusabilidad de lógica de negocio entre diferentes interfaces",
              "Facilita mantenimiento (cambios en UI no afectan datos)"
            ],
            "disadvantages": [
              "Performance overhead (múltiples capas añaden latencia)",
              "Over-engineering para sistemas simples",
              "Acoplamiento entre capas puede generar rigidez"
            ],
            "whenToUse": "Sistemas transaccionales con lógica de negocio compleja y múltiples interfaces (web, móvil, API)",
            "tradeoffs": "Mantenibilidad y separación de concerns vs Performance (latencia de múltiples capas)"
          },
          {
            "name": "MVC (Model-View-Controller)",
            "description": "Patrón que separa datos (Model), presentación (View) y lógica de control (Controller).",
            "advantages": [
              "Separación clara entre datos y presentación",
              "Facilita testing de lógica de negocio (Model)",
              "Múltiples vistas pueden usar mismo modelo",
              "Evolución independiente de UI y lógica de negocio"
            ],
            "disadvantages": [
              "Controllers pueden volverse muy grandes (fat controllers)",
              "Curva de aprendizaje para desarrolladores nuevos",
              "Overhead de coordinación entre componentes"
            ],
            "whenToUse": "Aplicaciones web transaccionales con múltiples vistas sobre los mismos datos",
            "tradeoffs": "Separación de concerns vs Complejidad de coordinación entre componentes"
          }
        ],
        "style": "Monolito modularizado (módulos separados por dominio de negocio)",
        "qualityAttributes": {
          "scalability": "Medium - Escalamiento vertical (más RAM/CPU al servidor). Escalamiento horizontal difícil con monolito. Load balancer con sticky sessions.",
          "maintainability": "High - Arquitectura en capas facilita localizar y modificar código. Separación de concerns clara. Refactoring seguro con tests.",
          "performance": "Medium-High - Latencia de múltiples capas, pero optimizable con caching (Redis) y database indexing. Queries SQL optimizadas críticas.",
          "security": "High - Autenticación/autorización en capa de negocio. SQL injection prevention con ORMs/prepared statements. HTTPS obligatorio. Session management."
        },
        "references": {
          "chapter": "chapter-6",
          "sections": [
            "6.3 Application architectures",
            "6.4 Architectural patterns"
          ]
        }
      },
      "timeline": [
        {
          "week": "1",
          "phase": "Especificación",
          "tasks": [
            "Documento de requisitos (10 páginas máximo)",
            "Casos de uso principales (5-8 casos)",
            "Análisis de riesgos de seguridad"
          ]
        },
        {
          "week": "2-3",
          "phase": "Diseño",
          "tasks": [
            "Diseño arquitectónico (diagrama + README)",
            "Selección de tecnología",
            "Setup de repo con CI/CD",
            "Primer prototipo técnico (spike)"
          ]
        },
        {
          "week": "4-12",
          "phase": "Implementación",
          "tasks": [
            "Implementación con TDD",
            "Code reviews semanales",
            "Testing continuo",
            "Documentación inline"
          ]
        },
        {
          "week": "13-16",
          "phase": "Testing y Deployment",
          "tasks": [
            "Testing de sistema exhaustivo",
            "Validación con regulador (si aplica)",
            "Documentación de usuario",
            "Deployment"
          ]
        }
      ],
      "avoid": [
        "Documentación IEEE 830 completa (demasiado peso)",
        "Múltiples niveles de aprobación (cuello de botella)",
        "Metodologías ágiles (criticidad requiere especificación completa)",
        "Modelado exhaustivo de cada detalle",
        "Revisiones formales muy pesadas"
      ],
      "templates": [
        "tpl-002",
        "tpl-003",
        "tpl-006",
        "tpl-011"
      ],
      "chapters": [
        2,
        4,
        5,
        6
      ]
    },
    "rec-003": {
      "id": "rec-003",
      "title": "Sistema Crítico → Volátiles (RIESGO ALTO)",
      "path": [
        "Crítico",
        "Volátiles"
      ],
      "pathDescription": "Sistema Crítico de Seguridad → Requisitos Volátiles (⚠️ CONFLICTO)",
      "warning": "⚠️ Combinación crítico + volátil es extremadamente riesgosa. Se recomienda Modelo Espiral con gestión exhaustiva de riesgos.",
      "process": {
        "name": "Spiral Model (Boehm)",
        "type": "risk-driven",
        "description": "Modelo de proceso orientado a gestión de riesgos que combina desarrollo iterativo con análisis sistemático de riesgos en cada ciclo. Cada iteración atraviesa 4 sectores: Objetivos, Análisis de Riesgos, Desarrollo/Verificación, Planificación. Enfocado en proyectos con alta incertidumbre técnica o de requisitos.",
        "why": [
          "Reducción temprana de riesgos técnicos y de mercado mediante prototipos",
          "Gestión sistemática de incertidumbre en proyectos innovadores",
          "Fail-fast: descubrir problemas críticos antes de inversión masiva",
          "Flexibilidad para cambios de requisitos basados en prototipos",
          "Validación continua con stakeholders en cada ciclo"
        ],
        "how": [
          "Ciclo 1 (4-6 sem): Concept of Operations → prototipo de feasibility",
          "Ciclo 2 (6-8 sem): Requirements Specification → prototipo arquitectónico",
          "Ciclo 3 (8-12 sem): Design & Implementation → sistema operacional",
          "Ciclo 4 (4-6 sem): Acceptance & Deployment → sistema en producción",
          "Cada ciclo tiene 4 sectores: Objectives → Risk Analysis → Development → Planning",
          "Go/No-Go decision al final de cada ciclo basada en riesgos residuales"
        ],
        "phases": [
          {
            "id": "phase-spiral-cycle1",
            "name": "Ciclo 1: Concept of Operations",
            "order": 1,
            "description": "Exploración inicial de viabilidad y alternativas de solución. Identifica riesgos críticos de concepto y valida feasibility mediante prototipo throw-away.",
            "duration": "4-6 semanas",
            "activities": [
              "SECTOR 1 - Determinar Objetivos: Definir objetivos de negocio, constraints (presupuesto, tecnología) y alternativas de solución (3-5 opciones arquitectónicas)",
              "SECTOR 2 - Analizar Riesgos: Identificar top 10 riesgos (técnicos, de mercado, financieros). Risk assessment (probabilidad × impacto). Estrategias de mitigación (prototipo, investigación, POC)",
              "SECTOR 3 - Desarrollo: Crear prototipo de feasibility (throw-away) que demuestre viabilidad técnica de la alternativa seleccionada. Validar supuestos críticos",
              "SECTOR 4 - Planificar Siguiente Ciclo: Revisar riesgos residuales, decidir GO/NO-GO. Si GO, planificar Ciclo 2 (Requirements Specification) con enfoque en riesgos de requisitos"
            ],
            "inputs": [
              "Business case con objetivos estratégicos",
              "Constraints de presupuesto, tiempo, tecnología",
              "Lista inicial de stakeholders y sus expectativas"
            ],
            "outputs": [
              "Concepto de operación validado (documento de 5-10 páginas)",
              "Prototipo de feasibility (código descartable)",
              "Risk register con top 10 riesgos y estrategias de mitigación",
              "Plan detallado para Ciclo 2"
            ],
            "deliverables": [
              {
                "name": "Concept of Operations Document",
                "template": "tpl-001",
                "required": true,
                "reviewedBy": [
                  "Product Owner",
                  "Technical Lead",
                  "Risk Manager"
                ]
              },
              {
                "name": "Feasibility Prototype (throw-away code)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Technical Lead",
                  "Arquitecto"
                ]
              },
              {
                "name": "Risk Register (top 10 riesgos críticos)",
                "template": "tpl-014",
                "required": true,
                "reviewedBy": [
                  "Risk Manager",
                  "Product Owner"
                ]
              }
            ],
            "gate": {
              "name": "Concept Feasibility Gate",
              "criteria": [
                "Al menos 1 alternativa de solución es técnicamente viable (demostrada por prototipo)",
                "Riesgos críticos tienen estrategias de mitigación definidas",
                "Business case positivo (ROI esperado >20%)",
                "Stakeholders aprueban concepto de operación",
                "Presupuesto suficiente para Ciclo 2 (Requirements)"
              ],
              "decision": "GO / NO-GO / PIVOT (cambiar concepto)"
            },
            "keyStakeholders": [
              "Product Owner",
              "Risk Manager",
              "Technical Lead",
              "Business Sponsor"
            ]
          },
          {
            "id": "phase-spiral-cycle2",
            "name": "Ciclo 2: Requirements Specification",
            "order": 2,
            "description": "Refinamiento de requisitos mediante prototipo evolutivo. Mitiga riesgos de malentendidos de stakeholders y volatilidad de requisitos.",
            "duration": "6-8 semanas",
            "activities": [
              "SECTOR 1 - Determinar Objetivos: Refinar requisitos funcionales y no funcionales. Priorizar features (MoSCoW). Identificar casos de uso críticos (20% que entregan 80% valor)",
              "SECTOR 2 - Analizar Riesgos: Evaluar riesgos de requisitos (ambigüedad, conflictos entre stakeholders, volatilidad). Risk assessment de features complejos. Priorizar requisitos de alto riesgo para validación temprana",
              "SECTOR 3 - Desarrollo: Crear prototipo UI/UX evolutivo (low-code, mockups interactivos). Validar usabilidad con usuarios reales (5-10 sesiones). Refinar requisitos basados en feedback",
              "SECTOR 4 - Planificar Siguiente Ciclo: Baseline de requisitos aprobados. Decidir GO/NO-GO para Ciclo 3 (Design & Implementation). Planificar arquitectura y tecnologías"
            ],
            "inputs": [
              "Concept of Operations aprobado (Ciclo 1)",
              "Risk register actualizado",
              "Lista de stakeholders y sus prioridades de features"
            ],
            "outputs": [
              "Especificación de requisitos (SRS) con casos de uso priorizados",
              "Prototipo UI/UX evolutivo (puede convertirse en producto final)",
              "Risk register actualizado con riesgos de requisitos mitigados",
              "Plan de arquitectura inicial"
            ],
            "deliverables": [
              {
                "name": "Software Requirements Specification (SRS)",
                "template": "tpl-002",
                "required": true,
                "reviewedBy": [
                  "Product Owner",
                  "Business Analyst",
                  "UX Lead"
                ]
              },
              {
                "name": "UI/UX Prototype (evolutivo, no throw-away)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "UX Lead",
                  "Product Owner",
                  "Sample Users"
                ]
              },
              {
                "name": "Risk Register Updated (requisitos validados)",
                "template": "tpl-014",
                "required": true,
                "reviewedBy": [
                  "Risk Manager"
                ]
              }
            ],
            "gate": {
              "name": "Requirements Validation Gate",
              "criteria": [
                "90%+ de stakeholders aprueban prototipo UI/UX",
                "Requisitos críticos validados con usuarios reales (>80% satisfacción)",
                "Riesgos de requisitos reducidos a nivel aceptable (MEDIUM o menor)",
                "Features priorizadas con MoSCoW (Must/Should/Could/Won't)",
                "Arquitectura inicial factible según Technical Lead"
              ],
              "decision": "GO / REFINE REQUIREMENTS / NO-GO"
            },
            "keyStakeholders": [
              "Product Owner",
              "Business Analyst",
              "UX Lead",
              "Sample Users",
              "Risk Manager"
            ]
          },
          {
            "id": "phase-spiral-cycle3",
            "name": "Ciclo 3: Design & Implementation",
            "order": 3,
            "description": "Desarrollo del sistema operacional con arquitectura robusta. Mitiga riesgos técnicos de integración, performance y escalabilidad.",
            "duration": "8-12 semanas",
            "activities": [
              "SECTOR 1 - Determinar Objetivos: Diseñar arquitectura detallada (capas, componentes, APIs). Definir objetivos de calidad (performance, seguridad, escalabilidad). Seleccionar tecnologías y frameworks",
              "SECTOR 2 - Analizar Riesgos: Identificar riesgos técnicos (integración de sistemas legacy, performance bajo carga, vulnerabilidades de seguridad). Crear POCs para componentes de alto riesgo",
              "SECTOR 3 - Desarrollo: Implementar sistema operacional con tests automatizados (unit, integration, E2E). Code reviews y CI/CD pipeline. Testing de performance y seguridad",
              "SECTOR 4 - Planificar Siguiente Ciclo: Validar sistema con beta testers (20-50 usuarios). Recoger métricas de uso y bugs. Planificar Ciclo 4 (Acceptance & Deployment) con enfoque en riesgos operacionales"
            ],
            "inputs": [
              "SRS aprobado (Ciclo 2)",
              "Prototipo UI/UX como base de frontend",
              "Risk register con riesgos técnicos priorizados"
            ],
            "outputs": [
              "Sistema operacional completo (código production-ready)",
              "Arquitectura documentada (diagramas C4, ADRs)",
              "Test suite automatizado (>80% coverage)",
              "Reportes de beta testing con métricas de uso"
            ],
            "deliverables": [
              {
                "name": "Sistema Operacional (beta release)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Technical Lead",
                  "QA Lead",
                  "Security Engineer"
                ]
              },
              {
                "name": "Documentación de Arquitectura (C4 + ADRs)",
                "template": "tpl-004",
                "required": true,
                "reviewedBy": [
                  "Arquitecto",
                  "Technical Lead"
                ]
              },
              {
                "name": "Test Suite Automatizado (CI/CD integrado)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "QA Lead",
                  "DevOps"
                ]
              },
              {
                "name": "Beta Testing Report (50+ usuarios)",
                "template": "tpl-013",
                "required": true,
                "reviewedBy": [
                  "Product Owner",
                  "QA Lead"
                ]
              }
            ],
            "gate": {
              "name": "System Readiness Gate",
              "criteria": [
                "Todos los requisitos MUST implementados y validados",
                "Test coverage >80% con zero bugs críticos",
                "Performance cumple SLOs (latency <200ms p95, throughput >1000 req/s)",
                "Security audit aprobado (zero vulnerabilidades HIGH/CRITICAL)",
                "Beta testers reportan >85% satisfacción general"
              ],
              "decision": "GO TO PRODUCTION / FIX CRITICAL ISSUES / ITERATE"
            },
            "keyStakeholders": [
              "Technical Lead",
              "Arquitecto",
              "QA Lead",
              "Security Engineer",
              "Beta Testers"
            ]
          },
          {
            "id": "phase-spiral-cycle4",
            "name": "Ciclo 4: Acceptance & Deployment",
            "order": 4,
            "description": "Despliegue a producción con validación de usuarios reales. Mitiga riesgos operacionales (downtime, data loss, user adoption).",
            "duration": "4-6 semanas",
            "activities": [
              "SECTOR 1 - Determinar Objetivos: Definir criterios de aceptación de producción (uptime >99.9%, zero data loss). Planificar rollout strategy (canary, blue-green). Establecer SLOs y SLIs",
              "SECTOR 2 - Analizar Riesgos: Identificar riesgos operacionales (downtime durante deploy, data migration failures, baja adopción de usuarios). Crear runbooks de incident response y rollback",
              "SECTOR 3 - Deployment: Despliegue gradual (5% → 25% → 100% usuarios). Monitoreo continuo de métricas (errors, latency, business KPIs). Soporte 24/7 durante primeras 2 semanas",
              "SECTOR 4 - Planificar Siguiente Ciclo: Recoger feedback post-deployment (NPS, support tickets, analytics). Identificar mejoras para siguiente versión. Decidir si iterar (nuevo Ciclo 1 para features adicionales) o cerrar proyecto"
            ],
            "inputs": [
              "Sistema validado en beta (Ciclo 3)",
              "Risk register con riesgos operacionales",
              "Plan de deployment y rollback"
            ],
            "outputs": [
              "Sistema en producción con 100% usuarios activos",
              "Documentación operacional (runbooks, playbooks)",
              "Métricas de adopción y satisfacción (NPS, CSAT)",
              "Lecciones aprendidas y backlog de mejoras"
            ],
            "deliverables": [
              {
                "name": "Sistema en Producción (100% rollout)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "DevOps Lead",
                  "SRE",
                  "Product Owner"
                ]
              },
              {
                "name": "Operational Runbooks (incident response, rollback)",
                "template": "tpl-006",
                "required": true,
                "reviewedBy": [
                  "SRE",
                  "DevOps Lead"
                ]
              },
              {
                "name": "Post-Deployment Report (métricas de adopción, NPS)",
                "template": "tpl-013",
                "required": true,
                "reviewedBy": [
                  "Product Owner",
                  "Business Sponsor"
                ]
              },
              {
                "name": "Lessons Learned & Backlog de Mejoras",
                "template": "tpl-015",
                "required": true,
                "reviewedBy": [
                  "Product Owner",
                  "Technical Lead",
                  "Risk Manager"
                ]
              }
            ],
            "gate": {
              "name": "Production Success Gate",
              "criteria": [
                "Sistema cumple SLOs (uptime >99.9%, latency <200ms p95)",
                "Zero incidentes críticos en primeras 2 semanas",
                "Adopción de usuarios >80% del target",
                "NPS >40 (satisfacción de usuarios)",
                "Business KPIs cumplen objetivos (conversión, revenue, etc.)"
              ],
              "decision": "PROJECT SUCCESS / ITERATE (nuevo ciclo) / ROLLBACK"
            },
            "keyStakeholders": [
              "DevOps Lead",
              "SRE",
              "Product Owner",
              "Support Team",
              "Business Sponsor"
            ]
          }
        ],
        "whenToUse": [
          "Proyectos con alta incertidumbre técnica (tecnologías nuevas, integraciones complejas)",
          "Requisitos volátiles o poco claros al inicio (exploración de producto, nuevos mercados)",
          "Alto riesgo de falla costosa (sistemas críticos, inversiones grandes >$500K)",
          "Stakeholders requieren validación continua (demostrar progreso con prototipos)",
          "Proyectos innovadores donde fallar rápido es más barato que planificar todo upfront",
          "Necesidad de balancear costo vs. reducción de riesgos (presupuesto flexible)",
          "Equipos con experiencia en gestión de riesgos y prototipado rápido",
          "Proyectos de larga duración (>6 meses) con puntos de decisión GO/NO-GO",
          "Desarrollo de productos con alto impacto de UX (prototipado evolutivo crítico)",
          "Contextos donde cancelar temprano es aceptable (fail-fast culture)"
        ],
        "whenNotToUse": [
          "Proyectos con requisitos estables y bien conocidos (mejor usar Cascada o Incremental)",
          "Presupuesto fijo y timeline rígido (Spiral requiere flexibilidad para iterar)",
          "Equipos sin experiencia en análisis de riesgos (overhead de gestión de riesgos es alto)",
          "Proyectos pequeños (<3 meses) donde overhead de 4 sectores por ciclo no justifica",
          "Stakeholders no disponibles para revisiones frecuentes de prototipos",
          "Organizaciones risk-averse que no toleran prototipado throw-away (desperdicio percibido)",
          "Proyectos con compliance estricto que requiere documentación exhaustiva upfront (mejor RUP)",
          "Equipos distribuidos sin cultura de colaboración (Spiral requiere comunicación intensiva)",
          "Desarrollo de productos commoditizados sin innovación (overhead innecesario)",
          "Contextos donde el costo de prototipado es prohibitivo (hardware especializado, infraestructura costosa)"
        ],
        "advantages": [
          "Reducción temprana de riesgos técnicos y de negocio mediante prototipos",
          "Fail-fast: cancelar proyectos inviables antes de inversión masiva (ahorro de costos)",
          "Flexibilidad para cambios de requisitos basados en feedback de prototipos",
          "Validación continua con stakeholders reduce riesgo de rechazo final",
          "Gestión sistemática de riesgos (risk register, análisis probabilidad × impacto)",
          "Puntos de decisión GO/NO-GO permiten ajustes estratégicos en cada ciclo",
          "Prototipado evolutivo mejora calidad de UX (usuarios validan antes de implementación final)",
          "Adecuado para proyectos complejos con múltiples alternativas de solución",
          "Combina beneficios de Cascada (estructura) con Incremental (iteración)",
          "Documentación de lecciones aprendidas mejora procesos futuros"
        ],
        "disadvantages": [
          "Alto overhead de gestión: requiere Risk Manager dedicado y revisiones frecuentes",
          "Costoso en tiempo y dinero: prototipado throw-away puede verse como desperdicio",
          "Requiere stakeholders altamente disponibles para revisiones de cada ciclo",
          "Complejidad de planificación: difícil estimar timelines y presupuesto total upfront",
          "Equipos necesitan skills especializados en análisis de riesgos y prototipado rápido",
          "No apto para proyectos pequeños: overhead no justifica para <3 meses duración",
          "Riesgo de analysis paralysis: equipos pueden sobre-analizar riesgos sin avanzar",
          "Difícil de integrar con procesos de adquisición tradicionales (contratos de scope fijo)",
          "Prototipado continuo puede generar expectativas irreales de velocidad de desarrollo",
          "Métricas de progreso ambiguas: difícil medir avance entre ciclos (no es % de features completas)"
        ],
        "iterationStrategy": "Cada ciclo del Espiral (4-12 semanas) atraviesa 4 sectores obligatorios: 1) Determinar Objetivos, 2) Analizar Riesgos, 3) Desarrollo (prototipo o sistema), 4) Planificar Siguiente Ciclo. Ciclos posteriores refinan entregables: Ciclo 1 produce concepto + prototipo throw-away, Ciclo 2 produce SRS + prototipo evolutivo, Ciclo 3 produce sistema operacional, Ciclo 4 produce sistema en producción. Cada ciclo termina con decisión GO/NO-GO basada en riesgos residuales. Feedback de prototipos guía refinamiento de requisitos y arquitectura en ciclos subsecuentes.",
        "changeManagement": {
          "description": "Gestión de cambios orientada a riesgos con evaluación de impacto en cada ciclo",
          "steps": [
            {
              "step": 1,
              "name": "Captura de Cambio Solicitado",
              "description": "Stakeholder registra cambio en Risk Register con justificación de negocio y riesgos percibidos"
            },
            {
              "step": 2,
              "name": "Análisis de Riesgos del Cambio",
              "description": "Risk Manager evalúa impacto del cambio: probabilidad de éxito, costo, impacto en timeline, riesgos técnicos introducidos"
            },
            {
              "step": 3,
              "name": "Priorización en Backlog de Ciclo",
              "description": "Product Owner + Risk Manager priorizan cambio contra otros riesgos. Cambios de alto riesgo se validan con prototipo en siguiente ciclo"
            },
            {
              "step": 4,
              "name": "Prototipado de Cambio (si aplica)",
              "description": "En Sector 3 (Desarrollo) del siguiente ciclo, crear prototipo que valide viabilidad del cambio solicitado"
            },
            {
              "step": 5,
              "name": "Decisión GO/NO-GO del Cambio",
              "description": "En Sector 4 (Planificar), decidir si integrar cambio basado en resultados de prototipo y análisis costo-beneficio"
            },
            {
              "step": 6,
              "name": "Actualización de Documentación",
              "description": "Si cambio aprobado, actualizar SRS, arquitectura, risk register y plan de siguiente ciclo"
            }
          ]
        },
        "tooling": [
          {
            "category": "Risk Management",
            "tools": [
              "Risk Register (Excel, Jira Risk Management, RiskWatch)",
              "Risk Matrix (probabilidad × impacto con heatmap)",
              "Monte Carlo Simulation para estimación de costos y timelines"
            ]
          },
          {
            "category": "Prototyping",
            "tools": [
              "Figma, Sketch, Adobe XD (UI/UX mockups evolutivos)",
              "Low-code platforms (OutSystems, Mendix) para prototipado rápido",
              "Jupyter Notebooks, Google Colab (prototipos de algoritmos ML/analytics)"
            ]
          },
          {
            "category": "Collaboration",
            "tools": [
              "Miro, Mural (workshops de análisis de riesgos con stakeholders)",
              "Confluence (documentación de decisiones GO/NO-GO)",
              "Slack, Teams (comunicación continua con stakeholders)"
            ]
          },
          {
            "category": "Development",
            "tools": [
              "Git (versionado de prototipos y código evolutivo)",
              "CI/CD (GitHub Actions, GitLab CI) para validación continua",
              "Monitoring (Datadog, New Relic) para métricas de producción en Ciclo 4"
            ]
          }
        ],
        "references": [
          {
            "title": "A Spiral Model of Software Development and Enhancement",
            "author": "Barry Boehm",
            "year": 1988,
            "source": "IEEE Computer, Vol. 21, No. 5",
            "url": "https://dl.acm.org/doi/10.1145/35043.35044"
          },
          {
            "title": "Software Engineering: A Practitioner's Approach (Chapter 2)",
            "author": "Roger Pressman",
            "year": 2014,
            "source": "McGraw-Hill Education"
          },
          {
            "title": "Software Engineering (10th Edition) - Chapter 2.1.3: Spiral Model",
            "author": "Ian Sommerville",
            "year": 2015,
            "source": "Pearson"
          }
        ],
        "chapter": 2
      },
      "methodology": {
        "name": "Spiral Model (Boehm)",
        "description": "Modelo de proceso iterativo cíclico orientado a gestión de riesgos que combina elementos de desarrollo Waterfall (fases estructuradas) con desarrollo iterativo y énfasis en análisis sistemático de riesgos en cada ciclo. Cada iteración (espiral) atraviesa 4 sectores radiales: (1) Determinar objetivos, alternativas y restricciones, (2) Evaluar alternativas, identificar y resolver riesgos (construcción de prototipos obligatoria), (3) Desarrollar y verificar el producto del ciclo, (4) Planificar el siguiente ciclo. El modelo permite tomar decisiones go/no-go al final de cada ciclo basadas en viabilidad técnica y económica. Enfocado en proyectos de alta complejidad técnica, alta incertidumbre de requisitos o riesgos significativos que deben validarse antes de comprometer recursos completos. Cada ciclo acumula sobre el anterior, construyendo progresivamente el sistema completo mientras se mitigan riesgos de manera sistemática.",
        "origin": {
          "creator": "Barry Boehm",
          "year": 1988,
          "context": "Desarrollado en TRW Defense Systems Group para proyectos de defensa de alta complejidad y alto riesgo. Publicado en el paper 'A Spiral Model of Software Development and Enhancement' (IEEE Computer, 1988). Motivado por la necesidad de validar viabilidad técnica y económica de sistemas complejos antes de comprometer recursos masivos en desarrollo completo, especialmente en proyectos donde cancelar temprano es preferible a descubrir inviabilidad al final después de años de inversión."
        },
        "principles": [
          "4 sectores radiales por ciclo: (1) Determinar objetivos, (2) Analizar riesgos y construir prototipos, (3) Desarrollar y verificar, (4) Planificar siguiente ciclo",
          "Gestión explícita de riesgos como driver principal: cada ciclo identifica, analiza, prioriza y mitiga riesgos específicos",
          "Construcción de prototipos obligatoria en cada ciclo para validar supuestos técnicos, de negocio y de viabilidad (throwaway o evolutionary prototypes)",
          "Decisiones go/no-go basadas en análisis de riesgos: cancelar proyecto si riesgos son inmanejables o costo de mitigación excede beneficio",
          "Iteraciones acumulativas: cada ciclo construye sobre el anterior, incrementando complejidad y completitud del sistema",
          "Fail-fast approach: detectar inviabilidad técnica/económica lo más temprano posible para minimizar pérdidas (sunk cost minimization)"
        ],
        "differentiators": [
          "vs Waterfall: Spiral tiene iteraciones cíclicas obligatorias y gestión explícita de riesgos en cada ciclo, mientras Waterfall es secuencial lineal sin análisis de riesgos formalizado",
          "vs Incremental: Spiral se centra en mitigación de riesgos mediante prototipos (no solo entregas funcionales), mientras Incremental se centra en entregas de funcionalidad acumulativa",
          "vs RUP: Spiral es puro risk-driven con 4 sectores genéricos, mientras RUP estructura 4 fases específicas (Inception/Elaboration/Construction/Transition) con 9 disciplinas y milestones definidos"
        ],
        "references": {
          "chapter": "chapter-2",
          "sections": [
            "2.3 Incremental development and delivery",
            "2.5 The Spiral Model (if covered - else 2.3)"
          ],
          "externalResources": [
            "Boehm, B. W. (1988). A spiral model of software development and enhancement. IEEE Computer, 21(5), 61-72",
            "Boehm, B. W. (1986). A Spiral Model of Software Development and Enhancement. ACM SIGSOFT Software Engineering Notes"
          ]
        }
      },
      "modeling": {
        "notations": [
          {
            "name": "UML",
            "description": "UML para documentar requisitos evolutivos y prototipos técnicos en cada ciclo.",
            "diagrams": [
              "Use Case Diagram (requisitos)",
              "Sequence Diagram (prototipos)",
              "Component Diagram (arquitectura evolutiva)"
            ],
            "whenToUse": "Documentar requisitos que evolucionan en cada ciclo de la espiral y prototipos técnicos validados",
            "tools": [
              "Lucidchart",
              "PlantUML",
              "Visual Paradigm"
            ]
          },
          {
            "name": "Prototyping Tools",
            "description": "Herramientas de prototipado rápido para validar viabilidad técnica (mockups, wireframes, PoCs).",
            "diagrams": [
              "Wireframes",
              "Interactive Prototypes",
              "Technical PoC (code prototypes)"
            ],
            "whenToUse": "Cada ciclo de la espiral requiere prototipo para validar supuestos técnicos antes de comprometer recursos",
            "tools": [
              "Figma",
              "Balsamiq",
              "InVision",
              "CodePen (PoCs técnicos)",
              "Jupyter Notebooks (algoritmos)"
            ]
          }
        ],
        "primaryFocus": "Modelado de riesgos, prototipos técnicos y validación de viabilidad en cada ciclo de la espiral",
        "references": {
          "chapter": "chapter-2, chapter-5",
          "sections": [
            "2.3 Incremental development and delivery",
            "5.1 System modeling"
          ]
        }
      },
      "architecture": {
        "patterns": [
          {
            "name": "Prototype-Driven Architecture",
            "description": "Arquitectura evoluciona a partir de prototipos técnicos validados en cada ciclo de la espiral.",
            "advantages": [
              "Validación temprana de viabilidad técnica (fail-fast approach)",
              "Reduce riesgo de arquitectura incorrecta (prototipos validan supuestos)",
              "Stakeholders ven progreso tangible (prototipos funcionales, no solo documentos)",
              "Permite experimentar con múltiples alternativas arquitectónicas"
            ],
            "disadvantages": [
              "Prototipos throwaway pueden convertirse en código productivo (technical debt)",
              "Overhead de construir múltiples prototipos (tiempo/recursos)",
              "Riesgo de scope creep (stakeholders piden más features en prototipos)"
            ],
            "whenToUse": "Sistemas de alto riesgo técnico (tecnología nueva, integraciones complejas, requisitos inciertos, algoritmos no probados)",
            "tradeoffs": "Validación temprana de riesgos vs Overhead de prototipos y riesgo de technical debt"
          },
          {
            "name": "Layered with Abstraction Layers",
            "description": "Capas de abstracción para aislar riesgos técnicos (ej: capa de integración con API externa inestable).",
            "advantages": [
              "Aisla código de alto riesgo (fácil reemplazar si prototipo falla)",
              "Facilita testing de componentes de riesgo (mocks de capas de riesgo)",
              "Permite evolución independiente de capas (refactoring localizado)"
            ],
            "disadvantages": [
              "Complejidad de múltiples capas de abstracción",
              "Overhead de performance (indirección adicional)"
            ],
            "whenToUse": "Riesgos técnicos específicos que necesitan aislamiento (integración con API legacy inestable, algoritmo experimental)",
            "tradeoffs": "Aislamiento de riesgos vs Complejidad de abstracción"
          }
        ],
        "style": "Evolutivo (arquitectura emerge de prototipos validados, no diseño upfront exhaustivo)",
        "qualityAttributes": {
          "scalability": "Medium - Prioridad es validar viabilidad, no escalar. Escalabilidad se refina después de validación en ciclos posteriores.",
          "maintainability": "Medium - Prototipos pueden generar technical debt si no se refactorizan. Importante separar prototipos throwaway vs evolutionary.",
          "performance": "Low-Medium - Prototipos priorizan validación rápida sobre performance óptima. Optimización en ciclos posteriores.",
          "security": "Medium-High - Riesgos de seguridad deben identificarse temprano (análisis de amenazas en cada ciclo). Security by design progresivo."
        },
        "references": {
          "chapter": "chapter-6",
          "sections": [
            "6.2 Architectural design decisions"
          ]
        }
      },
      "timeline": [
        {
          "week": "1-4",
          "phase": "Espiral 1: Planificación",
          "tasks": [
            "Identificar objetivos de alto nivel",
            "Análisis de riesgos críticos",
            "Identificar requisitos estables vs volátiles",
            "Prototipo de concepto",
            "Decisión Go/No-Go"
          ]
        },
        {
          "week": "5-12",
          "phase": "Espiral 2: Reducción de Riesgos",
          "tasks": [
            "Resolver riesgos de seguridad identificados",
            "Especificación de núcleo crítico",
            "Prototipo funcional del core",
            "Validación con expertos",
            "Refinar arquitectura"
          ]
        },
        {
          "week": "13-24",
          "phase": "Espirales 3-4: Desarrollo Iterativo",
          "tasks": [
            "Implementación incremental",
            "Testing exhaustivo por iteración",
            "Análisis de riesgos continuo",
            "Refinar requisitos volátiles",
            "Validación regulatoria progresiva"
          ]
        },
        {
          "week": "25-30",
          "phase": "Finalización",
          "tasks": [
            "Integración completa",
            "Certificación regulatoria",
            "Testing de sistema final",
            "Documentación completa"
          ]
        }
      ],
      "avoid": [
        "Cascada puro (no maneja volatilidad)",
        "Ágil puro (no maneja criticidad)",
        "Ignorar análisis de riesgos",
        "Cambios en núcleo crítico sin análisis exhaustivo",
        "No estabilizar requisitos de seguridad pronto"
      ],
      "templates": [
        "tpl-001",
        "tpl-003",
        "tpl-007",
        "tpl-009"
      ],
      "chapters": [
        2,
        4,
        5,
        6
      ]
    },
    "rec-004": {
      "id": "rec-004",
      "title": "Sistema Transaccional → Grande",
      "path": [
        "Transaccional",
        "Estables",
        "Grande"
      ],
      "pathDescription": "Sistema Transaccional → Requisitos Estables → Equipo Grande (>20)",
      "process": {
        "name": "Incremental Development with RUP",
        "type": "iterative-phased",
        "chapter": 2,
        "description": "Framework híbrido que combina 4 fases secuenciales de RUP (Inception, Elaboration, Construction, Transition) con desarrollo iterativo incremental dentro de cada fase. Ideal para sistemas transaccionales grandes con requisitos complejos, workflows de negocio críticos y necesidad de arquitectura robusta desde el inicio.",
        "why": [
          "RUP estructura el desarrollo en fases macro para gestionar complejidad",
          "Iteraciones dentro de cada fase permiten entregas incrementales y feedback continuo",
          "Emphasis en arquitectura sólida (Elaboration) minimiza refactoring costoso en Construction",
          "Manejo sistemático de transacciones ACID desde fase de diseño",
          "Documentación formal (Use Cases, SAD) facilita governance y auditorías"
        ],
        "how": [
          "Ejecutar 4 fases secuenciales (Inception → Elaboration → Construction → Transition)",
          "Cada fase tiene 1-5 iteraciones de 2-4 semanas que producen incremento funcional",
          "Usar 9 disciplinas RUP (Requirements, Design, Implementation, Testing, Deployment)",
          "Intensidad de disciplinas varía por fase: Requirements alto en Inception/Elaboration, Implementation alto en Construction",
          "Milestones claros (Lifecycle Objective, Architecture, Capability, Release) con decisiones go/no-go"
        ],
        "phases": [
          {
            "id": "phase-rup-inception",
            "name": "Inception (Concepción)",
            "order": 1,
            "description": "Establecer viabilidad del proyecto, alcance inicial y business case. Objetivo: Responder '¿Vale la pena construir este sistema?' mediante análisis preliminar de requisitos y factibilidad técnica.",
            "duration": "2-4 semanas (1-2 iteraciones)",
            "activities": [
              "Identificar stakeholders clave y objetivos de negocio (C-level, usuarios finales, IT)",
              "Crear Vision Document (problema a resolver, objetivos estratégicos, restricciones presupuesto/tiempo)",
              "Definir 10-15 casos de uso core (critical business workflows: facturación, ventas, inventario)",
              "Realizar feasibility study técnico (tecnologías candidatas, integraciones con legacy systems)",
              "Construir Business Case con ROI preliminar (costos estimados, beneficios cuantificables)",
              "Identificar riesgos críticos iniciales (top 5: integraciones, escalabilidad, regulaciones)",
              "Crear initial project plan (fases, hitos, recursos necesarios)",
              "Milestone: Lifecycle Objective - Decisión go/no-go de stakeholders y sponsor"
            ],
            "inputs": [
              "Solicitud de proyecto o RFP (Request for Proposal)",
              "Descripción del problema de negocio a resolver",
              "Restricciones conocidas (presupuesto, tiempo, compliance)"
            ],
            "outputs": [
              "Vision Document aprobado (10-15 páginas)",
              "Initial Use Case Model (10-15 casos de uso en formato brief)",
              "Business Case con ROI preliminar",
              "Initial Risk List (top 10 riesgos identificados)",
              "Project Plan de alto nivel (Gantt con fases y milestones)"
            ],
            "deliverables": [
              {
                "name": "Vision Document v1.0",
                "template": "tpl-001",
                "required": true,
                "reviewedBy": [
                  "Product Owner",
                  "Sponsor",
                  "Business Analyst"
                ]
              },
              {
                "name": "Use Case Specification (brief format, UML use case diagrams)",
                "template": "tpl-002",
                "required": true,
                "reviewedBy": [
                  "Business Analyst",
                  "Product Owner"
                ]
              },
              {
                "name": "Business Case Document (financial analysis, ROI)",
                "template": "tpl-003",
                "required": true,
                "reviewedBy": [
                  "CFO",
                  "Sponsor"
                ]
              },
              {
                "name": "Go/No-Go Decision Document",
                "template": "tpl-015",
                "required": true,
                "reviewedBy": [
                  "Sponsor",
                  "Finance"
                ]
              }
            ],
            "gate": {
              "name": "Lifecycle Objective Milestone",
              "criteria": [
                "Vision Document aprobado por al menos 3/4 de stakeholders ejecutivos",
                "Business Case muestra ROI positivo en 18-24 meses",
                "Top 5 riesgos tienen estrategias de mitigación identificadas",
                "Presupuesto aprobado para Elaboration Phase (siguiente fase)",
                "Sponsor firma decisión explícita de continuar a Elaboration"
              ],
              "decision": "GO / NO-GO / PIVOT",
              "approvers": [
                "Sponsor",
                "Product Owner",
                "Technical Lead",
                "Finance"
              ]
            },
            "keyStakeholders": [
              "Business Analyst",
              "Product Owner",
              "Enterprise Architect",
              "CFO",
              "CTO"
            ]
          },
          {
            "id": "phase-rup-elaboration",
            "name": "Elaboration (Elaboración)",
            "order": 2,
            "description": "Establecer arquitectura base del sistema y mitigar riesgos arquitectónicos críticos. Objetivo: Crear architecture baseline sólida que soporte todos los requisitos sin refactoring mayor en Construction.",
            "duration": "8-12 semanas (2-3 iteraciones de 4 semanas)",
            "activities": [
              "Refinar y detallar 80% de casos de uso (formato fully dressed con pre/post condiciones, flujos alternativos)",
              "Diseñar arquitectura de referencia (capas: presentación, lógica negocio, acceso datos, integración)",
              "Seleccionar stack tecnológico definitivo (frameworks, DB, cloud provider, message queues)",
              "Construir Architecture Baseline (ADRs para decisiones críticas: monolito vs microservicios, SQL vs NoSQL)",
              "Implementar spike técnico de componentes críticos (motor de workflows, procesamiento transaccional, integraciones)",
              "Definir NFRs cuantificables (latencia <200ms, throughput 1000 TPS, uptime 99.9%)",
              "Crear detailed risk mitigation plan (top 10 riesgos con owner, plan, deadline)",
              "Testing del spike: performance, escalabilidad, seguridad básica",
              "Milestone: Lifecycle Architecture - Arquitectura aprobada por equipo técnico y stakeholders"
            ],
            "inputs": [
              "Vision Document aprobado (Inception)",
              "Initial Use Cases (brief format)",
              "Risk List inicial",
              "Budget aprobado para Elaboration"
            ],
            "outputs": [
              "Detailed Use Case Specifications (80% completos, fully dressed)",
              "Software Architecture Document (SAD con diagramas UML: componentes, deployment, secuencia)",
              "Architecture Baseline (spike técnico funcional con componentes críticos)",
              "Architecture Decision Records (ADRs para decisiones key)",
              "Risk Mitigation Plan detallado (top 10 riesgos con planes de acción)",
              "Refined Project Plan (estimaciones de Construction con ±15% accuracy)"
            ],
            "deliverables": [
              {
                "name": "Software Architecture Document (SAD)",
                "template": "tpl-004",
                "required": true,
                "reviewedBy": [
                  "Software Architect",
                  "Technical Lead"
                ]
              },
              {
                "name": "Detailed Use Case Model (UML, 80% completos)",
                "template": "tpl-002",
                "required": true,
                "reviewedBy": [
                  "Business Analyst",
                  "Product Owner"
                ]
              },
              {
                "name": "Architecture Baseline (código ejecutable del spike)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Software Architect",
                  "Senior Developers"
                ]
              },
              {
                "name": "Risk Mitigation Plan v2.0",
                "template": "tpl-014",
                "required": true,
                "reviewedBy": [
                  "Risk Manager",
                  "Technical Lead"
                ]
              },
              {
                "name": "NFRs Document (performance, seguridad, escalabilidad)",
                "template": "tpl-005",
                "required": true,
                "reviewedBy": [
                  "Architect",
                  "QA Lead"
                ]
              }
            ],
            "gate": {
              "name": "Lifecycle Architecture Milestone",
              "criteria": [
                "Architecture Baseline valida todos los NFRs críticos (performance, escalabilidad)",
                "80% de casos de uso detallados y aprobados por Product Owner",
                "Top 5 riesgos arquitectónicos mitigados o con plan claro",
                "Estimaciones de Construction refinadas con ±15% accuracy",
                "Arquitectura aprobada por Architecture Review Board (ARB)",
                "Go decision de sponsor para continuar a Construction (presupuesto aprobado)"
              ],
              "decision": "GO / REFINE ARCHITECTURE / NO-GO",
              "approvers": [
                "Software Architect",
                "Technical Lead",
                "Product Owner",
                "Sponsor",
                "Security Lead"
              ]
            },
            "keyStakeholders": [
              "Software Architect",
              "Senior Developers",
              "DBA",
              "Security Engineer",
              "DevOps Lead"
            ]
          },
          {
            "id": "phase-rup-construction",
            "name": "Construction (Construcción)",
            "order": 3,
            "description": "Desarrollar sistema completo con todas las features implementadas, probadas e integradas. Objetivo: Producir sistema operacional listo para User Acceptance Testing (UAT).",
            "duration": "12-20 semanas (3-5 iteraciones de 4 semanas)",
            "activities": [
              "Iteración 1-2 (Core Features): Implementar workflows críticos de negocio (facturación, ventas, usuarios), testing unit e integration",
              "Iteración 3-4 (Secondary Features): Implementar features secundarios (reportes, dashboards, admin panels), integraciones con sistemas externos",
              "Iteración 5 (Hardening): Bug fixing, performance tuning, security hardening, refactoring técnico, testing end-to-end",
              "Code reviews obligatorios (peer review para cada feature critical)",
              "Testing continuo: unit tests (>80% coverage), integration tests, system tests por iteración",
              "Crear user documentation (user manuals, help system, FAQs)",
              "Preparar deployment scripts (CI/CD pipelines, migrations, rollback procedures)",
              "Realizar pre-UAT interno (alpha testing con equipo interno)",
              "Milestone: Initial Operational Capability - Sistema completo y listo para UAT"
            ],
            "inputs": [
              "Architecture Baseline validada (Elaboration)",
              "Detailed Use Cases (80% completos)",
              "NFRs definidos",
              "Development environment configurado"
            ],
            "outputs": [
              "Sistema operacional con 100% features implementados",
              "Test Suite completo (unit, integration, system tests con >80% coverage)",
              "User Documentation (manuals, help system, release notes)",
              "Deployment Package (CI/CD pipelines, Docker images, Kubernetes manifests)",
              "Pre-UAT Test Report (alpha testing resultados)"
            ],
            "deliverables": [
              {
                "name": "Sistema desplegable en staging (100% funcional)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Technical Lead",
                  "QA Lead",
                  "Product Owner"
                ]
              },
              {
                "name": "Test Coverage Report (>80% en código crítico)",
                "template": "tpl-013",
                "required": true,
                "reviewedBy": [
                  "QA Lead"
                ]
              },
              {
                "name": "User Manual v1.0",
                "template": "tpl-007",
                "required": true,
                "reviewedBy": [
                  "Technical Writer",
                  "Product Owner"
                ]
              },
              {
                "name": "Deployment Guide (runbook)",
                "template": "tpl-006",
                "required": true,
                "reviewedBy": [
                  "DevOps Lead",
                  "Operations"
                ]
              },
              {
                "name": "Release Notes v1.0",
                "template": "tpl-008",
                "required": true,
                "reviewedBy": [
                  "Product Owner"
                ]
              }
            ],
            "gate": {
              "name": "Initial Operational Capability Milestone",
              "criteria": [
                "100% de casos de uso implementados y verificados",
                "Test coverage >80% en código crítico (core workflows)",
                "Zero bugs críticos, <5 bugs high priority conocidos",
                "Performance cumple NFRs (latencia, throughput, uptime en staging)",
                "Security audit aprobado (OWASP Top 10, penetration testing básico)",
                "Pre-UAT completado con >90% éxito en test cases",
                "Aprobación de Technical Lead y Product Owner para iniciar UAT"
              ],
              "decision": "GO TO UAT / FIX CRITICAL ISSUES / ITERATE",
              "approvers": [
                "Technical Lead",
                "QA Lead",
                "Product Owner",
                "Security Lead"
              ]
            },
            "keyStakeholders": [
              "Development Team (8-15 developers)",
              "QA Engineers",
              "DevOps Engineer",
              "Technical Writer"
            ]
          },
          {
            "id": "phase-rup-transition",
            "name": "Transition (Transición)",
            "order": 4,
            "description": "Desplegar sistema a producción, ejecutar User Acceptance Testing (UAT), capacitar usuarios y establecer soporte inicial. Objetivo: Sistema aceptado y operando en producción con usuarios reales.",
            "duration": "4-8 semanas (1-2 iteraciones de 4 semanas)",
            "activities": [
              "Ejecutar User Acceptance Testing (UAT) con 20-50 usuarios piloto (key users de cada departamento)",
              "Iteración 1 (UAT): Fixing de bugs reportados por usuarios (prioridad alta), ajustes de UX menores",
              "Crear training materials (videos, slideshows, hands-on labs para end-users)",
              "Ejecutar training sessions (capacitación presencial o virtual, 3-5 sesiones de 2h c/u)",
              "Preparar production environment (configuración de servidores, DB, networking, monitoreo)",
              "Ejecutar data migration de legacy systems (ETL scripts, validación de integridad de datos)",
              "Deployment a producción (phased rollout: 10% usuarios → 50% → 100% en 2 semanas)",
              "Establecer soporte L1/L2 (helpdesk, on-call rotation, incident response procedures)",
              "Monitoreo post-deployment (métricas SRE: latencia, error rate, uptime por 30 días)",
              "Milestone: Product Release - Sistema aceptado por usuarios y operando en producción"
            ],
            "inputs": [
              "Sistema operacional completo (Construction)",
              "Test reports de pre-UAT",
              "User documentation",
              "Production environment aprovisionado"
            ],
            "outputs": [
              "Sistema en producción con 100% usuarios activos",
              "UAT Test Report (aprobado por usuarios piloto y Product Owner)",
              "Training completion certificates (usuarios capacitados)",
              "Post-Deployment Support Plan (L1/L2 procedures, escalation matrix)",
              "Lessons Learned Document (retrospectiva del proyecto)"
            ],
            "deliverables": [
              {
                "name": "Production System (live con usuarios reales)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Operations Manager",
                  "Product Owner"
                ]
              },
              {
                "name": "UAT Acceptance Document",
                "template": "tpl-013",
                "required": true,
                "reviewedBy": [
                  "Product Owner",
                  "Key Users",
                  "Sponsor"
                ]
              },
              {
                "name": "Training Materials Package",
                "template": "tpl-007",
                "required": true,
                "reviewedBy": [
                  "Training Team",
                  "Product Owner"
                ]
              },
              {
                "name": "Operations Manual (runbook, troubleshooting)",
                "template": "tpl-006",
                "required": true,
                "reviewedBy": [
                  "SRE",
                  "DevOps Lead"
                ]
              },
              {
                "name": "Post-Implementation Review",
                "template": "tpl-015",
                "required": true,
                "reviewedBy": [
                  "Product Owner",
                  "Sponsor",
                  "Technical Lead"
                ]
              }
            ],
            "gate": {
              "name": "Product Release Milestone",
              "criteria": [
                "UAT aprobado por >90% de usuarios piloto (acceptance criteria cumplidos)",
                "Zero bugs críticos en producción, <3 bugs high priority conocidos",
                "Data migration completada con 100% integridad (validación end-to-end)",
                "Training completado para >95% de usuarios finales (attendance + quiz >80%)",
                "Sistema operando en producción con >99% uptime por 7 días continuos",
                "Soporte L1/L2 establecido y respondiendo a tickets (<4h response time)",
                "Sign-off formal de sponsor y Product Owner (project closure)"
              ],
              "decision": "PROJECT SUCCESS / ITERATE / ROLLBACK",
              "approvers": [
                "Product Owner",
                "Sponsor",
                "Key Users (piloto)",
                "Operations Manager",
                "Support Lead"
              ]
            },
            "keyStakeholders": [
              "End Users",
              "Support Team",
              "Training Team",
              "Operations Team",
              "Product Owner"
            ]
          }
        ],
        "iterationStrategy": "RUP ejecuta 7-12 iteraciones totales distribuidas en 4 fases: Inception (1-2 iter), Elaboration (2-3 iter), Construction (3-5 iter), Transition (1-2 iter). Cada iteración dura 2-4 semanas y produce incremento funcional testeable. Intensidad de 9 disciplinas RUP varía por fase: Requirements alto en Inception/Elaboration, Implementation alto en Construction, Deployment alto en Transition. Feedback de usuarios piloto en Transition puede gatillar iteración adicional de refinamiento.",
        "whenToUse": [
          "Sistema transaccional grande con workflows complejos (ERP, CRM, core banking)",
          "Requisitos bien entendidos pero complejos (necesitan análisis detallado en Elaboration)",
          "Necesidad de arquitectura robusta desde el inicio (evitar refactoring costoso después)",
          "Equipo mediano-grande (20-50 personas) con roles especializados (BA, Architect, QA)",
          "Múltiples stakeholders con intereses divergentes (requiere Vision y Business Case claros)",
          "Alto impacto de fallas en producción (financiero, salud, crítico para negocio)",
          "Integraciones complejas con legacy systems (necesitan spike técnico en Elaboration)",
          "Regulaciones estrictas que requieren documentación formal (FDA, SOX, HIPAA)",
          "Presupuesto grande (>$500K) con necesidad de control de costos por fase",
          "Organización madura con procesos definidos (compatible con governance corporativo)"
        ],
        "whenNotToUse": [
          "Requisitos completamente desconocidos o experimentales (Ágil puro o Espiral mejor)",
          "Startup o proyecto de innovación sin arquitectura predefinida (overhead de RUP excesivo)",
          "Equipo pequeño (<10 personas) sin roles especializados (RUP demasiado pesado)",
          "Plazos muy cortos (<6 meses, no hay tiempo para 4 fases completas)",
          "Presupuesto limitado (<$100K, overhead de documentación y governance muy caro)",
          "Cambios frecuentes de requisitos esperados (Scrum/XP mejor para pivoting rápido)",
          "Sistema simple CRUD sin workflows complejos (overkill, Incremental puro suficiente)",
          "Cultura organizacional ágil anti-documentación (friction con formalidad de RUP)",
          "Sin sponsor ejecutivo comprometido (RUP requiere decisiones go/no-go frecuentes)",
          "Tecnología completamente nueva sin madurez (spike de Elaboration puede fallar)"
        ],
        "advantages": [
          "Arquitectura sólida desde Elaboration evita refactoring costoso en Construction (saving 30-40% tiempo)",
          "Control de riesgos en fases tempranas (Inception + Elaboration) minimiza sorpresas tardías",
          "Iteraciones dentro de fases permiten feedback continuo sin perder estructura macro",
          "Documentación formal (Vision, SAD, Use Cases) facilita governance y auditorías de compliance",
          "Milestones claros (Lifecycle Objective, Architecture, Capability, Release) permiten decisiones go/no-go",
          "Apropiado para equipos grandes con especialización (roles claros: BA, Architect, Dev, QA)",
          "Manejo explícito de requisitos complejos mediante casos de uso detallados (UML)",
          "Transition Phase asegura deployment exitoso con UAT, training y soporte estructurado",
          "Escalable a proyectos muy grandes (equipos distribuidos, múltiples locaciones)",
          "Compatible con herramientas enterprise (IBM Rational, JIRA, Confluence, ALM tools)"
        ],
        "disadvantages": [
          "Overhead de documentación alto (Vision, SAD, Use Cases consume 15-20% del tiempo)",
          "Largo tiempo hasta primer release (6-12 meses mínimo para 4 fases completas)",
          "Requiere equipo experimentado con expertise en RUP (curva de aprendizaje >6 meses)",
          "Costoso debido a fases de análisis extensas (Inception + Elaboration = 25-30% del timeline)",
          "Menos flexible que Ágil puro ante cambios de requisitos en Construction/Transition",
          "Governance pesado puede generar burocracia (aprobaciones de milestones lentas)",
          "Riesgo de analysis paralysis en Elaboration (exceso de diseño upfront)",
          "Transición de fase puede ser abrupta si estimaciones de Elaboration fueron incorrectas",
          "Requiere tooling enterprise costoso (IBM Rational Suite, ALM tools >$50K licencias)",
          "Puede sentirse 'anticuado' en organizaciones con cultura ágil moderna"
        ],
        "changeManagement": {
          "description": "Gestión de cambios estructurada por fase con impact analysis. Cambios en Inception/Elaboration son más baratos (requisitos aún flexibles). Cambios en Construction/Transition requieren Change Control Board (CCB) y aprobación formal debido a alto costo de refactoring.",
          "steps": [
            {
              "step": 1,
              "name": "Change Request Formal (CR)",
              "description": "Todo cambio de requisitos, arquitectura o alcance requiere CR formal con: justificación, impacto en tiempo/costo/riesgo, alternativas consideradas."
            },
            {
              "step": 2,
              "name": "Impact Analysis por Fase",
              "description": "Inception/Elaboration: cambios baratos (requisitos flexibles). Construction: cambios costosos (refactoring de código). Transition: cambios muy costosos (re-testing de UAT, re-training)."
            },
            {
              "step": 3,
              "name": "Change Control Board (CCB) Review",
              "description": "En Construction/Transition, CCB (Product Owner, Architect, Tech Lead, Sponsor) revisa CR y decide: Aprobar, Rechazar, Defer to Next Release."
            },
            {
              "step": 4,
              "name": "Re-estimación y Re-planificación",
              "description": "Cambios aprobados requieren re-estimar tiempo/costo afectado. Actualizar project plan, comunicar a stakeholders, ajustar próximas iteraciones."
            },
            {
              "step": 5,
              "name": "Implementation y Regression Testing",
              "description": "Implementar cambio en próxima iteración disponible. Ejecutar regression testing completo (cambios pueden romper features existentes)."
            },
            {
              "step": 6,
              "name": "Documentation Update",
              "description": "Actualizar documentación afectada: Use Cases, SAD, User Manuals, Test Cases, Release Notes. Versionar todos los documentos (vX.Y)."
            }
          ]
        },
        "tooling": [
          {
            "category": "Requirements Management",
            "tools": [
              "IBM DOORS, Jama, JIRA Requirements para trazabilidad de requisitos",
              "Enterprise Architect, Visual Paradigm para UML Use Cases y diagramas"
            ]
          },
          {
            "category": "Project Management",
            "tools": [
              "MS Project, JIRA, Monday.com con Gantt charts para fases y milestones",
              "Confluence, SharePoint para documentación centralizada (Vision, SAD)"
            ]
          },
          {
            "category": "Development",
            "tools": [
              "Git/GitHub/GitLab para version control de código y documentación",
              "CI/CD (Jenkins, GitHub Actions) para builds automatizados por iteración",
              "IBM Rational Suite (RUP tooling completo: ClearCase, ClearQuest)"
            ]
          },
          {
            "category": "Testing",
            "tools": [
              "Selenium, JMeter, Postman para testing automatizado (unit, integration, performance)",
              "SonarQube para code quality y test coverage tracking"
            ]
          },
          {
            "category": "Monitoring",
            "tools": [
              "Datadog, New Relic, Prometheus/Grafana para producción",
              "Slack/Teams con integraciones a JIRA para daily standups"
            ]
          }
        ],
        "references": [
          {
            "title": "Software Engineering (10th Edition) - Chapter 2.3: Incremental Development",
            "author": "Ian Sommerville",
            "year": 2015,
            "source": "Pearson"
          },
          {
            "title": "Software Engineering (10th Edition) - Chapter 2.4: Rational Unified Process",
            "author": "Ian Sommerville",
            "year": 2015,
            "source": "Pearson"
          },
          {
            "title": "The Rational Unified Process: An Introduction",
            "author": "Philippe Kruchten",
            "year": 2003,
            "source": "Addison-Wesley"
          }
        ]
      },
      "methodology": {
        "name": "Rational Unified Process (RUP)",
        "description": "Framework de proceso híbrido que combina 4 fases secuenciales macro (Inception, Elaboration, Construction, Transition) con desarrollo iterativo incremental dentro de cada fase. Énfasis en diseño de arquitectura robusta desde la fase de Elaboration (Architecture Baseline) para evitar refactoring arquitectónico costoso en fases posteriores, y uso extensivo de UML (Unified Modeling Language) para modelado visual de requisitos, diseño y arquitectura. RUP define 9 disciplinas (Requirements, Analysis & Design, Implementation, Test, Deployment, Configuration & Change Management, Project Management, Environment, Business Modeling) que se trabajan con diferente intensidad en cada fase, siguiendo una curva de esfuerzo específica. Cada fase termina con un milestone crítico que determina si el proyecto puede avanzar a la siguiente fase. RUP es altamente configurable (no es prescriptivo) y puede adaptarse desde proyectos pequeños hasta sistemas empresariales masivos.",
        "origin": {
          "creator": "Philippe Kruchten, Ivar Jacobson, Grady Booch (Rational Software Corporation, adquirida por IBM en 2003)",
          "year": 1998,
          "context": "Evolucionó del Rational Objectory Process (adquisición de Objectory AB de Ivar Jacobson en 1995) combinado con metodologías de Grady Booch. Desarrollado para proyectos empresariales grandes que necesitaban estructura y predictibilidad de Waterfall pero con flexibilidad de iteraciones para manejar cambios de requisitos. Muy popular en la década de 2000s (especialmente en banca, gobierno, telecomunicaciones) antes del auge masivo de metodologías Ágiles post-2010."
        },
        "principles": [
          "4 fases secuenciales macro con milestones críticos: Inception (Lifecycle Objective), Elaboration (Lifecycle Architecture), Construction (Initial Operational Capability), Transition (Product Release)",
          "Iteraciones time-boxed dentro de cada fase (típicamente 2-4 semanas por iteración, 2-4 iteraciones por fase)",
          "Architecture-centric: diseño de arquitectura baseline en Elaboration es crítico y debe estabilizarse antes de Construction (evita refactoring costoso después)",
          "Use case driven: casos de uso (UML use case diagrams) son artefacto central de captura de requisitos funcionales",
          "9 disciplinas con intensidad variable por fase (ej: Requirements alta en Inception/Elaboration, Implementation alta en Construction)",
          "Risk-driven: riesgos técnicos y de negocio se identifican y mitigan temprano en Inception/Elaboration (similar a Spiral pero estructurado en fases)",
          "Iterativo e incremental: cada iteración produce un incremento ejecutable (aunque deployment final es en Transition)"
        ],
        "differentiators": [
          "vs Waterfall puro: RUP tiene iteraciones dentro de cada fase con entregas incrementales, mientras Waterfall es estrictamente secuencial sin iteraciones",
          "vs Ágil puro (Scrum/XP): RUP es más pesado en documentación formal, planificación upfront y diseño arquitectónico exhaustivo, mientras Ágil minimiza documentación y favorece emergent design",
          "vs Scrum: RUP define 4 fases macro con milestones específicos y 9 disciplinas, mientras Scrum solo define sprints uniformes sin estructura macro de fases ni disciplinas"
        ],
        "references": {
          "chapter": "chapter-2",
          "sections": [
            "2.4 The Rational Unified Process",
            "2.3 Incremental development and delivery"
          ],
          "externalResources": [
            "Kruchten, P. (2003). The Rational Unified Process: An Introduction (3rd ed.). Addison-Wesley",
            "Jacobson, I., Booch, G., & Rumbaugh, J. (1999). The Unified Software Development Process. Addison-Wesley"
          ]
        }
      },
      "modeling": {
        "notations": [
          {
            "name": "UML (completo)",
            "description": "Unified Modeling Language completo con todos los diagramas para modelado exhaustivo.",
            "diagrams": [
              "Use Case",
              "Class",
              "Sequence",
              "State Machine",
              "Activity",
              "Component",
              "Deployment"
            ],
            "whenToUse": "RUP es use case driven y architecture-centric, requiere modelado UML exhaustivo en todas las fases",
            "tools": [
              "IBM Rational",
              "Enterprise Architect",
              "Visual Paradigm",
              "PlantUML"
            ]
          },
          {
            "name": "4+1 Views (Kruchten)",
            "description": "Modelo de arquitectura con 5 vistas: Logical, Process, Development, Physical, Scenarios.",
            "diagrams": [
              "Class Diagram (Logical)",
              "Sequence Diagram (Process)",
              "Component Diagram (Development)",
              "Deployment Diagram (Physical)"
            ],
            "whenToUse": "RUP arquitectura-céntrica requiere documentar arquitectura desde múltiples perspectivas en Elaboration",
            "tools": [
              "Rational Software Architect",
              "Visual Paradigm",
              "Enterprise Architect"
            ]
          }
        ],
        "primaryFocus": "Modelado exhaustivo UML y arquitectura 4+1 Views desde fase de Elaboration",
        "references": {
          "chapter": "chapter-5",
          "sections": [
            "5.2 UML diagrams",
            "5.5 Model-driven engineering"
          ]
        }
      },
      "architecture": {
        "patterns": [
          {
            "name": "Layered (N-Tier)",
            "description": "Arquitectura en capas (Presentation, Business Logic, Data Access) con separación clara de responsabilidades.",
            "advantages": [
              "Separación de concerns (UI, lógica de negocio, datos)",
              "Facilita testing de cada capa independientemente",
              "Reusabilidad de lógica de negocio entre diferentes interfaces",
              "Facilita mantenimiento (cambios en UI no afectan datos)"
            ],
            "disadvantages": [
              "Performance overhead (múltiples capas añaden latencia)",
              "Over-engineering para sistemas simples",
              "Acoplamiento entre capas puede generar rigidez"
            ],
            "whenToUse": "Sistemas transaccionales con lógica de negocio compleja y múltiples interfaces (web, móvil, API)",
            "tradeoffs": "Mantenibilidad y separación de concerns vs Performance (latencia de múltiples capas)"
          },
          {
            "name": "Service-Oriented Architecture (SOA)",
            "description": "Arquitectura basada en servicios reutilizables con interfaces bien definidas (SOAP/REST).",
            "advantages": [
              "Reusabilidad de servicios (ej: servicio de autenticación usado por múltiples apps)",
              "Interoperabilidad (servicios pueden ser consumidos por diferentes tecnologías)",
              "Escalabilidad independiente por servicio",
              "Evolución independiente de servicios"
            ],
            "disadvantages": [
              "Overhead de comunicación (latencia de red)",
              "Complejidad de governance (versionado de servicios)",
              "Performance inferior a monolito (múltiples llamadas de red)"
            ],
            "whenToUse": "Sistemas empresariales grandes con múltiples aplicaciones compartiendo servicios comunes",
            "tradeoffs": "Reusabilidad y interoperabilidad vs Performance (latencia de red)"
          }
        ],
        "style": "Monolito modularizado o SOA (dependiendo de tamaño)",
        "qualityAttributes": {
          "scalability": "Medium-High - RUP arquitectura-céntrica facilita diseño para escalabilidad desde Elaboration.",
          "maintainability": "High - Arquitectura bien documentada (4+1 Views) facilita mantenimiento.",
          "performance": "Medium - Diseño upfront permite optimizaciones tempranas (caching, indexing).",
          "security": "High - RUP seguridad se diseña en Elaboration (análisis de amenazas, autenticación/autorización)."
        },
        "references": {
          "chapter": "chapter-6",
          "sections": [
            "6.3 Application architectures",
            "6.5 Distributed systems architectures"
          ]
        }
      },
      "timeline": [
        {
          "week": "1-4",
          "phase": "Inicio",
          "tasks": [
            "Definir alcance y módulos principales",
            "Arquitectura de alto nivel",
            "Modelo de datos inicial",
            "Setup de infraestructura"
          ]
        },
        {
          "week": "5-8",
          "phase": "Elaboración",
          "tasks": [
            "Diseño completo de base de datos",
            "Definición de APIs",
            "Arquitectura detallada",
            "Prototipo técnico"
          ]
        },
        {
          "week": "9-14",
          "phase": "Incremento 1",
          "tasks": [
            "Autenticación y autorización",
            "Módulo core (primera entidad transaccional)",
            "Testing de concurrencia básico"
          ]
        },
        {
          "week": "15-20",
          "phase": "Incremento 2",
          "tasks": [
            "Módulos transaccionales principales",
            "Reportes básicos",
            "Optimización de queries"
          ]
        },
        {
          "week": "21-30",
          "phase": "Incrementos 3-4",
          "tasks": [
            "Funcionalidades restantes",
            "Integración con sistemas externos",
            "Testing de carga",
            "Performance tuning"
          ]
        },
        {
          "week": "31-36",
          "phase": "Transición",
          "tasks": [
            "UAT (User Acceptance Testing)",
            "Migración de datos",
            "Capacitación",
            "Go-live controlado"
          ]
        }
      ],
      "avoid": [
        "No diseñar base de datos anticipadamente",
        "Operaciones sin transacciones",
        "Ignorar índices de BD",
        "No testear concurrencia",
        "N+1 queries",
        "No considerar escalabilidad"
      ],
      "templates": [
        "tpl-001",
        "tpl-004",
        "tpl-006",
        "tpl-010"
      ],
      "chapters": [
        2,
        4,
        5,
        6
      ]
    },
    "rec-005": {
      "id": "rec-005",
      "title": "Sistema Transaccional → Mediano → Scrum",
      "path": [
        "Transaccional",
        "Volátiles",
        "Cliente"
      ],
      "pathDescription": "Sistema Transaccional → Requisitos Volátiles → Cliente Disponible → Equipo Mediano",
      "process": {
        "name": "Scrum",
        "type": "agile-iterative",
        "chapter": 3,
        "description": "Framework ágil para desarrollo iterativo incremental basado en sprints de tiempo fijo (1-4 semanas). Enfocado en entregas rápidas, auto-organización del equipo y adaptación continua basada en feedback. Apropiado para equipos únicos (8-12 personas) con requisitos volátiles y necesidad de time-to-market rápido.",
        "why": [
          "Entregas rápidas cada 2 semanas permiten validar funcionalidad con usuarios reales temprano",
          "Adaptación continua a requisitos cambiantes mediante re-priorización de Product Backlog",
          "Feedback temprano del Product Owner y stakeholders reduce riesgo de construir features incorrectas",
          "Auto-organización del equipo maximiza productividad y ownership",
          "Transparencia del proceso (burndown chart, tablero Kanban) facilita gestión de expectativas"
        ],
        "how": [
          "Sprints de 2 semanas que producen incremento funcional potencialmente shippable",
          "4 ceremonias por sprint: Planning (4h), Daily Standup (15min diario), Review (2h), Retrospective (1.5h)",
          "3 roles: Product Owner (priorización), Scrum Master (facilitación), Development Team (6-10 personas)",
          "Product Backlog con user stories priorizadas por valor de negocio, estimadas en story points",
          "Definition of Done: código testeado (>80% coverage), code review aprobado, deployable a staging"
        ],
        "phases": [
          {
            "id": "phase-scrum-planning",
            "name": "Sprint Planning",
            "order": 1,
            "description": "Ceremonia de inicio de sprint donde equipo selecciona user stories del Product Backlog, define Sprint Goal y descompone stories en tareas técnicas. Objetivo: Crear Sprint Backlog con trabajo comprometido para las próximas 2 semanas.",
            "duration": "4 horas (sprint de 2 semanas)",
            "activities": [
              "Product Owner presenta top user stories del Product Backlog priorizadas por ROI y valor de negocio",
              "Development Team estima complejidad de cada story usando Planning Poker (escala Fibonacci: 1, 2, 3, 5, 8, 13 story points)",
              "Equipo selecciona stories que caben en velocity promedio (20-30 story points para sprint de 2 semanas)",
              "Definir Sprint Goal: objetivo coherente del sprint (ej: 'Usuario puede crear y editar órdenes de compra')",
              "Descomponer cada story en tareas técnicas (desarrollo, testing, code review, deployment) de 2-8 horas c/u",
              "Identificar dependencias técnicas y riesgos del sprint (integraciones, performance, data migration)",
              "Asignar tareas iniciales (auto-asignación por developers según expertise)",
              "Output: Sprint Backlog visualizado en tablero Kanban (Jira, Trello) con columnas To Do / In Progress / Done"
            ],
            "inputs": [
              "Product Backlog refinado (stories con acceptance criteria claros)",
              "Velocity promedio de últimos 3 sprints (para estimar capacidad)",
              "Definition of Done acordada por equipo",
              "Feedback de Sprint Review anterior (bugs, ajustes solicitados)"
            ],
            "outputs": [
              "Sprint Backlog (subset de Product Backlog para este sprint)",
              "Sprint Goal (objetivo del sprint en 1 frase)",
              "Tareas técnicas (descomposición de stories en tareas de 2-8h)",
              "Burndown chart inicializado (trabajo restante vs días del sprint)"
            ],
            "deliverables": [
              {
                "name": "Sprint Backlog en tablero Kanban",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Product Owner",
                  "Development Team"
                ]
              },
              {
                "name": "Sprint Goal Document",
                "template": "tpl-009",
                "required": true,
                "reviewedBy": [
                  "Product Owner",
                  "Scrum Master"
                ]
              }
            ],
            "gate": {
              "name": "Sprint Commitment",
              "criteria": [
                "Sprint Goal definido y aceptado por Product Owner y Development Team",
                "Stories seleccionadas caben en velocity promedio (no over-commitment)",
                "Todas las stories tienen acceptance criteria claros y testables",
                "Dependencias técnicas identificadas y mitigadas (o con plan de acción)",
                "Equipo tiene confianza de completar trabajo comprometido"
              ],
              "decision": "COMMIT / ADJUST SCOPE / CANCEL SPRINT (si Product Owner cambia prioridades drásticamente)",
              "approvers": [
                "Product Owner",
                "Development Team",
                "Scrum Master"
              ]
            },
            "keyStakeholders": [
              "Product Owner",
              "Scrum Master",
              "Development Team (6-10 developers)"
            ]
          },
          {
            "id": "phase-scrum-daily-dev",
            "name": "Daily Development (with Daily Standups)",
            "order": 2,
            "description": "Fase de ejecución del sprint (10 días hábiles para sprint de 2 semanas) donde Development Team implementa, testea y code-reviewea user stories. Sincronización diaria mediante Daily Standup de 15 minutos. Objetivo: Completar Sprint Backlog cumpliendo Definition of Done.",
            "duration": "10 días hábiles (2 semanas)",
            "activities": [
              "Daily Standup (9:00 AM, 15 min): Cada developer responde: ¿Qué hice ayer? ¿Qué haré hoy? ¿Tengo impedimentos?",
              "Desarrollo iterativo: Developers auto-asignan tareas del Sprint Backlog, implementan código, escriben tests",
              "Code review obligatorio: Pull requests revisados por al menos 1 peer antes de merge (GitHub/GitLab)",
              "Continuous Integration: Tests automatizados (unit, integration) ejecutados en cada merge a main branch",
              "Testing continuo: QA engineers (si hay) ejecutan testing exploratorio de features completadas",
              "Actualización de tablero Kanban: Mover tareas de To Do → In Progress → Done conforme avanzan",
              "Scrum Master remueve impedimentos: Bloqueos técnicos, dependencias externas, distracciones organizacionales",
              "Backlog refinement ad-hoc (mid-sprint): Product Owner clarifica acceptance criteria si surgen dudas",
              "Product Owner valida features completadas mid-sprint (opcional): Feedback temprano para ajustes",
              "Monitoring de burndown chart: Scrum Master verifica progreso diario, alerta si equipo está atrasado"
            ],
            "inputs": [
              "Sprint Backlog con tareas priorizadas",
              "Definition of Done (criterios de completitud)",
              "Development environment configurado (repos, CI/CD, staging)",
              "Velocity promedio (para tracking de progreso)"
            ],
            "outputs": [
              "Incremento funcional parcial (features completadas durante sprint)",
              "Código mergeado a main branch (con tests pasando)",
              "Burndown chart actualizado diariamente (trabajo restante)",
              "Lista de impedimentos removidos y pendientes (tracking de Scrum Master)"
            ],
            "deliverables": [
              {
                "name": "Working Software (incremento funcional)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Development Team",
                  "Product Owner (mid-sprint opcional)"
                ]
              },
              {
                "name": "Burndown Chart (progreso diario)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Scrum Master"
                ]
              },
              {
                "name": "Impediments Log (tracking de bloqueos)",
                "template": "tpl-011",
                "required": false,
                "reviewedBy": [
                  "Scrum Master"
                ]
              }
            ],
            "gate": {
              "name": "Daily Progress Check",
              "criteria": [
                "Al menos 1 tarea completada por developer cada 2 días (evitar estancamiento)",
                "Burndown chart trending hacia cero al final del sprint (no muy atrasado)",
                "Impedimentos críticos removidos dentro de 24h (Scrum Master activo)",
                "Daily Standup <15 min (no convertir en status meeting largo)",
                "Code reviews completados dentro de 4h de abrir PR (no bloquear flujo)"
              ],
              "decision": "CONTINUE / ESCALATE IMPEDIMENTS / ADJUST SPRINT SCOPE (si burndown muy atrasado)",
              "approvers": [
                "Scrum Master",
                "Development Team"
              ]
            },
            "keyStakeholders": [
              "Development Team",
              "Scrum Master",
              "Product Owner (validación mid-sprint)"
            ]
          },
          {
            "id": "phase-scrum-review",
            "name": "Sprint Review",
            "order": 3,
            "description": "Ceremonia de demo del incremento funcional a stakeholders. Product Owner acepta o rechaza user stories basado en Definition of Done. Stakeholders dan feedback que alimenta Product Backlog. Objetivo: Validar que el incremento cumple expectativas y recoger feedback para próximos sprints.",
            "duration": "2 horas",
            "activities": [
              "Product Owner presenta Sprint Goal y user stories comprometidas al inicio del sprint",
              "Development Team demuestra incremento funcional en staging environment (working software, no slides)",
              "Demo de cada user story completada: Mostrar flujo end-to-end desde perspectiva de usuario final",
              "Product Owner valida acceptance criteria de cada story: Acepta (DONE) o Rechaza (vuelve a backlog con ajustes)",
              "Stakeholders dan feedback: Features que faltan, UX issues, bugs encontrados, nuevas ideas",
              "Product Owner actualiza Product Backlog: Agregar nuevas stories basadas en feedback, re-priorizar existentes",
              "Revisar métricas del sprint: Velocity alcanzada (story points completados), burndown final, bugs reportados",
              "Discusión de impedimentos no removidos: ¿Afectarán próximos sprints? ¿Requieren escalación?",
              "Proyección de roadmap: Product Owner muestra próximas 2-3 sprints según backlog actualizado"
            ],
            "inputs": [
              "Incremento funcional deployado en staging (working software)",
              "Sprint Backlog con stories marcadas como Done",
              "Definition of Done (criterios de aceptación)",
              "Feedback de stakeholders de sprints previos (para validar si se incorporó)"
            ],
            "outputs": [
              "User stories aceptadas (pasan a DONE, potencialmente shippable a producción)",
              "User stories rechazadas (vuelven a Product Backlog con ajustes necesarios)",
              "Product Backlog actualizado (nuevas stories, re-priorización)",
              "Velocity del sprint (story points completados: ej 25 puntos)",
              "Action items de feedback de stakeholders (mejoras para próximos sprints)"
            ],
            "deliverables": [
              {
                "name": "Sprint Review Report (aceptación de stories)",
                "template": "tpl-013",
                "required": true,
                "reviewedBy": [
                  "Product Owner",
                  "Stakeholders"
                ]
              },
              {
                "name": "Updated Product Backlog (con feedback incorporado)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Product Owner"
                ]
              },
              {
                "name": "Velocity Metrics (story points completados)",
                "template": "tpl-013",
                "required": true,
                "reviewedBy": [
                  "Scrum Master"
                ]
              }
            ],
            "gate": {
              "name": "Increment Acceptance",
              "criteria": [
                "Al menos 80% de user stories comprometidas completadas y aceptadas por Product Owner",
                "Incremento funcional deployable a producción (cumple Definition of Done)",
                "Zero bugs críticos introducidos (si hay bugs, son low priority)",
                "Stakeholders satisfechos con progreso (feedback mayormente positivo)",
                "Velocity estable o mejorando (no cayendo sprint a sprint)"
              ],
              "decision": "ACCEPT INCREMENT / PARTIAL ACCEPT (algunas stories rechazadas) / REJECT (muy pocas stories completadas)",
              "approvers": [
                "Product Owner",
                "Stakeholders"
              ]
            },
            "keyStakeholders": [
              "Product Owner",
              "Development Team",
              "Stakeholders (usuarios finales, management)",
              "Scrum Master"
            ]
          },
          {
            "id": "phase-scrum-retrospective",
            "name": "Sprint Retrospective",
            "order": 4,
            "description": "Ceremonia de mejora continua donde equipo inspecciona el proceso (no el producto) e identifica acciones de mejora. Objetivo: Incrementar productividad, calidad y satisfacción del equipo en próximos sprints.",
            "duration": "1.5 horas",
            "activities": [
              "Set the stage (10 min): Scrum Master crea ambiente seguro para feedback honesto (lo dicho en retro queda en retro)",
              "Gather data (20 min): Equipo lista hechos objetivos del sprint (metrics: velocity, bugs, cycle time, impedimentos)",
              "Generate insights (30 min): Discusión facilitada por Scrum Master usando formato 'What went well / What didn't / What to improve'",
              "What went well: Identificar prácticas exitosas (ej: pair programming aceleró feature X, daily standups más cortos fueron efectivos)",
              "What didn't go well: Problemas enfrentados (ej: code reviews lentos bloquearon flujo, ambiguity en acceptance criteria causó re-trabajo)",
              "Decide what to do (20 min): Priorizar top 3 problemas y definir acciones concretas con owner y deadline",
              "Action items SMART: Específicos, Medibles, Alcanzables, Relevantes, con Tiempo definido (ej: 'Reducir tiempo de code review a <4h mediante notificaciones Slack')",
              "Close retrospective (10 min): Scrum Master resume action items, asigna owners, agrega a tablero de mejora continua",
              "Tracking de action items previos: Revisar si acciones de retrospectiva anterior se completaron (accountability)"
            ],
            "inputs": [
              "Sprint metrics (velocity, burndown, cycle time, bugs)",
              "Impediments log del sprint",
              "Feedback anecdótico de team members (frustraciones, éxitos)",
              "Action items de retrospectiva anterior (para tracking)"
            ],
            "outputs": [
              "Lista de 'What went well' (prácticas exitosas a mantener)",
              "Lista de 'What didn't go well' (problemas identificados)",
              "Top 3 action items priorizados con owner y deadline",
              "Retrospective summary document (para referencia futura)",
              "Action items board actualizado (tracking de mejoras continuas)"
            ],
            "deliverables": [
              {
                "name": "Retrospective Action Items (top 3 mejoras priorizadas)",
                "template": "tpl-012",
                "required": true,
                "reviewedBy": [
                  "Scrum Master",
                  "Development Team"
                ]
              },
              {
                "name": "Retrospective Summary (what went well, didn't, improvements)",
                "template": "tpl-012",
                "required": false,
                "reviewedBy": [
                  "Scrum Master"
                ]
              }
            ],
            "gate": {
              "name": "Continuous Improvement Commitment",
              "criteria": [
                "Al menos 3 action items concretos definidos con owner y deadline",
                "Action items son SMART (específicos y medibles, no vagos como 'comunicar mejor')",
                "Equipo tiene consenso en priorización de action items (no impuestos por Scrum Master)",
                "Action items de retrospectiva anterior fueron revisados (accountability)",
                "Ambiente de retro fue seguro (todos participaron, no blame game)"
              ],
              "decision": "COMMIT TO IMPROVEMENTS / DEFER (si equipo no tiene consenso)",
              "approvers": [
                "Development Team",
                "Scrum Master"
              ]
            },
            "keyStakeholders": [
              "Development Team",
              "Scrum Master",
              "Product Owner (opcional, generalmente no participa)"
            ]
          }
        ],
        "iterationStrategy": "Scrum ejecuta sprints de 2 semanas (10 días hábiles) que producen incremento funcional potencialmente shippable. Velocity estable de 20-30 story points por sprint después de 3-4 sprints de calibración. Product Backlog refinement continuo: Product Owner y equipo refinan top 20% del backlog semanalmente (grooming sessions de 1h). Re-priorización permitida entre sprints pero NO mid-sprint (scope freeze). Feedback de Sprint Review alimenta próximo sprint.",
        "whenToUse": [
          "Requisitos volátiles que cambian frecuentemente (prioridades de negocio, feedback de usuarios, pivoting)",
          "Equipo único mediano (8-12 personas) sin necesidad de coordinación multi-equipo",
          "Product Owner disponible >50% del tiempo (para sprint planning, review, backlog refinement, clarificaciones)",
          "Necesidad de time-to-market rápido (entregas cada 2 semanas vs 6 meses waterfall)",
          "Stakeholders requieren demos frecuentes de progreso (validación continua, no sorpresas al final)",
          "Sistema transaccional mediano sin complejidad arquitectónica extrema (ej: gestión órdenes, CRM, booking)",
          "Equipo cross-funcional disponible (developers, QA, UX en mismo equipo, no silos)",
          "Organización tolera cambios de alcance (no contratos de scope fijo inmutables)",
          "Cultura de ownership y auto-organización (equipo puede tomar decisiones técnicas sin aprobaciones lentas)",
          "Incrementos pequeños son valiosos para negocio (no necesitan sistema completo para entregar valor)"
        ],
        "whenNotToUse": [
          "Requisitos completamente estables y conocidos upfront (Cascada o RUP más eficiente, menos overhead de ceremonias)",
          "Product Owner no disponible o sin autoridad (Scrum requiere PO empowered que pueda tomar decisiones rápidas)",
          "Equipo distribuido con zonas horarias muy diferentes (daily standup, planning sincrónicos difíciles)",
          "Sistema simple CRUD sin complejidad (overhead de 4 ceremonias no justifica para 1 mes de desarrollo)",
          "Equipo <5 personas (ceremonias Scrum demasiado pesadas, XP puro mejor)",
          "Regulaciones requieren documentación exhaustiva upfront (FDA, aviación, nuclear - waterfall/RUP necesario)",
          "Cultura organizacional jerárquica anti-ágil (management quiere gantt charts, no acepta cambios mid-project)",
          "Stakeholders no disponibles para sprint reviews cada 2 semanas (feedback loop se rompe)",
          "Sistema con dependencias críticas externas fuera de control del equipo (Scrum asume equipo autónomo)",
          "Presupuesto o timeline absolutamente fijo sin flexibilidad (Scrum requiere trade-off entre scope/tiempo/costo)"
        ],
        "advantages": [
          "Time-to-market rápido: Entregas cada 2 semanas vs 6-12 meses de waterfall (valor al negocio temprano)",
          "Adaptabilidad a cambios: Re-priorización de backlog entre sprints sin costo alto de re-planificación",
          "Feedback temprano: Validación con usuarios reales cada 2 semanas reduce riesgo de construir features incorrectas",
          "Transparencia: Burndown chart, tablero Kanban, velocity hacen progreso visible a stakeholders",
          "Calidad continua: Definition of Done con testing obligatorio previene deuda técnica acumulada",
          "Motivación de equipo: Auto-organización y ownership incrementan satisfacción y productividad",
          "Risk mitigation temprana: Problemas técnicos, de integración o de requisitos detectados en sprints tempranos",
          "Ceremonias estructuradas: Planning, review, retrospective aseguran alineación sin micro-management",
          "Velocity predecible: Después de 3-4 sprints, equipo puede estimar roadmap con ±20% accuracy",
          "Mejora continua: Retrospectives cada 2 semanas optimizan proceso incrementalmente (no esperan fin de proyecto)"
        ],
        "disadvantages": [
          "Overhead de ceremonias: 4h planning + 15min diario + 2h review + 1.5h retro = ~12h/sprint (12% del tiempo)",
          "Requiere Product Owner full-time disponible: Si PO no disponible, equipo se bloquea esperando decisiones",
          "Curva de aprendizaje: Equipo nuevo en Scrum tarda 3-4 sprints en estabilizar velocity (período de calibración)",
          "Scope creep si no hay disciplina: Cambios mid-sprint rompen compromiso y afectan velocity (requiere PO firme)",
          "Difícil estimar largo plazo: Velocity variable hace roadmap >3 meses impreciso (stakeholders piden fechas fijas)",
          "Burnout si sprints mal gestionados: Over-commitment crónico lleva a crunch continuo (no sostenible)",
          "Definition of Done puede relajarse: Presión de completar stories puede llevar a compromisos en calidad",
          "Daily standup puede volverse status report: Sin facilitación de Scrum Master, degenera en meeting largo y aburrido",
          "Requiere stakeholders comprometidos: Si stakeholders no asisten a sprint reviews, feedback loop se rompe",
          "No apto para todos los dominios: Regulaciones estrictas (FDA, SOX) requieren documentación que Scrum no genera por defecto"
        ],
        "changeManagement": {
          "description": "Gestión de cambios mid-sprint y entre sprints con balance entre flexibilidad y estabilidad del sprint.",
          "steps": [
            {
              "step": 1,
              "name": "Scope Freeze Mid-Sprint",
              "description": "Regla: NO cambios en Sprint Backlog mid-sprint excepto si es crítico (bug de producción, cambio de regulación). Product Owner debe justificar urgencia y equipo debe consensuar si aceptar cambio o defer a próximo sprint."
            },
            {
              "step": 2,
              "name": "Emergency Change Exception",
              "description": "Si cambio mid-sprint es inevitable (producción caída, seguridad crítica), equipo swap: Remover story de igual complejidad del sprint y agregar cambio urgente. Documentar en Sprint Review por qué sprint goal cambió."
            },
            {
              "step": 3,
              "name": "Backlog Re-Prioritization (entre sprints)",
              "description": "Product Owner puede re-priorizar Product Backlog libremente entre sprints basado en feedback de Sprint Review, cambios de mercado, o nuevas oportunidades. Equipo selecciona nuevas top stories en próximo Sprint Planning."
            },
            {
              "step": 4,
              "name": "Handling Incomplete Stories",
              "description": "Stories no completadas al final del sprint NO pasan a Done. Opciones: (1) Vuelven a Product Backlog re-estimadas, (2) Se splitean en stories más pequeñas, (3) Se cancelan si ya no son valiosas. NO arrastrar stories automáticamente a próximo sprint."
            },
            {
              "step": 5,
              "name": "Stakeholder Change Requests",
              "description": "Stakeholders pueden solicitar nuevas features o cambios en cualquier momento. Product Owner evalúa, prioriza en Product Backlog y comunica cuándo se implementarán (próximo sprint, en 3 sprints, never). Transparencia de roadmap previene expectativas incorrectas."
            },
            {
              "step": 6,
              "name": "Definition of Done Updates",
              "description": "Equipo puede actualizar Definition of Done en Sprint Retrospective para incrementar calidad (ej: agregar performance testing). Cambios aplican a partir de próximo sprint, no retroactivamente."
            }
          ]
        },
        "tooling": [
          {
            "category": "Sprint Management",
            "tools": [
              "Jira (tablero Kanban, burndown charts, backlog management)",
              "Trello (alternativa lightweight para equipos pequeños)",
              "Azure DevOps (integración con Microsoft stack)"
            ]
          },
          {
            "category": "Communication",
            "tools": [
              "Slack/Teams (daily standups remotos, notificaciones de CI/CD)",
              "Zoom/Meet (sprint planning, review, retrospective remotas)",
              "Miro/Mural (retrospective boards, sprint planning virtual)"
            ]
          },
          {
            "category": "Development",
            "tools": [
              "GitHub/GitLab (version control, pull requests, code review)",
              "CI/CD (GitHub Actions, Jenkins, GitLab CI para tests automatizados)",
              "SonarQube (code quality, test coverage tracking)"
            ]
          },
          {
            "category": "Documentation",
            "tools": [
              "Confluence (user stories, acceptance criteria, sprint reports)",
              "Notion (alternativa moderna para documentación colaborativa)"
            ]
          }
        ],
        "references": [
          {
            "title": "Software Engineering (10th Edition) - Chapter 3: Agile Software Development",
            "author": "Ian Sommerville",
            "year": 2015,
            "source": "Pearson"
          },
          {
            "title": "The Scrum Guide (2020)",
            "author": "Ken Schwaber, Jeff Sutherland",
            "year": 2020,
            "source": "Scrum.org"
          },
          {
            "title": "Scrum: The Art of Doing Twice the Work in Half the Time",
            "author": "Jeff Sutherland",
            "year": 2014,
            "source": "Crown Business"
          }
        ]
      },
      "methodology": {
        "name": "Scrum Framework",
        "description": "Framework ágil ligero (lightweight) para desarrollo iterativo incremental basado en sprints time-boxed de duración fija (típicamente 1-4 semanas, recomendado 2 semanas). Enfocado en auto-organización del equipo (self-organizing teams), entregas frecuentes de incrementos funcionales potencialmente desplegables (potentially shippable increments) y adaptación continua basada en feedback de stakeholders y retrospectivas. Scrum define una estructura mínima de 3 roles (Product Owner, Scrum Master, Development Team), 4 ceremonias obligatorias (Sprint Planning, Daily Standup, Sprint Review, Sprint Retrospective) y 3 artefactos (Product Backlog, Sprint Backlog, Increment). Scrum es deliberadamente incompleto: no prescribe prácticas técnicas (testing, CI/CD, arquitectura), permitiendo que equipos las definan. Se basa en empirismo (transparencia, inspección, adaptación) y promueve mejora continua mediante retrospectivas regulares.",
        "origin": {
          "creator": "Ken Schwaber y Jeff Sutherland",
          "year": 1995,
          "context": "Presentado formalmente en OOPSLA 1995 (Object-Oriented Programming, Systems, Languages & Applications). Inspirado en el paper 'The New New Product Development Game' (Takeuchi & Nonaka, Harvard Business Review, 1986) que analizaba equipos de desarrollo de producto en Toyota, Honda y Canon. La Scrum Guide oficial fue publicada en 2010 y es actualizada periódicamente por Schwaber y Sutherland. Desarrollado inicialmente para equipos pequeños (5-9 personas) que necesitaban adaptarse rápidamente a cambios de requisitos en entornos de alta incertidumbre."
        },
        "principles": [
          "Empirismo (empirical process control): transparencia (todos ven el trabajo), inspección (revisar progreso frecuentemente), adaptación (ajustar proceso/producto basado en feedback)",
          "Auto-organización del equipo (self-organizing): Development Team decide cómo hacer el trabajo técnico, sin micro-gestión externa",
          "Sprints time-boxed de duración fija con entrega de incremento funcional potencialmente desplegable al final de cada sprint",
          "Product Owner prioriza Product Backlog basado en valor de negocio (ROI, riesgos, dependencias), no en detalles técnicos",
          "Daily Standup de 15 minutos para sincronización rápida del equipo (¿qué hice ayer? ¿qué haré hoy? ¿impedimentos?)",
          "Sprint Retrospective obligatoria al final de cada sprint para inspección del proceso y mejora continua (Kaizen)",
          "Working software como medida principal de progreso (no documentación ni % de tareas completadas)"
        ],
        "differentiators": [
          "vs XP: Scrum define estructura de proceso (ceremonias, roles, artefactos) pero NO prescribe prácticas técnicas, mientras XP prescribe 12 prácticas técnicas obligatorias (TDD, pair programming, CI, etc.)",
          "vs Kanban: Scrum usa sprints time-boxed con planning/review/retro al inicio/final de cada sprint, mientras Kanban es flujo continuo (continuous flow) sin time-boxes ni ceremonias obligatorias",
          "vs Waterfall: Scrum es iterativo con entregas incrementales frecuentes (cada 1-4 semanas), mientras Waterfall es secuencial con entrega única al final del proyecto (big-bang)"
        ],
        "references": {
          "chapter": "chapter-3",
          "sections": [
            "3.2 Agile development techniques",
            "3.3 Agile project management"
          ],
          "externalResources": [
            "Schwaber, K., & Sutherland, J. (2020). The Scrum Guide. https://scrumguides.org",
            "Sutherland, J. (2014). Scrum: The Art of Doing Twice the Work in Half the Time. Crown Business",
            "Takeuchi, H., & Nonaka, I. (1986). The New New Product Development Game. Harvard Business Review"
          ]
        }
      },
      "modeling": {
        "notations": [
          {
            "name": "User Story Mapping",
            "description": "Técnica ágil para organizar user stories en épicas y sprints.",
            "diagrams": [
              "User Story Map (horizontal: flujo usuario, vertical: prioridad)"
            ],
            "whenToUse": "Scrum Product Backlog refinement (organizar stories en sprints)",
            "tools": [
              "Miro",
              "Mural",
              "StoriesOnBoard",
              "Jira"
            ]
          },
          {
            "name": "UML ligero",
            "description": "Documentación técnica ligera (no exhaustiva como RUP). Solo diagramas críticos.",
            "diagrams": [
              "Class Diagram (diseño básico)",
              "Sequence Diagram (flujos críticos)",
              "Component Diagram (arquitectura)"
            ],
            "whenToUse": "Scrum teams documentan arquitectura high-level sin detalles exhaustivos",
            "tools": [
              "Lucidchart",
              "Draw.io",
              "Mermaid (markdown-based)",
              "PlantUML"
            ]
          },
          {
            "name": "C4 Model",
            "description": "Modelo de 4 niveles (Context, Container, Component, Code) para documentar arquitectura moderna.",
            "diagrams": [
              "C4 Context Diagram (sistema + actores)",
              "C4 Container Diagram (apps, DBs, message brokers)"
            ],
            "whenToUse": "Scrum teams documentan arquitectura high-level con C4 (Context, Container) sin detalles exhaustivos",
            "tools": [
              "Structurizr",
              "Draw.io",
              "Mermaid",
              "C4-PlantUML"
            ]
          }
        ],
        "primaryFocus": "Modelado ligero centrado en user stories y arquitectura high-level (no documentación exhaustiva)",
        "references": {
          "chapter": "chapter-3",
          "sections": [
            "3.2 Agile development techniques"
          ]
        }
      },
      "architecture": {
        "patterns": [
          {
            "name": "Monolito modular",
            "description": "Monolito con módulos bien definidos (separación por bounded contexts de DDD).",
            "advantages": [
              "Simplicidad operacional (1 deployment)",
              "Transacciones ACID (sin distributed transactions)",
              "Debugging fácil (todo en 1 proceso)",
              "Bajo costo de infraestructura"
            ],
            "disadvantages": [
              "Escalamiento solo vertical (no horizontal por módulo)",
              "Deployment monolítico (cambio pequeño requiere deployment completo)",
              "Acoplamiento puede crecer con el tiempo si no se cuida modularidad"
            ],
            "whenToUse": "Scrum team único (rec-005: 8-12 personas) con sistema mediano",
            "tradeoffs": "Simplicidad operacional vs Limitaciones de escalamiento"
          },
          {
            "name": "MVC/MVVM (Frontend)",
            "description": "Patrón para frontend (web/móvil) que separa lógica de presentación.",
            "advantages": [
              "Separación de UI y lógica de negocio",
              "Testabilidad (ViewModel/Controller testeable sin UI)",
              "Reactive programming (UI se actualiza automáticamente)"
            ],
            "disadvantages": [
              "Curva de aprendizaje (reactive programming)",
              "Boilerplate code puede ser significativo"
            ],
            "whenToUse": "Apps web modernas (React, Vue, Angular) o móviles (Flutter, React Native)",
            "tradeoffs": "Testabilidad y reactive UI vs Complejidad de boilerplate"
          }
        ],
        "style": "Monolito modular (backend), MVC/MVVM (frontend)",
        "qualityAttributes": {
          "scalability": "Medium - Escalamiento vertical. Load balancer con sticky sessions para horizontal limitado.",
          "maintainability": "High - Scrum iterativo facilita refactoring continuo. Tests automatizados críticos. Modularidad clara.",
          "performance": "Medium-High - Sprints permiten optimizaciones iterativas. Monitoring con APM (New Relic, Datadog).",
          "security": "High - Security user stories en Product Backlog. Sprint Reviews validan controles de seguridad."
        },
        "references": {
          "chapter": "chapter-6",
          "sections": [
            "6.3 Application architectures",
            "6.4 Architectural patterns"
          ]
        }
      },
      "timeline": [
        {
          "week": "1-2",
          "phase": "Sprint 0",
          "tasks": [
            "Setup técnico completo",
            "Definir arquitectura base",
            "Configurar BD con migrations",
            "CI/CD pipeline",
            "Herramientas de testing de carga"
          ]
        },
        {
          "week": "3-6",
          "phase": "Sprints 1-2",
          "tasks": [
            "Módulo de autenticación",
            "CRUD básico de entidad principal",
            "Testing de concurrencia",
            "Performance baseline"
          ]
        },
        {
          "week": "7-14",
          "phase": "Sprints 3-6",
          "tasks": [
            "Funcionalidades transaccionales core",
            "Reportes básicos",
            "Performance optimization",
            "Integración con sistemas externos"
          ]
        },
        {
          "week": "15+",
          "phase": "Sprints continuos",
          "tasks": [
            "Features adicionales según backlog",
            "Monitoreo de performance",
            "Optimización de queries",
            "Refactorización continua"
          ]
        }
      ],
      "avoid": [
        "Operaciones sin transacciones",
        "No testear concurrencia",
        "Ignorar índices de BD",
        "N+1 queries",
        "No considerar escalabilidad",
        "Sprint sin demo funcional"
      ],
      "templates": [
        "tpl-004",
        "tpl-005",
        "tpl-006",
        "tpl-010"
      ],
      "chapters": [
        2,
        3,
        5,
        6
      ]
    },
    "rec-006": {
      "id": "rec-006",
      "title": "Web/SaaS → Startup → Pequeño",
      "path": [
        "Web/SaaS",
        "Startup",
        "Cliente",
        "Pequeño"
      ],
      "pathDescription": "Sistema Web/SaaS → Startup → Cliente Disponible → Equipo Pequeño (<10)",
      "process": {
        "name": "Scrum/XP Hybrid",
        "type": "agile-xp-hybrid",
        "chapter": 3,
        "description": "Framework ágil que combina ceremonias de Scrum con prácticas técnicas de XP (Extreme Programming). Sprints cortos de 1 semana para máxima velocidad, TDD obligatorio, pair programming 50% del tiempo, CI múltiples veces al día. Ideal para startups y equipos pequeños (5-8 personas) que necesitan experimentar rápido y mantener calidad técnica alta.",
        "why": [
          "Sprints de 1 semana permiten pivoting rápido si experimentos de producto fallan (fail-fast culture)",
          "TDD (Test-Driven Development) asegura calidad técnica desde el inicio, minimiza deuda técnica en crecimiento rápido",
          "Pair programming acelera onboarding de nuevos developers y distribuye conocimiento (crítico en startups con rotación)",
          "Continuous Integration múltiples veces al día detecta bugs de integración inmediatamente (no acumulados)",
          "Simple Design y YAGNI (You Aren't Gonna Need It) evitan over-engineering en contexto de incertidumbre de startup"
        ],
        "how": [
          "Sprints de 1 semana (lunes-viernes) con planning 2h lunes, review 1h viernes, retrospective 45min viernes",
          "Daily standup 10 min (equipo pequeño permite sincronización rápida)",
          "TDD obligatorio: Write test → See it fail (red) → Write code → Test passes (green) → Refactor",
          "Pair programming 50% del tiempo: Rotación de pairs cada día, knowledge sharing continuo",
          "CI/CD agresivo: Merge a main 3-5 veces al día por developer, tests automatizados en cada merge"
        ],
        "phases": [
          {
            "id": "phase-xp-planning",
            "name": "Sprint Planning",
            "order": 1,
            "description": "Planning condensado de 2 horas (sprint de 1 semana es corto). Equipo selecciona user stories pequeñas (max 5 story points c/u) que caben en 5 días. Énfasis en simplicidad: YAGNI, no over-engineering.",
            "duration": "2 horas (lunes 9-11 AM)",
            "activities": [
              "Product Owner presenta top 5-8 user stories del backlog priorizadas por experimentos de producto a validar",
              "Equipo estima complejidad con Planning Poker (escala pequeña: 1, 2, 3, 5 - no stories >5 puntos para sprint de 1 semana)",
              "Seleccionar 10-15 story points de trabajo (velocity típica para equipo 5-8 personas, sprint 1 semana)",
              "Definir Sprint Goal enfocado en experimento: 'Validar que usuarios completan checkout en <3 clics' (hipótesis a probar)",
              "Descomponer stories en tareas técnicas con TDD explícito: Para cada feature, escribir tests primero (red-green-refactor)",
              "Identificar pairs para pair programming: Asignar duplas developer senior + junior para knowledge sharing",
              "Simple Design check: Asegurar que solución propuesta es la más simple posible (YAGNI, no agregar features 'por si acaso')",
              "Output: Sprint Backlog en tablero físico o digital (Trello, GitHub Projects) con tareas de testing explícitas"
            ],
            "inputs": [
              "Product Backlog con stories pequeñas (<5 puntos)",
              "Velocity de último sprint (10-15 puntos típico)",
              "Experimentos de producto fallidos/exitosos de sprint anterior (para priorización)"
            ],
            "outputs": [
              "Sprint Backlog con 10-15 story points",
              "Sprint Goal (hipótesis a validar)",
              "Pairs asignados para pair programming",
              "Lista de tests a escribir (TDD tasks)"
            ],
            "deliverables": [
              {
                "name": "Sprint Backlog (tablero Kanban)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Product Owner",
                  "Development Team"
                ]
              },
              {
                "name": "Sprint Goal (hipótesis de experimento)",
                "template": "tpl-009",
                "required": true,
                "reviewedBy": [
                  "Product Owner"
                ]
              }
            ],
            "gate": {
              "name": "Sprint Commitment",
              "criteria": [
                "Sprint Goal es experimento claro y medible (no vago como 'mejorar UX')",
                "Stories son pequeñas (max 5 puntos c/u, no stories grandes para sprint 1 semana)",
                "Pairs asignados con balance senior/junior (knowledge sharing)",
                "TDD tasks identificadas (tests a escribir antes de código)",
                "Simple Design verificado (no over-engineering detectado en planning)"
              ],
              "decision": "COMMIT / ADJUST SCOPE",
              "approvers": [
                "Product Owner",
                "Development Team"
              ]
            },
            "keyStakeholders": [
              "Product Owner",
              "Development Team (5-8 developers)",
              "Scrum Master (puede ser part-time)"
            ]
          },
          {
            "id": "phase-xp-daily-dev",
            "name": "Daily Development (TDD, Pair Programming, CI)",
            "order": 2,
            "description": "Fase de ejecución intensiva (5 días). TDD obligatorio para cada feature, pair programming 50% del tiempo con rotación diaria de pairs, CI agresivo (merge 3-5 veces/día). Daily standup de 10 min para sincronización rápida.",
            "duration": "5 días (lunes PM - viernes AM)",
            "activities": [
              "Daily Standup (10 min, 9:30 AM): ¿Qué hice? ¿Qué haré? ¿Impedimentos? (más rápido que Scrum estándar por equipo pequeño)",
              "Pair Programming rotación diaria: Lunes (Alice+Bob), Martes (Alice+Carlos), Miércoles (Bob+Carlos) - todos aprenden todo",
              "TDD cycle (red-green-refactor): (1) Write failing test (red), (2) Write minimal code to pass (green), (3) Refactor code + tests",
              "Continuous Integration agresivo: Merge a main 3-5 veces al día por developer, CI pipeline ejecuta tests en <5 min",
              "Refactoring continuo: Después de cada feature, refactorizar código para mantener simple design (no acumular deuda técnica)",
              "Collective Code Ownership: Cualquier developer puede modificar cualquier parte del código (no silos de ownership)",
              "Simple Design enforcement: Code reviews rechazan PRs con over-engineering (features no solicitadas, abstracciones innecesarias)",
              "On-site Customer (Product Owner): Disponible todo el día para clarificar acceptance criteria (no emails, respuesta inmediata)",
              "40-hour week (Sustainable Pace): No overtime sostenido - burnout previene velocity (XP value: fresh mind > horas extras)",
              "Coding Standards enforcement: Linter automatizado (ESLint, Prettier) asegura consistencia de código"
            ],
            "inputs": [
              "Sprint Backlog con TDD tasks",
              "Pairs asignados",
              "CI/CD pipeline configurado (GitHub Actions, tests <5 min)",
              "Product Owner disponible on-site o remote sync"
            ],
            "outputs": [
              "Código con >90% test coverage (TDD garantiza tests)",
              "Múltiples merges diarios a main (CI agresivo)",
              "Código refactorizado continuamente (mantiene simple design)",
              "Knowledge distribuido (pair programming rotado)"
            ],
            "deliverables": [
              {
                "name": "Working Software con TDD (>90% test coverage)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Development Team",
                  "CI/CD pipeline"
                ]
              },
              {
                "name": "Refactoring Log (mejoras de diseño continuas)",
                "template": null,
                "required": false,
                "reviewedBy": [
                  "Development Team"
                ]
              }
            ],
            "gate": {
              "name": "Daily Progress with Quality",
              "criteria": [
                "Test coverage >90% mantenido (TDD obligatorio, no código sin tests)",
                "CI pipeline pasando en cada merge (zero broken builds en main)",
                "Pair programming 50% del tiempo cumplido (tracking en standup)",
                "No overtime crónico (40-hour week, sustainable pace)",
                "Refactoring ejecutado (código no acumula deuda técnica)"
              ],
              "decision": "CONTINUE / ADJUST PRACTICES (si TDD no se cumple)",
              "approvers": [
                "Development Team",
                "Scrum Master"
              ]
            },
            "keyStakeholders": [
              "Development Team",
              "Product Owner (on-site customer)",
              "Scrum Master"
            ]
          },
          {
            "id": "phase-xp-review",
            "name": "Sprint Review",
            "order": 3,
            "description": "Review condensado de 1 hora (viernes PM). Demo de experimento de producto: ¿Hipótesis validada o refutada? Decisión de pivoting rápido si experimento falló. Stakeholders dan feedback para próximo sprint de 1 semana.",
            "duration": "1 hora (viernes 3-4 PM)",
            "activities": [
              "Recordar Sprint Goal (hipótesis): '¿Usuarios completan checkout en <3 clics?' - mostrar métricas",
              "Demo de incremento funcional: Mostrar feature implementada con TDD (código + tests pasando)",
              "Validar hipótesis con datos: Analytics de usuarios piloto (conversion rate, time-to-checkout, drop-off rate)",
              "Product Owner decide: Hipótesis validada (escalar feature) o refutada (pivotar en próximo sprint)",
              "Stakeholders dan feedback: UX improvements, nuevos experimentos a probar, features a deprecar si no se usan",
              "Actualizar Product Backlog: Agregar nuevas hipótesis a validar, re-priorizar basado en aprendizajes del sprint",
              "Revisar velocity: Story points completados (10-15 típico), ajustar estimaciones para próximo sprint si fue over/under-committed",
              "Decisión de release: ¿Incremento va a producción esta semana o esperamos próximo sprint? (startup speed permite releases semanales)"
            ],
            "inputs": [
              "Incremento funcional con TDD (tests pasando)",
              "Analytics de experimento (métricas de usuarios)",
              "Sprint Goal (hipótesis a validar)"
            ],
            "outputs": [
              "Hipótesis validada/refutada (decisión de pivoting)",
              "Product Backlog actualizado (nuevos experimentos)",
              "Velocity del sprint (story points completados)",
              "Decisión de release a producción (weekly release)"
            ],
            "deliverables": [
              {
                "name": "Sprint Review Report (hipótesis validada/refutada)",
                "template": "tpl-013",
                "required": true,
                "reviewedBy": [
                  "Product Owner",
                  "Stakeholders"
                ]
              },
              {
                "name": "Updated Product Backlog (nuevos experimentos)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Product Owner"
                ]
              }
            ],
            "gate": {
              "name": "Experiment Validation",
              "criteria": [
                "Hipótesis validada o refutada con datos (no opiniones subjetivas)",
                "Incremento cumple Definition of Done (TDD, code review, deployable)",
                "Velocity estable o mejorando (10-15 puntos típico)",
                "Decisión de pivoting tomada si experimento falló (no persistir en ideas fallidas)",
                "Product Backlog actualizado con aprendizajes del sprint"
              ],
              "decision": "ACCEPT INCREMENT / PIVOT (cambiar dirección de producto)",
              "approvers": [
                "Product Owner",
                "Stakeholders"
              ]
            },
            "keyStakeholders": [
              "Product Owner",
              "Development Team",
              "Stakeholders (founders, investors)",
              "Scrum Master"
            ]
          },
          {
            "id": "phase-xp-retrospective",
            "name": "Sprint Retrospective",
            "order": 4,
            "description": "Retrospective condensado de 45 min (viernes 4-4:45 PM). Mejora continua semanal de prácticas XP: ¿TDD funcionó? ¿Pair programming efectivo? ¿CI suficientemente rápido? Top 2 action items para próxima semana.",
            "duration": "45 min (viernes 4-4:45 PM)",
            "activities": [
              "What went well: Prácticas XP exitosas (ej: 'TDD previno 3 bugs que habrían llegado a producción', 'Pair programming aceleró onboarding de nuevo developer')",
              "What didn't go well: Problemas (ej: 'CI pipeline lento (10 min) bloqueó merges frecuentes', 'Pair programming 30% del tiempo solo, no 50%')",
              "XP practices check: Revisar cumplimiento de prácticas XP (TDD, pair programming, CI, refactoring, simple design, 40-hour week)",
              "Identificar top 2 action items: Enfocados en prácticas técnicas (ej: 'Optimizar CI a <5 min', 'Pair programming obligatorio 50% del tiempo con tracking')",
              "Sustainable Pace check: ¿Equipo trabajó >40h/semana? Si sí, ¿por qué? (over-commitment crónico lleva a burnout)",
              "Knowledge sharing assessment: ¿Pair programming distribuyó conocimiento? ¿Hay silos de expertise que necesitan romperse?",
              "Close retrospective: Scrum Master resume action items, asigna owners, trackea para próxima retro semanal"
            ],
            "inputs": [
              "Sprint metrics (velocity, test coverage, CI time, pair programming %)",
              "Código refactorizado o deuda técnica acumulada",
              "Feedback de team sobre prácticas XP"
            ],
            "outputs": [
              "Top 2 action items con owner y deadline (1 semana)",
              "XP practices compliance report (TDD, pair programming, CI cumplidos?)",
              "Retrospective summary (mantener prácticas exitosas)"
            ],
            "deliverables": [
              {
                "name": "Retrospective Action Items (top 2)",
                "template": "tpl-012",
                "required": true,
                "reviewedBy": [
                  "Scrum Master",
                  "Development Team"
                ]
              },
              {
                "name": "XP Practices Compliance Report",
                "template": "tpl-012",
                "required": false,
                "reviewedBy": [
                  "Scrum Master"
                ]
              }
            ],
            "gate": {
              "name": "XP Practices Improvement",
              "criteria": [
                "Top 2 action items definidos (enfocados en prácticas técnicas XP)",
                "Action items son SMART y alcanzables en 1 semana",
                "Sustainable Pace mantenido (no overtime crónico)",
                "XP practices cumplidas >80% del tiempo (TDD, pair programming, CI)",
                "Knowledge sharing funcionando (pair programming rotado)"
              ],
              "decision": "COMMIT TO IMPROVEMENTS",
              "approvers": [
                "Development Team",
                "Scrum Master"
              ]
            },
            "keyStakeholders": [
              "Development Team",
              "Scrum Master"
            ]
          }
        ],
        "iterationStrategy": "Sprints de 1 semana (lunes-viernes) para máxima velocidad y adaptación. Velocity típica 10-15 story points/semana para equipo 5-8 personas. TDD obligatorio (write test → fail → code → pass → refactor). Pair programming 50% del tiempo con rotación diaria de pairs para knowledge sharing. CI agresivo: Merge a main 3-5 veces/día por developer, tests automatizados <5 min. Refactoring continuo post-feature para mantener simple design. Product Backlog refinement ad-hoc (Product Owner disponible on-site para clarificaciones inmediatas).",
        "whenToUse": [
          "Startup en fase de product-market fit (necesidad de experimentar rápido, pivotar semanalmente)",
          "Equipo pequeño (5-8 personas) todos generalistas (no silos de especialización)",
          "Necesidad de velocidad extrema (weekly releases, competencia agresiva, time-to-market crítico)",
          "Calidad técnica crítica desde el inicio (no budget para re-escribir después, TDD previene deuda técnica)",
          "Product Owner disponible full-time (on-site customer, respuestas inmediatas a clarificaciones)",
          "Equipo valora prácticas técnicas (desarrolladores quieren aprender TDD, pair programming, no lo ven como overhead)",
          "Sistema web/móvil sin integraciones legacy complejas (TDD y CI funcionan mejor con código nuevo)",
          "Cultura de fail-fast (stakeholders toleran experimentos fallidos, pivoting frecuente)",
          "Budget limitado (equipos pequeños son más baratos, XP maximiza productividad de pocos developers)",
          "Onboarding frecuente (pair programming acelera onboarding de nuevos developers en equipo pequeño)"
        ],
        "whenNotToUse": [
          "Equipo grande (>10 personas) - pair programming y sprints 1 semana no escalan bien",
          "Requisitos estables y conocidos (overhead de TDD y pair programming no justifica si no hay cambios)",
          "Product Owner no disponible full-time (XP requiere on-site customer para clarificaciones inmediatas)",
          "Equipo sin experiencia en XP (TDD, pair programming tienen curva de aprendizaje >1 mes)",
          "Sistema legacy complejo (TDD difícil de aplicar en código legacy sin tests, refactoring arriesgado)",
          "Cultura de cowboy coding (desarrolladores rechazan pair programming como 'micro-management')",
          "Regulaciones requieren documentación exhaustiva (XP genera poco documentation, código + tests son la documentación)",
          "Sprints 1 semana causan burnout (equipo no puede sostener ritmo intensivo, necesita sprints 2 semanas)",
          "Stakeholders no toleran pivoting (contratos de scope fijo, no permiten cambios semanales)",
          "Infraestructura lenta (CI >10 min hace merge 3-5 veces/día impráctico, necesitan optimizar primero)"
        ],
        "advantages": [
          "Velocidad máxima: Sprints 1 semana + CI agresivo permiten weekly releases (time-to-market imbatible)",
          "Calidad técnica alta: TDD obligatorio asegura >90% test coverage, previene bugs en producción",
          "Knowledge sharing: Pair programming rotado distribuye expertise, elimina silos de conocimiento (bus factor bajo)",
          "Fail-fast culture: Experimentos semanales permiten pivotar rápido si hipótesis fallan (no persisten en ideas fallidas)",
          "Refactoring continuo: Código mantiene simple design, no acumula deuda técnica en crecimiento rápido",
          "Onboarding rápido: Pair programming acelera ramp-up de nuevos developers (aprenden de seniors on-the-job)",
          "CI detecta bugs temprano: Merge 3-5 veces/día con tests automatizados previene integration hell",
          "Sustainable Pace: 40-hour week previene burnout (equipo fresco > overtime cansado)",
          "Product Owner empowered: On-site customer permite decisiones rápidas sin esperar aprobaciones lentas",
          "Simple Design: YAGNI evita over-engineering (no construyen features 'por si acaso' que nunca se usan)"
        ],
        "disadvantages": [
          "Pair programming 50% más lento: 2 developers, 1 tarea (pero compensa con menos bugs y knowledge sharing)",
          "TDD requiere disciplina: Escribir tests primero es anti-intuitivo, curva de aprendizaje >1 mes",
          "Sprints 1 semana pueden causar burnout: Ritmo intensivo no sostenible long-term (algunos equipos necesitan 2 semanas)",
          "Requiere Product Owner full-time: Si PO no disponible, equipo se bloquea esperando clarificaciones (costoso)",
          "CI agresivo requiere infra rápida: Tests deben ejecutar <5 min o merge 3-5 veces/día se vuelve impráctico",
          "Poco documentation generado: Código + tests son la documentación (problemas con compliance/auditorías)",
          "Collective Ownership puede causar caos: Sin dueños claros, código puede degradarse si todos modifican sin cuidado",
          "Difícil de escalar: Prácticas XP (TDD, pair programming) funcionan bien con 5-8 personas, no con 20+",
          "Stakeholders impacientes: Weekly releases pueden generar expectativa de features grandes cada semana (irreal)",
          "Refactoring continuo puede sobre-optimizar: Riesgo de refactorizar código que cambiará radicalmente en próximo pivot"
        ],
        "changeManagement": {
          "description": "Gestión de cambios ultra-flexible para startups: pivoting semanal permitido, scope freeze mid-sprint mínimo.",
          "steps": [
            {
              "step": 1,
              "name": "Weekly Pivoting Allowed",
              "description": "Sprint de 1 semana permite cambios drásticos de dirección semanalmente. Si experimento del sprint falla, Product Owner puede pivotar completamente en próximo sprint planning (no esperan 2-4 semanas como Scrum estándar)."
            },
            {
              "step": 2,
              "name": "Mid-Sprint Changes Minimizados",
              "description": "Sprints cortos (1 semana) hacen scope freeze mid-sprint menos crítico. Si cambio urgente surge, equipo puede absorberlo porque sprint termina en días (no weeks). No necesitan proceso formal de swap como Scrum 2 semanas."
            },
            {
              "step": 3,
              "name": "Continuous Refactoring Enables Change",
              "description": "Refactoring continuo mantiene código flexible. Cuando pivoting ocurre, código simple y bien testeado (TDD) facilita cambios drásticos sin romper sistema (deuda técnica baja)."
            },
            {
              "step": 4,
              "name": "On-Site Customer Immediate Clarifications",
              "description": "Product Owner disponible full-time resuelve ambigüedades de acceptance criteria en minutos (no días). Equipo no se bloquea esperando respuestas por email."
            },
            {
              "step": 5,
              "name": "Experiment-Driven Backlog",
              "description": "Product Backlog organizado por hipótesis a validar (no features fijas). Si hipótesis refutada, backlog se re-prioriza radicalmente basado en aprendizajes. Flexibilidad total de alcance."
            }
          ]
        },
        "tooling": [
          {
            "category": "Sprint Management",
            "tools": [
              "Trello (lightweight, ideal para equipos pequeños 5-8 personas)",
              "GitHub Projects (integración directa con repos, kanban board)",
              "Linear (moderna, rápida, enfocada en startups)"
            ]
          },
          {
            "category": "TDD & Testing",
            "tools": [
              "Jest (JavaScript TDD framework, fast test execution)",
              "Pytest (Python TDD framework con fixtures potentes)",
              "RSpec (Ruby TDD framework con sintaxis expresiva)",
              "Coverage.py, Istanbul (test coverage tracking >90%)"
            ]
          },
          {
            "category": "Pair Programming",
            "tools": [
              "VS Code Live Share (pair programming remoto en tiempo real)",
              "Tuple, Pop (pair programming tools con baja latencia)",
              "tmux + vim (pair programming en terminal para equipos técnicos)"
            ]
          },
          {
            "category": "CI/CD",
            "tools": [
              "GitHub Actions (CI/CD integrado, <5 min builds)",
              "CircleCI (optimizado para velocidad, paralelización de tests)",
              "Vercel, Netlify (deploy automático en cada merge, preview deploys)"
            ]
          },
          {
            "category": "Communication",
            "tools": [
              "Slack (async communication, CI/CD notifications)",
              "Zoom (daily standup remoto 10 min, sprint ceremonies)",
              "Miro (retrospective boards, sprint planning virtual)"
            ]
          }
        ],
        "references": [
          {
            "title": "Software Engineering (10th Edition) - Chapter 3: Agile Software Development",
            "author": "Ian Sommerville",
            "year": 2015,
            "source": "Pearson"
          },
          {
            "title": "Extreme Programming Explained: Embrace Change (2nd Edition)",
            "author": "Kent Beck",
            "year": 2004,
            "source": "Addison-Wesley"
          },
          {
            "title": "Test Driven Development: By Example",
            "author": "Kent Beck",
            "year": 2002,
            "source": "Addison-Wesley"
          },
          {
            "title": "The Scrum Guide (2020)",
            "author": "Ken Schwaber, Jeff Sutherland",
            "year": 2020,
            "source": "Scrum.org"
          }
        ]
      },
      "methodology": {
        "name": "Scrum Framework",
        "description": "Framework ágil ligero (lightweight) para desarrollo iterativo incremental basado en sprints time-boxed de duración fija (típicamente 1-4 semanas, recomendado 2 semanas). Enfocado en auto-organización del equipo (self-organizing teams), entregas frecuentes de incrementos funcionales potencialmente desplegables (potentially shippable increments) y adaptación continua basada en feedback de stakeholders y retrospectivas. Scrum define una estructura mínima de 3 roles (Product Owner, Scrum Master, Development Team), 4 ceremonias obligatorias (Sprint Planning, Daily Standup, Sprint Review, Sprint Retrospective) y 3 artefactos (Product Backlog, Sprint Backlog, Increment). Scrum es deliberadamente incompleto: no prescribe prácticas técnicas (testing, CI/CD, arquitectura), permitiendo que equipos las definan. Se basa en empirismo (transparencia, inspección, adaptación) y promueve mejora continua mediante retrospectivas regulares.",
        "origin": {
          "creator": "Ken Schwaber y Jeff Sutherland",
          "year": 1995,
          "context": "Presentado formalmente en OOPSLA 1995 (Object-Oriented Programming, Systems, Languages & Applications). Inspirado en el paper 'The New New Product Development Game' (Takeuchi & Nonaka, Harvard Business Review, 1986) que analizaba equipos de desarrollo de producto en Toyota, Honda y Canon. La Scrum Guide oficial fue publicada en 2010 y es actualizada periódicamente por Schwaber y Sutherland. Desarrollado inicialmente para equipos pequeños (5-9 personas) que necesitaban adaptarse rápidamente a cambios de requisitos en entornos de alta incertidumbre."
        },
        "principles": [
          "Empirismo (empirical process control): transparencia (todos ven el trabajo), inspección (revisar progreso frecuentemente), adaptación (ajustar proceso/producto basado en feedback)",
          "Auto-organización del equipo (self-organizing): Development Team decide cómo hacer el trabajo técnico, sin micro-gestión externa",
          "Sprints time-boxed de duración fija con entrega de incremento funcional potencialmente desplegable al final de cada sprint",
          "Product Owner prioriza Product Backlog basado en valor de negocio (ROI, riesgos, dependencias), no en detalles técnicos",
          "Daily Standup de 15 minutos para sincronización rápida del equipo (¿qué hice ayer? ¿qué haré hoy? ¿impedimentos?)",
          "Sprint Retrospective obligatoria al final de cada sprint para inspección del proceso y mejora continua (Kaizen)",
          "Working software como medida principal de progreso (no documentación ni % de tareas completadas)"
        ],
        "differentiators": [
          "vs XP: Scrum define estructura de proceso (ceremonias, roles, artefactos) pero NO prescribe prácticas técnicas, mientras XP prescribe 12 prácticas técnicas obligatorias (TDD, pair programming, CI, etc.)",
          "vs Kanban: Scrum usa sprints time-boxed con planning/review/retro al inicio/final de cada sprint, mientras Kanban es flujo continuo (continuous flow) sin time-boxes ni ceremonias obligatorias",
          "vs Waterfall: Scrum es iterativo con entregas incrementales frecuentes (cada 1-4 semanas), mientras Waterfall es secuencial con entrega única al final del proyecto (big-bang)"
        ],
        "references": {
          "chapter": "chapter-3",
          "sections": [
            "3.2 Agile development techniques",
            "3.3 Agile project management"
          ],
          "externalResources": [
            "Schwaber, K., & Sutherland, J. (2020). The Scrum Guide. https://scrumguides.org",
            "Sutherland, J. (2014). Scrum: The Art of Doing Twice the Work in Half the Time. Crown Business",
            "Takeuchi, H., & Nonaka, I. (1986). The New New Product Development Game. Harvard Business Review"
          ]
        }
      },
      "modeling": {
        "notations": [
          {
            "name": "User Story Mapping",
            "description": "Técnica ágil para organizar user stories en épicas y sprints.",
            "diagrams": [
              "User Story Map (horizontal: flujo usuario, vertical: prioridad)"
            ],
            "whenToUse": "Scrum Product Backlog refinement (organizar stories en sprints)",
            "tools": [
              "Miro",
              "Mural",
              "StoriesOnBoard",
              "Jira"
            ]
          },
          {
            "name": "UML ligero",
            "description": "Documentación técnica ligera (no exhaustiva como RUP). Solo diagramas críticos.",
            "diagrams": [
              "Class Diagram (diseño básico)",
              "Sequence Diagram (flujos críticos)",
              "Component Diagram (arquitectura)"
            ],
            "whenToUse": "Scrum teams documentan arquitectura high-level sin detalles exhaustivos",
            "tools": [
              "Lucidchart",
              "Draw.io",
              "Mermaid (markdown-based)",
              "PlantUML"
            ]
          },
          {
            "name": "C4 Model",
            "description": "Modelo de 4 niveles (Context, Container, Component, Code) para documentar arquitectura moderna.",
            "diagrams": [
              "C4 Context Diagram (sistema + actores)",
              "C4 Container Diagram (apps, DBs, message brokers)"
            ],
            "whenToUse": "Scrum teams documentan arquitectura high-level con C4 (Context, Container) sin detalles exhaustivos",
            "tools": [
              "Structurizr",
              "Draw.io",
              "Mermaid",
              "C4-PlantUML"
            ]
          }
        ],
        "primaryFocus": "Modelado ligero centrado en user stories y arquitectura high-level (no documentación exhaustiva)",
        "references": {
          "chapter": "chapter-3",
          "sections": [
            "3.2 Agile development techniques"
          ]
        }
      },
      "architecture": {
        "patterns": [
          {
            "name": "Microservices (lightweight)",
            "description": "Pocos microservicios (3-5) enfocados en dominios de negocio clave, no full microservices architecture.",
            "advantages": [
              "Deployment independiente de servicios clave (API, Workers, Admin)",
              "Escalamiento diferenciado (escalar API sin escalar Admin)",
              "Tecnologías diferentes por servicio (Node.js API, Python ML)",
              "Resiliencia parcial (fallo de Admin no afecta API pública)"
            ],
            "disadvantages": [
              "Complejidad operacional vs monolito",
              "Network latency entre servicios",
              "Distributed transactions (eventual consistency)"
            ],
            "whenToUse": "Startups (rec-006: 5-8 personas) con necesidad de deployment ágil y escalamiento diferenciado",
            "tradeoffs": "Deployment ágil vs Complejidad operacional"
          },
          {
            "name": "BFF (Backend for Frontend)",
            "description": "Backend específico para cada frontend (Web BFF, Mobile BFF) que agrega datos de servicios backend.",
            "advantages": [
              "Optimización por frontend (payloads específicos para web vs móvil)",
              "Evolución independiente de cada BFF",
              "Reduce acoplamiento entre frontend y backend"
            ],
            "disadvantages": [
              "Duplicación de lógica si no se gestiona bien",
              "Más servicios para mantener"
            ],
            "whenToUse": "Apps con web y móvil con necesidades diferentes (ej: móvil requiere payloads pequeños)",
            "tradeoffs": "Optimización por frontend vs Duplicación de lógica"
          }
        ],
        "style": "Microservices ligeros (3-5 servicios), BFF pattern",
        "qualityAttributes": {
          "scalability": "High - Microservices permiten escalamiento horizontal independiente. Cloud auto-scaling.",
          "maintainability": "High - Sprints de 1 semana + TDD + pair programming garantizan código limpio. Refactoring continuo.",
          "performance": "High - Deployment ágil permite optimizaciones rápidas. CI/CD con tests de performance.",
          "security": "High - OAuth2 para autenticación. TLS everywhere. Security tests automatizados en CI."
        },
        "references": {
          "chapter": "chapter-6",
          "sections": [
            "6.3 Application architectures",
            "6.4 Architectural patterns"
          ]
        }
      },
      "timeline": [
        {
          "week": "1",
          "phase": "Definición de MVP",
          "tasks": [
            "Identificar problema core",
            "Definir 3-5 features esenciales",
            "Wireframes básicos",
            "Setup técnico"
          ]
        },
        {
          "week": "2-4",
          "phase": "Desarrollo MVP",
          "tasks": [
            "Autenticación básica",
            "Feature core implementada",
            "UI funcional (no perfecta)",
            "Deploy a staging"
          ]
        },
        {
          "week": "5-6",
          "phase": "Beta Testing",
          "tasks": [
            "Onboarding de beta users",
            "Recolección de feedback",
            "Bug fixes críticos",
            "Iteración rápida"
          ]
        },
        {
          "week": "7-8",
          "phase": "Launch v1.0",
          "tasks": [
            "Polish de UI",
            "Documentación de usuario",
            "Launch público",
            "Marketing inicial"
          ]
        },
        {
          "week": "9+",
          "phase": "Iteración Continua",
          "tasks": [
            "Features según feedback de usuarios",
            "Optimización de conversión",
            "Escalabilidad según crecimiento"
          ]
        }
      ],
      "avoid": [
        "Sobre-ingeniería (YAGNI!)",
        "Perfeccionismo en v1.0",
        "No validar con usuarios reales",
        "Features que no resuelven el problema core",
        "Escalar prematuramente",
        "No medir métricas clave"
      ],
      "templates": [
        "tpl-004",
        "tpl-005",
        "tpl-008"
      ],
      "chapters": [
        2,
        3,
        5,
        6
      ]
    },
    "rec-007": {
      "id": "rec-007",
      "title": "Web/SaaS → Escalando",
      "path": [
        "Web/SaaS",
        "Escalando"
      ],
      "pathDescription": "Sistema Web/SaaS → Producto Establecido en Crecimiento",
      "process": {
        "name": "Scaled Scrum (SAFe/LeSS)",
        "type": "agile-scaled",
        "chapter": 3,
        "description": "Framework ágil escalado para múltiples equipos Scrum (3-5 equipos, 20-40 personas) trabajando en mismo producto. Combina ceremonias estándar de Scrum con ceremonias adicionales de coordinación: Scrum of Scrums (SoS), Product Owner Sync, System Demo, PI Planning. Basado en SAFe (Scaled Agile Framework) o LeSS (Large-Scale Scrum) para sincronización multi-equipo.",
        "why": [
          "Múltiples equipos trabajando en paralelo maximizan throughput (más personas = más features simultáneas)",
          "Ceremonias de sincronización (SoS, PO Sync) previenen conflictos entre equipos y dependencias bloqueantes",
          "Sprints sincronizados (todos inician lunes) facilitan integration testing y system demos coordinados",
          "PI Planning cada 10 semanas alinea roadmap de todos los equipos con objetivos estratégicos de negocio",
          "System Demo end-to-end valida que subsistemas desarrollados por equipos independientes se integran correctamente"
        ],
        "how": [
          "3-5 equipos Scrum (cada uno 6-9 personas) con sprints sincronizados de 2 semanas (todos inician/terminan mismo día)",
          "Ceremonias estándar por equipo: Planning, Daily Standup, Review, Retrospective",
          "Ceremonias de escalamiento: Scrum of Scrums 3x/semana (representantes de equipos), PO Sync semanal, System Demo fin de sprint",
          "PI Planning cada 10 semanas: Planning de alto nivel para 5 sprints futuros con todos los equipos (2 días presencial)",
          "Integration testing continuo: CI/CD ejecuta integration tests cross-subsystem después de cada merge"
        ],
        "phases": [
          {
            "id": "phase-scaled-planning",
            "name": "Sprint Planning (Multi-Team Synchronized)",
            "order": 1,
            "description": "Sprint Planning sincronizado donde 3-5 equipos planifican sprints de 2 semanas en paralelo. Coordinación de dependencias cross-team crítica. Objetivo: Cada equipo tiene Sprint Backlog alineado con objetivos globales del PI (Program Increment).",
            "duration": "4 horas por equipo (todos ejecutan planning simultáneamente)",
            "activities": [
              "Chief Product Owner presenta objetivos del sprint alineados con PI roadmap (qué features son prioridad global esta iteración)",
              "Product Owners de cada equipo presentan top stories de su backlog a sus respectivos equipos",
              "Equipos identifican dependencias cross-team: Equipo A necesita API de Equipo B, Equipo C depende de feature de Equipo D",
              "Dependency board actualizado: Visualizar dependencias críticas entre equipos (impedimentos potenciales)",
              "Scrum of Scrums pre-planning (30 min): Representantes de equipos coordinan secuencia de trabajo (Equipo B debe completar API en día 3 para que A pueda integrar)",
              "Cada equipo selecciona stories considerando dependencies: Si dependen de otro equipo, asumen riesgo de bloqueo",
              "Definir Sprint Goals por equipo alineados con objetivo global del PI (ej: PI Goal 'Lanzar checkout v2', Sprint Goals de equipos contribuyen a esto)",
              "Integration testing plan: Definir qué equipos ejecutarán integration tests cross-subsystem al final del sprint",
              "Output: Sprint Backlogs de 3-5 equipos sincronizados, dependency board actualizado"
            ],
            "inputs": [
              "PI roadmap (objetivos de Program Increment para próximos 5 sprints)",
              "Product Backlogs de cada equipo (priorizados por POs)",
              "Dependency board (dependencias conocidas entre equipos)",
              "Velocity promedio por equipo (20-30 puntos típico por equipo 6-9 personas)"
            ],
            "outputs": [
              "Sprint Backlogs de 3-5 equipos (60-150 story points total si 3-5 equipos)",
              "Sprint Goals por equipo alineados con PI roadmap",
              "Dependency board actualizado (riesgos de bloqueo identificados)",
              "Integration testing plan (qué equipos integran qué subsistemas)"
            ],
            "deliverables": [
              {
                "name": "Multi-Team Sprint Backlogs (3-5 tableros Kanban)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Product Owners",
                  "Chief Product Owner"
                ]
              },
              {
                "name": "Dependency Board (dependencias cross-team)",
                "template": "tpl-011",
                "required": true,
                "reviewedBy": [
                  "Release Train Engineer",
                  "Scrum Masters"
                ]
              },
              {
                "name": "Sprint Goals (por equipo, alineados con PI)",
                "template": "tpl-009",
                "required": true,
                "reviewedBy": [
                  "Chief Product Owner"
                ]
              }
            ],
            "gate": {
              "name": "Multi-Team Sprint Commitment",
              "criteria": [
                "Sprint Goals de equipos alineados con objetivos del PI (no equipos trabajando en direcciones divergentes)",
                "Dependencias críticas identificadas y mitigadas (Equipo B comprometido a entregar API en día 3)",
                "Velocity total de equipos balanceado (no un equipo over-committed y otros con capacity sobrante)",
                "Integration testing plan acordado (equipos saben cuándo y cómo integrarán)",
                "Chief Product Owner aprueba alineación de sprints con roadmap estratégico"
              ],
              "decision": "COMMIT / ADJUST DEPENDENCIES / RE-BALANCE WORK",
              "approvers": [
                "Chief Product Owner",
                "Product Owners (3-5)",
                "Release Train Engineer"
              ]
            },
            "keyStakeholders": [
              "Chief Product Owner",
              "Product Owners (1 por equipo)",
              "Scrum Masters (1 por equipo)",
              "Release Train Engineer",
              "Development Teams (3-5 equipos)"
            ]
          },
          {
            "id": "phase-scaled-daily-dev",
            "name": "Daily Development (with Scrum of Scrums)",
            "order": 2,
            "description": "Ejecución de sprint con desarrollo paralelo de 3-5 equipos. Daily Standups dentro de cada equipo + Scrum of Scrums (SoS) 3x/semana entre representantes de equipos para sincronización cross-team. Objetivo: Maximizar paralelismo sin conflictos de integración.",
            "duration": "10 días hábiles (2 semanas)",
            "activities": [
              "Daily Standup por equipo (15 min, 9:00 AM): Cada equipo ejecuta standup estándar internamente",
              "Scrum of Scrums (SoS) 3x/semana (lunes/miércoles/viernes, 9:30 AM, 30 min): 1 representante por equipo (tech lead o scrum master) sincroniza",
              "SoS agenda: (1) Progreso de cada equipo, (2) Dependencies resueltas o bloqueadas, (3) Integration issues encontrados, (4) Coordinación de próximos 2 días",
              "Desarrollo paralelo: Equipos trabajan independientemente en sus subsistemas (Equipo A: frontend, B: backend API, C: data pipeline, D: admin panel)",
              "Integration testing continuo: CI/CD ejecuta integration tests cross-subsystem después de cada merge (validar que cambio en A no rompe B)",
              "Product Owner Sync semanal (miércoles, 1h): POs de equipos + Chief PO sincronizan prioridades, ajustan backlogs si dependencias cambiaron",
              "Dependency escalation: Si Equipo A bloqueado porque Equipo B no entregó API, Release Train Engineer escala y re-prioriza trabajo de B",
              "Code reviews cross-team (opcional): Developers de diferentes equipos revisan PRs que afectan interfaces compartidas (APIs, message schemas)",
              "Continuous Integration agresivo: Merge frequency balanceada (no todos los equipos mergen simultáneamente para evitar integration conflicts)",
              "Monitoring de dependency board: Release Train Engineer trackea dependencias críticas, alerta si bloqueos no se resuelven en 24h"
            ],
            "inputs": [
              "Sprint Backlogs de 3-5 equipos",
              "Dependency board (dependencias críticas trackeadas)",
              "Integration testing suite (tests cross-subsystem automatizados)",
              "Product Owner Sync agenda (prioridades a discutir)"
            ],
            "outputs": [
              "Código de 3-5 subsistemas desarrollados en paralelo",
              "Integration tests pasando (subsistemas se comunican correctamente)",
              "Dependency board actualizado (dependencias resueltas o escaladas)",
              "Burndown charts de 3-5 equipos (progreso individual + agregado)"
            ],
            "deliverables": [
              {
                "name": "Multi-Subsystem Code (3-5 repos, merges coordinados)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Development Teams",
                  "Release Train Engineer"
                ]
              },
              {
                "name": "Integration Test Suite (cross-subsystem tests pasando)",
                "template": "tpl-013",
                "required": true,
                "reviewedBy": [
                  "Integration Testing Team",
                  "QA Lead"
                ]
              },
              {
                "name": "Dependency Board Updated (bloqueos resueltos)",
                "template": "tpl-011",
                "required": true,
                "reviewedBy": [
                  "Release Train Engineer"
                ]
              }
            ],
            "gate": {
              "name": "Multi-Team Progress Check",
              "criteria": [
                "Scrum of Scrums ejecutado 3x/semana (sincronización continua, no esperan fin de sprint)",
                "Dependency board sin bloqueos críticos activos >48h (escalaciones funcionando)",
                "Integration tests pasando >90% (subsistemas compatibles, no integration hell)",
                "Product Owner Sync semanal ejecutado (POs alineados en prioridades)",
                "Burndown charts agregados trending hacia zero (todos los equipos en track)"
              ],
              "decision": "CONTINUE / ESCALATE BLOCKERS / ADJUST TEAM PRIORITIES",
              "approvers": [
                "Release Train Engineer",
                "Scrum Masters (3-5)",
                "Chief Product Owner"
              ]
            },
            "keyStakeholders": [
              "Development Teams (3-5 equipos)",
              "Scrum Masters (coordinación SoS)",
              "Product Owners (sync semanal)",
              "Release Train Engineer",
              "Integration Testing Team"
            ]
          },
          {
            "id": "phase-scaled-system-demo",
            "name": "System Demo (Multi-Team Integrated Review)",
            "order": 3,
            "description": "Demo integrada del sistema completo (subsistemas de 3-5 equipos funcionando juntos). Reemplaza Sprint Reviews individuales por equipo con System Demo unificado. Stakeholders ven producto end-to-end, no features aisladas. Objetivo: Validar integración cross-team exitosa.",
            "duration": "2 horas (viernes PM, todas las teams demuestran conjuntamente)",
            "activities": [
              "Chief Product Owner presenta objetivos del sprint alcanzados a nivel de sistema (no individual por equipo)",
              "Demo end-to-end: Flujo de usuario completo que atraviesa múltiples subsistemas (Equipo A frontend → B backend → C data pipeline → D admin panel)",
              "Cada equipo demuestra su contribución en contexto del flujo end-to-end (no demos aisladas)",
              "Integration testing live demo: Ejecutar integration tests en vivo para mostrar que subsistemas se comunican correctamente",
              "Stakeholders validan funcionalidad integrada: ¿El sistema completo cumple expectativas? ¿Bugs encontrados en integración?",
              "Product Owners aceptan/rechazan stories por equipo basado en integración exitosa (story de Equipo A no acepta si rompe integración con B)",
              "Feedback de stakeholders para próximo sprint: Prioridades ajustadas, nuevas features solicitadas, bugs críticos a fixear",
              "Actualizar Product Backlogs: Chief PO y POs de equipos re-priorizan basado en feedback de System Demo",
              "Decisión de release: ¿Sistema integrado va a producción este sprint o esperamos próximo? (releases cada 2-4 sprints típico en scaled scrum)",
              "Revisar métricas agregadas: Velocity total de equipos (80-150 story points típico para 3-5 equipos), bugs reportados cross-subsystem, integration issues"
            ],
            "inputs": [
              "Sistema integrado en staging (subsistemas de 3-5 equipos desplegados juntos)",
              "Integration tests pasando (validación cross-subsystem)",
              "Sprint Goals de equipos (para validar cumplimiento global)",
              "Stakeholders (usuarios finales, management, product team)"
            ],
            "outputs": [
              "Sistema integrado aceptado/rechazado por stakeholders",
              "Product Backlogs actualizados (prioridades ajustadas post-demo)",
              "Velocity agregada del sprint (story points completados por todos los equipos)",
              "Decisión de release a producción (go/no-go)",
              "Integration issues identificados (bugs cross-subsystem a fixear)"
            ],
            "deliverables": [
              {
                "name": "System Demo Report (aceptación de sistema integrado)",
                "template": "tpl-013",
                "required": true,
                "reviewedBy": [
                  "Chief Product Owner",
                  "Stakeholders"
                ]
              },
              {
                "name": "Updated Product Backlogs (3-5 backlogs actualizados)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Product Owners",
                  "Chief Product Owner"
                ]
              },
              {
                "name": "Aggregated Velocity Metrics (story points totales)",
                "template": "tpl-013",
                "required": true,
                "reviewedBy": [
                  "Release Train Engineer"
                ]
              }
            ],
            "gate": {
              "name": "Integrated System Acceptance",
              "criteria": [
                "Sistema integrado funciona end-to-end (flujo completo de usuario atraviesa subsistemas exitosamente)",
                "Integration tests pasando >95% (subsistemas compatibles)",
                "Al menos 75% de stories de todos los equipos aceptadas (no todos los equipos deben llegar a 100%, pero mayoría sí)",
                "Zero bugs críticos de integración (bugs menores aceptables)",
                "Stakeholders satisfechos con progreso integrado (feedback positivo mayormente)",
                "Velocity agregada estable o mejorando sprint a sprint"
              ],
              "decision": "ACCEPT INTEGRATED SYSTEM / PARTIAL ACCEPT / REJECT (si integration muy rota)",
              "approvers": [
                "Chief Product Owner",
                "Stakeholders",
                "Product Owners (3-5)"
              ]
            },
            "keyStakeholders": [
              "Chief Product Owner",
              "Product Owners (3-5)",
              "Development Teams (3-5)",
              "Stakeholders (management, users)",
              "Release Train Engineer"
            ]
          },
          {
            "id": "phase-scaled-retrospective",
            "name": "Multi-Level Retrospectives (Team + Cross-Team)",
            "order": 4,
            "description": "Retrospectives en 2 niveles: (1) Retrospectives individuales por equipo (1h), (2) Cross-Team Retrospective con representantes de equipos (1.5h). Objetivo: Mejorar procesos internos de equipos Y procesos de coordinación cross-team.",
            "duration": "1h por equipo + 1.5h cross-team (viernes PM)",
            "activities": [
              "Level 1 - Team Retrospectives (1h por equipo, paralelo): Cada equipo ejecuta retrospective estándar internamente (what went well, didn't, action items)",
              "Team retros enfocados en: Prácticas técnicas del equipo, velocity, collaboration interna, impedimentos específicos del equipo",
              "Level 2 - Cross-Team Retrospective (1.5h, representantes): 1 representante por equipo + Release Train Engineer + Chief PO discuten coordinación",
              "Cross-team retro agenda: (1) Dependency management (bloquearon equipos entre sí?), (2) Scrum of Scrums efectividad, (3) Integration testing issues, (4) Communication bottlenecks",
              "Identificar systemic issues: Problemas que afectan múltiples equipos (ej: CI pipeline lento afecta a todos, dependency board confuso, PO Sync no útil)",
              "Top 3 action items cross-team: Mejoras en procesos de coordinación (ej: 'Automatizar dependency tracking en Jira', 'SoS reducir a 2x/semana si no hay blockers')",
              "Top 2 action items por equipo: Mejoras internas de cada equipo (ej: 'Reducir tiempo de code review a <4h', 'Pair programming 1x/semana para knowledge sharing')",
              "Tracking de action items previos: Revisar si mejoras de retrospectiva anterior (team + cross-team) se implementaron (accountability)",
              "Close retrospectives: Release Train Engineer resume action items cross-team, Scrum Masters resumen action items de sus equipos, trackean para próxima retro"
            ],
            "inputs": [
              "Sprint metrics por equipo (velocity, burndown, cycle time)",
              "Aggregated metrics (velocity total, integration test pass rate, dependency resolution time)",
              "Feedback de Scrum of Scrums (bloquearon teams?)",
              "Feedback de System Demo (integration issues)"
            ],
            "outputs": [
              "Top 2 action items por equipo (6-10 action items totales si 3-5 equipos)",
              "Top 3 action items cross-team (coordinación, dependencies, integration)",
              "Retrospective summaries (por equipo + cross-team)",
              "Action items board actualizado (tracking de mejoras team + cross-team)"
            ],
            "deliverables": [
              {
                "name": "Team Retrospective Action Items (2 por equipo)",
                "template": "tpl-012",
                "required": true,
                "reviewedBy": [
                  "Scrum Masters",
                  "Development Teams"
                ]
              },
              {
                "name": "Cross-Team Retrospective Action Items (top 3)",
                "template": "tpl-012",
                "required": true,
                "reviewedBy": [
                  "Release Train Engineer",
                  "Chief Product Owner"
                ]
              },
              {
                "name": "Retrospective Summaries (team + cross-team)",
                "template": "tpl-012",
                "required": false,
                "reviewedBy": [
                  "Release Train Engineer"
                ]
              }
            ],
            "gate": {
              "name": "Multi-Level Improvement Commitment",
              "criteria": [
                "Cada equipo tiene 2 action items internos con owner y deadline",
                "Cross-team tiene 3 action items de coordinación con owner y deadline",
                "Action items son SMART (específicos, medibles, alcanzables en 1-2 sprints)",
                "Systemic issues identificados y con plan de acción (no solo síntomas)",
                "Action items previos (team + cross-team) fueron revisados (accountability)",
                "Ambiente de retros fue seguro (equipos participaron honestamente, no blame game)"
              ],
              "decision": "COMMIT TO IMPROVEMENTS (team + cross-team)",
              "approvers": [
                "Development Teams (3-5)",
                "Scrum Masters",
                "Release Train Engineer"
              ]
            },
            "keyStakeholders": [
              "Development Teams (3-5)",
              "Scrum Masters (1 por equipo)",
              "Release Train Engineer",
              "Chief Product Owner (opcional en cross-team retro)"
            ]
          }
        ],
        "iterationStrategy": "Sprints sincronizados de 2 semanas across 3-5 equipos (todos inician lunes, terminan viernes misma semana). Velocity agregada 80-150 story points total por sprint (20-30 puntos por equipo). Scrum of Scrums 3x/semana (lunes/miércoles/viernes, 30 min) para coordinación de dependencies. Product Owner Sync semanal (miércoles, 1h) para alinear prioridades. System Demo fin de sprint reemplaza Sprint Reviews individuales. PI (Program Increment) Planning cada 10 semanas (2 días presencial) planifica próximos 5 sprints con todos los equipos. Integration testing continuo post-merge para detectar incompatibilidades cross-subsystem temprano.",
        "whenToUse": [
          "Sistema grande con múltiples módulos independientes que requieren equipos separados (e-commerce: frontend, backend, payments, logistics)",
          "Equipos >20 personas (3-5 equipos de 6-9 personas c/u, no un solo equipo gigante)",
          "Necesidad de desarrollo paralelo (múltiples features simultáneas para acelerar time-to-market)",
          "Dependencias cross-team manejables pero existentes (equipos no completamente independientes)",
          "Organización madura en Scrum (equipos individuales ya ejecutan Scrum bien, listo para escalar)",
          "Product Owner tiene Chief PO de apoyo (1 PO solo no puede manejar 3-5 equipos)",
          "Stakeholders requieren visibilidad de sistema completo (no solo features aisladas de equipos individuales)",
          "Budget soporta 20-40 personas (salarios + tooling enterprise como Jira Align, SAFe licenses)",
          "Sistema web establecido con roadmap claro (no startup experimental, sino producto maduro creciendo)",
          "Integration testing automatizado factible (CI/CD infrastructure robusta para tests cross-subsystem)"
        ],
        "whenNotToUse": [
          "Equipo único <15 personas (overhead de Scrum of Scrums, System Demo no justifica, Scrum estándar suficiente)",
          "Subsistemas completamente independientes sin dependencies (cada equipo puede usar Scrum estándar aisladamente, no necesitan coordinación)",
          "Startup early-stage (Scrum/XP simple mejor, scaled Scrum demasiado pesado para 5-8 personas experimentando)",
          "Equipos distribuidos en zonas horarias muy diferentes (SoS 3x/semana, PO Sync síncrono difícil)",
          "Product Owner no tiene Chief PO de apoyo (1 PO solo se sobrecarga con 3-5 equipos)",
          "Sin Release Train Engineer dedicado (coordinación cross-team requiere rol full-time)",
          "Cultura organizacional no tolera ceremonias adicionales (SoS, PO Sync, System Demo visto como burocracia)",
          "Dependencies cross-team críticas y bloqueantes constantes (equipos se bloquean mutuamente, paralelismo se pierde)",
          "Budget limitado (20-40 personas + tooling enterprise costoso >$50K/año)",
          "Sistema simple sin complejidad arquitectónica (no necesitan múltiples equipos, 1 equipo Scrum estándar completa trabajo)"
        ],
        "advantages": [
          "Escalabilidad: 3-5 equipos paralelos entregan 3-5x más throughput que 1 equipo único (asumiendo dependencies bajas)",
          "Sincronización explícita: Scrum of Scrums, PO Sync, System Demo previenen integration hell y conflictos cross-team",
          "Visibilidad del sistema completo: System Demo muestra producto integrado, no features aisladas (stakeholders ven el 'big picture')",
          "PI Planning alinea equipos con estrategia: Planning de 10 semanas asegura que todos los equipos trabajan hacia objetivos comunes",
          "Integration testing continuo: CI/CD cross-subsystem detecta incompatibilidades temprano (no big-bang integration al final)",
          "Fault isolation: Falla de Equipo B no bloquea completamente a otros equipos si dependencies bien gestionadas",
          "Especialización de equipos: Frontend team, backend team, data team permite expertise profunda (no todos generalistas)",
          "Velocity predecible agregada: Después de 3-4 sprints, velocity total estable permite roadmap >6 meses con ±20% accuracy",
          "Career growth: Equipos grandes ofrecen roles especializados (tech lead, architect, PO) que equipos pequeños no tienen",
          "Reduces single points of failure: Multiple Scrum Masters, POs, tech leads (no dependen de 1 persona clave)"
        ],
        "disadvantages": [
          "Overhead de coordinación alto: SoS 3x/semana + PO Sync + System Demo + PI Planning consume 15-20% del tiempo",
          "Complejidad organizacional: Gestionar 3-5 POs, Scrum Masters, Chief PO, Release Train Engineer requiere management skills",
          "Dependencies bloquean flujo: Si Equipo A espera API de B, paralelismo se pierde (estimaciones complejas)",
          "Riesgo de burocracia: Ceremonias adicionales pueden volverse status meetings largos sin valor si mal facilitadas",
          "Integration testing complejo: CI/CD debe ejecutar tests cross-subsystem (infrastructure costosa, test data sync difícil)",
          "Communication overhead: 20-40 personas requieren más comunicación que 8-12 (Slack channels, meetings, emails crecen)",
          "Velocity variable entre equipos: Un equipo lento afecta system demo si otros dependen de él (frustración)",
          "Tooling costoso: Jira Align, SAFe licenses, enterprise ALM tools >$50K/año (vs Trello gratuito para equipo pequeño)",
          "Curva de aprendizaje de SAFe/LeSS: Frameworks complejos, equipos tardan 6-12 meses en dominar prácticas de escalamiento",
          "Silos de conocimiento: Equipos especializados (frontend, backend) pueden crear silos (frontend team no entiende backend)"
        ],
        "changeManagement": {
          "description": "Gestión de cambios coordinada cross-team con análisis de impacto multi-equipo.",
          "steps": [
            {
              "step": 1,
              "name": "Scope Freeze Mid-Sprint (Multi-Team)",
              "description": "Regla: NO cambios en Sprint Backlogs mid-sprint para ningún equipo (excepto emergencias críticas). Cambio en 1 equipo puede afectar dependencies de otros equipos, causando cascada de re-planificación."
            },
            {
              "step": 2,
              "name": "Cross-Team Impact Analysis",
              "description": "Si cambio urgente mid-sprint es inevitable, Chief PO + Release Train Engineer analizan impacto cross-team: ¿Qué equipos afectados? ¿Dependencies rotas? ¿Re-priorización necesaria en múltiples equipos?"
            },
            {
              "step": 3,
              "name": "Dependency-Aware Backlog Re-Prioritization",
              "description": "Entre sprints, POs re-priorizan backlogs en PO Sync considerando dependencies. Si Equipo A sube prioridad de feature que depende de Equipo B, PO de B debe ajustar prioridades en consecuencia."
            },
            {
              "step": 4,
              "name": "PI Planning for Long-Term Changes",
              "description": "Cambios estratégicos grandes (nuevos módulos, refactoring arquitectónico) se planifican en PI Planning cada 10 semanas. 2 días de planning con todos los equipos asegura alineación antes de ejecutar cambios grandes."
            },
            {
              "step": 5,
              "name": "System Demo Validates Integrated Changes",
              "description": "System Demo valida que cambios de múltiples equipos se integraron correctamente. Si un equipo cambió API sin coordinar, demo fallará y cambio se revierte o se fixea urgentemente."
            },
            {
              "step": 6,
              "name": "Retrospectives Address Change Management Issues",
              "description": "Cross-Team Retrospective identifica problemas en gestión de cambios (ej: 'Dependencies no documentadas causaron bloqueos', 'PO Sync no suficiente para coordinar cambios grandes'). Action items mejoran procesos de change management."
            }
          ]
        },
        "tooling": [
          {
            "category": "Scaled Agile Management",
            "tools": [
              "Jira Align (SAFe tooling, PI Planning, dependency tracking, roadmaps)",
              "VersionOne (alternativa a Jira Align para SAFe/LeSS)",
              "Rally (CA Agile Central, scaled agile management)"
            ]
          },
          {
            "category": "Multi-Team Coordination",
            "tools": [
              "Miro (PI Planning virtual, dependency boards, cross-team retrospectives)",
              "Mural (alternativa a Miro para workshops colaborativos)",
              "Slack (multi-channel communication, SoS notifications, integration alerts)"
            ]
          },
          {
            "category": "Integration Testing",
            "tools": [
              "Jenkins (CI/CD orchestration, integration tests cross-subsystem)",
              "GitHub Actions (CI/CD con matrix builds para tests paralelos)",
              "Postman/Newman (API integration testing automatizado)"
            ]
          },
          {
            "category": "Dependency Tracking",
            "tools": [
              "Jira Advanced Roadmaps (dependency visualization, cross-team dependencies)",
              "LucidChart (dependency diagrams, architecture visualization)",
              "Confluence (dependency documentation, API contracts, ADRs)"
            ]
          },
          {
            "category": "Communication",
            "tools": [
              "Zoom (PI Planning remoto, System Demo, cross-team retros)",
              "Slack (async coordination, SoS summaries, CI/CD notifications)",
              "Confluence (documentation, PI objectives, team working agreements)"
            ]
          }
        ],
        "references": [
          {
            "title": "Software Engineering (10th Edition) - Chapter 3: Agile Software Development",
            "author": "Ian Sommerville",
            "year": 2015,
            "source": "Pearson"
          },
          {
            "title": "SAFe 5.0 Distilled: Achieving Business Agility with the Scaled Agile Framework",
            "author": "Richard Knaster, Dean Leffingwell",
            "year": 2020,
            "source": "Addison-Wesley"
          },
          {
            "title": "Large-Scale Scrum (LeSS): More with LeSS",
            "author": "Craig Larman, Bas Vodde",
            "year": 2016,
            "source": "Addison-Wesley"
          },
          {
            "title": "The Scrum Guide (2020)",
            "author": "Ken Schwaber, Jeff Sutherland",
            "year": 2020,
            "source": "Scrum.org"
          }
        ]
      },
      "methodology": {
        "name": "Scrum Framework",
        "description": "Framework ágil ligero (lightweight) para desarrollo iterativo incremental basado en sprints time-boxed de duración fija (típicamente 1-4 semanas, recomendado 2 semanas). Enfocado en auto-organización del equipo (self-organizing teams), entregas frecuentes de incrementos funcionales potencialmente desplegables (potentially shippable increments) y adaptación continua basada en feedback de stakeholders y retrospectivas. Scrum define una estructura mínima de 3 roles (Product Owner, Scrum Master, Development Team), 4 ceremonias obligatorias (Sprint Planning, Daily Standup, Sprint Review, Sprint Retrospective) y 3 artefactos (Product Backlog, Sprint Backlog, Increment). Scrum es deliberadamente incompleto: no prescribe prácticas técnicas (testing, CI/CD, arquitectura), permitiendo que equipos las definan. Se basa en empirismo (transparencia, inspección, adaptación) y promueve mejora continua mediante retrospectivas regulares.",
        "origin": {
          "creator": "Ken Schwaber y Jeff Sutherland",
          "year": 1995,
          "context": "Presentado formalmente en OOPSLA 1995 (Object-Oriented Programming, Systems, Languages & Applications). Inspirado en el paper 'The New New Product Development Game' (Takeuchi & Nonaka, Harvard Business Review, 1986) que analizaba equipos de desarrollo de producto en Toyota, Honda y Canon. La Scrum Guide oficial fue publicada en 2010 y es actualizada periódicamente por Schwaber y Sutherland. Desarrollado inicialmente para equipos pequeños (5-9 personas) que necesitaban adaptarse rápidamente a cambios de requisitos en entornos de alta incertidumbre."
        },
        "principles": [
          "Empirismo (empirical process control): transparencia (todos ven el trabajo), inspección (revisar progreso frecuentemente), adaptación (ajustar proceso/producto basado en feedback)",
          "Auto-organización del equipo (self-organizing): Development Team decide cómo hacer el trabajo técnico, sin micro-gestión externa",
          "Sprints time-boxed de duración fija con entrega de incremento funcional potencialmente desplegable al final de cada sprint",
          "Product Owner prioriza Product Backlog basado en valor de negocio (ROI, riesgos, dependencias), no en detalles técnicos",
          "Daily Standup de 15 minutos para sincronización rápida del equipo (¿qué hice ayer? ¿qué haré hoy? ¿impedimentos?)",
          "Sprint Retrospective obligatoria al final de cada sprint para inspección del proceso y mejora continua (Kaizen)",
          "Working software como medida principal de progreso (no documentación ni % de tareas completadas)"
        ],
        "differentiators": [
          "vs XP: Scrum define estructura de proceso (ceremonias, roles, artefactos) pero NO prescribe prácticas técnicas, mientras XP prescribe 12 prácticas técnicas obligatorias (TDD, pair programming, CI, etc.)",
          "vs Kanban: Scrum usa sprints time-boxed con planning/review/retro al inicio/final de cada sprint, mientras Kanban es flujo continuo (continuous flow) sin time-boxes ni ceremonias obligatorias",
          "vs Waterfall: Scrum es iterativo con entregas incrementales frecuentes (cada 1-4 semanas), mientras Waterfall es secuencial con entrega única al final del proyecto (big-bang)"
        ],
        "references": {
          "chapter": "chapter-3",
          "sections": [
            "3.2 Agile development techniques",
            "3.3 Agile project management"
          ],
          "externalResources": [
            "Schwaber, K., & Sutherland, J. (2020). The Scrum Guide. https://scrumguides.org",
            "Sutherland, J. (2014). Scrum: The Art of Doing Twice the Work in Half the Time. Crown Business",
            "Takeuchi, H., & Nonaka, I. (1986). The New New Product Development Game. Harvard Business Review"
          ]
        }
      },
      "modeling": {
        "notations": [
          {
            "name": "User Story Mapping",
            "description": "Técnica ágil para organizar user stories en épicas y sprints.",
            "diagrams": [
              "User Story Map (horizontal: flujo usuario, vertical: prioridad)"
            ],
            "whenToUse": "Scrum Product Backlog refinement (organizar stories en sprints)",
            "tools": [
              "Miro",
              "Mural",
              "StoriesOnBoard",
              "Jira"
            ]
          },
          {
            "name": "UML ligero",
            "description": "Documentación técnica ligera (no exhaustiva como RUP). Solo diagramas críticos.",
            "diagrams": [
              "Class Diagram (diseño básico)",
              "Sequence Diagram (flujos críticos)",
              "Component Diagram (arquitectura)"
            ],
            "whenToUse": "Scrum teams documentan arquitectura high-level sin detalles exhaustivos",
            "tools": [
              "Lucidchart",
              "Draw.io",
              "Mermaid (markdown-based)",
              "PlantUML"
            ]
          },
          {
            "name": "C4 Model",
            "description": "Modelo de 4 niveles (Context, Container, Component, Code) para documentar arquitectura moderna.",
            "diagrams": [
              "C4 Context Diagram (sistema + actores)",
              "C4 Container Diagram (apps, DBs, message brokers)"
            ],
            "whenToUse": "Scrum teams documentan arquitectura high-level con C4 (Context, Container) sin detalles exhaustivos",
            "tools": [
              "Structurizr",
              "Draw.io",
              "Mermaid",
              "C4-PlantUML"
            ]
          }
        ],
        "primaryFocus": "Modelado ligero centrado en user stories y arquitectura high-level (no documentación exhaustiva)",
        "references": {
          "chapter": "chapter-3",
          "sections": [
            "3.2 Agile development techniques"
          ]
        }
      },
      "architecture": {
        "patterns": [
          {
            "name": "Microservices (full architecture)",
            "description": "Arquitectura completa de microservicios con 10-20 servicios, cada equipo Scrum posee 2-4 servicios.",
            "advantages": [
              "Ownership claro (cada equipo posee sus servicios)",
              "Deployment completamente independiente por equipo",
              "Escalamiento granular por servicio",
              "Tecnologías heterogéneas (equipos eligen stack óptimo)"
            ],
            "disadvantages": [
              "Complejidad operacional alta (service mesh necesario)",
              "Coordinación entre equipos para integraciones",
              "Distributed transactions complejas (sagas, event sourcing)"
            ],
            "whenToUse": "Scaled Scrum (rec-007: 20-40 personas, 3-5 teams) con sistema grande",
            "tradeoffs": "Autonomía de equipos vs Complejidad de coordinación"
          },
          {
            "name": "API Gateway",
            "description": "Gateway único de entrada que rutea requests a microservicios backend (Kong, AWS API Gateway).",
            "advantages": [
              "Punto único de entrada (simplifica clientes)",
              "Autenticación/autorización centralizada",
              "Rate limiting y throttling",
              "Routing y load balancing"
            ],
            "disadvantages": [
              "Puede convertirse en bottleneck si no escala bien",
              "Single point of failure (necesita redundancia)",
              "Complejidad de configuración"
            ],
            "whenToUse": "Microservices con múltiples clientes (web, móvil, partners) que necesitan punto de entrada unificado",
            "tradeoffs": "Simplicidad para clientes vs Riesgo de bottleneck"
          }
        ],
        "style": "Microservices distribuidos (10-20 servicios), API Gateway, Service Mesh",
        "qualityAttributes": {
          "scalability": "Very High - Microservices + auto-scaling + service mesh. Soporta alta carga distribuida.",
          "maintainability": "Medium-High - Equipos autónomos facilitan cambios, pero Scrum of Scrums (SoS) necesario para coordinación. Observabilidad crítica.",
          "performance": "High - Escalamiento independiente optimiza recursos. Service mesh con circuit breakers previene cascading failures.",
          "security": "Very High - API Gateway centraliza autenticación. mTLS entre servicios. Security champions en cada equipo Scrum."
        },
        "references": {
          "chapter": "chapter-6",
          "sections": [
            "6.3 Application architectures",
            "6.4 Architectural patterns",
            "6.5 Distributed systems architectures"
          ]
        }
      },
      "timeline": [
        {
          "week": "Continuo",
          "phase": "Sprints de 2 semanas",
          "tasks": [
            "Planning: Coordinación entre equipos",
            "Development: Features en paralelo",
            "Integration: Testing entre servicios",
            "Review: Demo consolidada",
            "Retrospective: Mejora continua"
          ]
        },
        {
          "week": "Mensual",
          "phase": "Arquitectura y Deuda Técnica",
          "tasks": [
            "Revisión de arquitectura",
            "Planificación de refactorización",
            "Migración a microservicios (incremental)",
            "Performance optimization"
          ]
        },
        {
          "week": "Trimestral",
          "phase": "Roadmap y Estrategia",
          "tasks": [
            "Definir features mayores",
            "Inversión en plataforma",
            "Evaluación de tecnologías",
            "Capacitación de equipos"
          ]
        }
      ],
      "avoid": [
        "Big bang migration a microservicios",
        "Equipos no coordinados (silos)",
        "Ignorar deuda técnica",
        "No invertir en observabilidad",
        "Over-engineering de features nuevas",
        "No medir impacto de features"
      ],
      "templates": [
        "tpl-004",
        "tpl-005",
        "tpl-006",
        "tpl-010"
      ],
      "chapters": [
        2,
        3,
        6
      ]
    },
    "rec-008": {
      "id": "rec-008",
      "title": "Personal/Móvil → App Individual",
      "path": [
        "Personal/Móvil",
        "Muy pequeño"
      ],
      "pathDescription": "Aplicación Personal/Móvil → Equipo Muy Pequeño (1-3 personas)",
      "process": {
        "name": "Extreme Programming (XP)",
        "type": "agile-xp-pure",
        "chapter": 3,
        "description": "Metodología ágil centrada en excelencia técnica y calidad de código mediante 12 prácticas obligatorias. Enfoque extremo en TDD (tests antes de código), pair programming, refactoring continuo, y small releases frecuentes. Ideal para equipos muy pequeños (2-4 personas) desarrollando aplicaciones móviles o personales donde calidad técnica es crítica.",
        "why": [
          "Calidad de código extremadamente alta mediante TDD (>90% test coverage) previene bugs en producción",
          "Small releases semanales a App Store/Play Store permiten feedback rápido de usuarios reales",
          "Pair programming reduce bugs 40-60% mediante revisión en tiempo real durante escritura de código",
          "Refactoring continuo evita acumulación de deuda técnica (código siempre limpio y mantenible)",
          "Simple Design (YAGNI) mantiene apps móviles ligeras y rápidas (crítico para mobile performance)"
        ],
        "how": [
          "Iterations de 1 semana (lunes-domingo) terminando con release a producción o beta",
          "Planning Game al inicio: Cliente presenta stories, developers estiman, seleccionan 5-10 story points",
          "TDD obligatorio: Red-Green-Refactor cycle (write test → fail → code → pass → refactor) múltiples veces al día",
          "Pair programming 30-50% del tiempo con rotación diaria de pairs para knowledge sharing",
          "Continuous Integration: Merge a main 3-5 veces/día con tests automatizados ejecutados en <3 min",
          "Small Release al final de iteration: Deploy a TestFlight/Play Store beta o producción"
        ],
        "phases": [
          {
            "id": "phase-xp-planning-game",
            "name": "Planning Game",
            "order": 1,
            "description": "Ceremonia de planificación colaborativa al inicio de iteration donde cliente/PO presenta user stories y developers estiman esfuerzo técnico. Negociación para seleccionar stories que caben en 1 semana. Objetivo: Crear iteration backlog con 5-10 story points de trabajo.",
            "duration": "2 horas (lunes 9-11 AM)",
            "activities": [
              "Cliente/PO presenta user stories priorizadas por valor de negocio (features más importantes primero)",
              "Developers estiman complejidad técnica de cada story usando Planning Poker (escala pequeña: 1, 2, 3, 5 - no stories >5 para iteration 1 semana)",
              "Negociación colaborativa: Cliente ajusta prioridades basado en estimaciones técnicas, developers sugieren simplificaciones",
              "Seleccionar 5-10 story points de trabajo (velocity típica para equipo 2-4 personas en 1 semana)",
              "Descomponer stories en tasks técnicas con TDD explícito: Para cada feature, identificar tests a escribir primero",
              "Identificar metaphor del sistema: Analogía simple que guía diseño (ej: 'App es una biblioteca personal que organiza libros')",
              "Verificar Simple Design: Asegurar que solución propuesta es la más simple posible (YAGNI, no agregar features especulativas)",
              "Asignar pairs para pair programming: Planificar qué días/tareas se harán en parejas (30-50% del tiempo)"
            ],
            "inputs": [
              "Backlog de user stories priorizadas por cliente",
              "Velocity de iteration anterior (5-10 puntos típico)",
              "Feedback de usuarios de release anterior (bugs, requests)"
            ],
            "outputs": [
              "Iteration backlog (5-10 story points seleccionados)",
              "Stories descompuestas en tasks con TDD tasks identificadas",
              "Pairs asignados para pair programming sessions",
              "Metaphor actualizada si sistema evolucionó"
            ],
            "deliverables": [
              {
                "name": "Iteration Backlog (user stories + tasks)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Cliente/PO",
                  "Developers"
                ]
              },
              {
                "name": "TDD Task List (tests a escribir por story)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Developers"
                ]
              },
              {
                "name": "Pair Programming Schedule (días/tareas en parejas)",
                "template": null,
                "required": false,
                "reviewedBy": [
                  "Developers"
                ]
              }
            ],
            "gate": {
              "name": "Iteration Commitment",
              "criteria": [
                "Stories seleccionadas caben en velocity promedio (5-10 puntos, no over-commitment)",
                "Todas las stories tienen acceptance criteria claros y testables",
                "TDD tasks identificadas para cada story (tests antes de código)",
                "Simple Design verificado (solución más simple posible, YAGNI)",
                "Cliente/PO disponible durante iteration para clarificaciones (On-site Customer)"
              ],
              "decision": "COMMIT / ADJUST SCOPE (si equipo tiene dudas de completar trabajo)",
              "approvers": [
                "Cliente/PO",
                "Developers"
              ]
            },
            "keyStakeholders": [
              "Cliente/PO (On-site Customer)",
              "Developers (2-4 personas)",
              "Designer (opcional si app móvil)"
            ]
          },
          {
            "id": "phase-xp-development-tdd",
            "name": "Development with TDD (Test-Driven Development)",
            "order": 2,
            "description": "Fase de desarrollo intensivo (días 1-5) con TDD obligatorio, pair programming 30-50% del tiempo, y continuous integration agresivo. TDD cycle: Red (write failing test) → Green (write minimal code to pass) → Refactor (improve design). Objetivo: Completar iteration backlog con >90% test coverage.",
            "duration": "5 días (lunes PM - viernes PM)",
            "activities": [
              "TDD Red-Green-Refactor cycle (múltiples veces al día): (1) Write failing unit test (Red), (2) Write minimal code to make test pass (Green), (3) Refactor code while keeping tests green",
              "Pair Programming 30-50% del tiempo: Rotación diaria de pairs (Driver escribe código, Navigator revisa en tiempo real y piensa estratégicamente)",
              "Continuous Integration agresivo: Merge a main/trunk 3-5 veces al día por developer, CI pipeline ejecuta tests en <3 min (GitHub Actions, CircleCI)",
              "Coding Standards enforcement: Pre-commit hooks ejecutan linter (ESLint, SwiftLint, Black) para asegurar código consistente",
              "Simple Design continuo: Implementar solución más simple que funcione (YAGNI, no over-engineering ni features especulativas)",
              "Collective Code Ownership: Cualquier developer puede modificar cualquier parte del código (facilitado por TDD que previene romper nada)",
              "On-site Customer disponible: Cliente/PO responde preguntas por Slack/WhatsApp en <2h para clarificar acceptance criteria",
              "Testing pyramid: Unit tests (mayoría, rápidos <1s), Integration tests (algunos, <5s), UI tests (mínimos, <30s)",
              "Code review en pair programming: Navigator hace review en tiempo real, no necesita PR review formal después (velocidad)",
              "40-hour week enforcement: No overtime crónico (equipo descansado escribe mejor código, overtime ocasional OK máximo 2 semanas)"
            ],
            "inputs": [
              "Iteration backlog con TDD tasks",
              "Pairs asignados para pair programming",
              "Metaphor del sistema (guía diseño)",
              "CI/CD pipeline configurado (tests <3 min)"
            ],
            "outputs": [
              "Código con >90% test coverage (TDD garantiza tests)",
              "Features implementadas con tests pasando (green)",
              "Código mergeado a main 3-5 veces/día (CI agresivo)",
              "Zero bugs conocidos (pair programming + TDD los previenen)"
            ],
            "deliverables": [
              {
                "name": "Working Software con TDD (>90% test coverage)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Developers",
                  "CI/CD pipeline"
                ]
              },
              {
                "name": "Test Suite Automatizado (unit, integration, UI tests)",
                "template": "tpl-013",
                "required": true,
                "reviewedBy": [
                  "Developers"
                ]
              },
              {
                "name": "Code Coverage Report (>90% coverage)",
                "template": "tpl-013",
                "required": true,
                "reviewedBy": [
                  "Developers"
                ]
              }
            ],
            "gate": {
              "name": "Quality Assurance Check",
              "criteria": [
                "Test coverage >90% mantenido (TDD obligatorio, no código sin tests)",
                "CI pipeline pasando en cada merge (zero broken builds en main)",
                "Pair programming 30-50% del tiempo cumplido (tracking informal)",
                "Simple Design mantenido (no over-engineering detectado en code reviews)",
                "Coding Standards cumplidos (linter pasa en pre-commit hooks)",
                "40-hour week respetado (no overtime crónico >2 semanas consecutivas)"
              ],
              "decision": "CONTINUE / FIX QUALITY ISSUES (si test coverage cae o broken builds)",
              "approvers": [
                "Developers",
                "CI/CD pipeline (automated gates)"
              ]
            },
            "keyStakeholders": [
              "Developers (pair programming rotado)",
              "Cliente/PO (On-site Customer para clarificaciones)",
              "CI/CD (automated testing)"
            ]
          },
          {
            "id": "phase-xp-refactoring",
            "name": "Refactoring & Collective Ownership",
            "order": 3,
            "description": "Día dedicado a refactoring del código de la iteration para mejorar diseño interno sin cambiar funcionalidad externa. Collective Code Ownership asegura que todos los developers entienden todo el código. Objetivo: Mantener código limpio y evitar deuda técnica acumulada.",
            "duration": "1 día (sábado o viernes tarde)",
            "activities": [
              "Refactoring de código de la iteration: Identificar code smells (duplicación, métodos largos, clases grandes) y refactorizar",
              "Aplicar reglas de Simple Design: (1) Pasa todos los tests, (2) No duplicación, (3) Expresa intención del programador, (4) Minimiza clases/métodos",
              "Collective Code Ownership enforcement: Developers rotan para leer y entender código escrito por otros (no silos de expertise)",
              "Code review cruzado: Todos revisan pull requests de otros (si no se hizo pair programming en esa feature)",
              "Actualizar metaphor del sistema: Si refactoring cambió estructura significativa, ajustar analogía para mantener coherencia",
              "Refactoring de tests: Eliminar tests duplicados, mejorar nombres de tests para claridad (tests como documentación)",
              "Dead code elimination: Remover código no usado (YAGNI retrospectivo, limpiar features experimentales que no se usaron)",
              "Performance profiling (si app móvil): Identificar bottlenecks con Instruments (iOS) o Profiler (Android), optimizar si necesario"
            ],
            "inputs": [
              "Código de iteration con features implementadas",
              "Test suite pasando (>90% coverage)",
              "Code smells identificados durante development"
            ],
            "outputs": [
              "Código refactorizado (mejor diseño interno)",
              "Zero duplicación de código (DRY aplicado)",
              "Metaphor actualizada (si cambió estructura)",
              "Collective ownership validado (todos entienden código)"
            ],
            "deliverables": [
              {
                "name": "Refactored Codebase (mejor diseño, zero duplicación)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Developers (collective ownership)"
                ]
              },
              {
                "name": "Updated Metaphor Document (si cambió)",
                "template": null,
                "required": false,
                "reviewedBy": [
                  "Developers"
                ]
              },
              {
                "name": "Performance Profile Report (si app móvil)",
                "template": "tpl-013",
                "required": false,
                "reviewedBy": [
                  "Developers"
                ]
              }
            ],
            "gate": {
              "name": "Code Quality Gate",
              "criteria": [
                "Tests siguen pasando después de refactoring (no funcionalidad rota)",
                "Code coverage mantenido >90% (refactoring no eliminó tests)",
                "Zero duplicación de código (DRY aplicado)",
                "Simple Design rules cumplidas (código expresa intención, minimiza clases)",
                "Collective ownership validado (al menos 2 developers entienden cada módulo)"
              ],
              "decision": "APPROVE REFACTORING / CONTINUE REFACTORING (si code smells persisten)",
              "approvers": [
                "Developers (consenso del equipo)"
              ]
            },
            "keyStakeholders": [
              "Developers (collective ownership)",
              "CI/CD (validación de tests post-refactoring)"
            ]
          },
          {
            "id": "phase-xp-small-release",
            "name": "Small Release",
            "order": 4,
            "description": "Release de la iteration a producción o beta (TestFlight para iOS, Play Store beta para Android). Small Releases frecuentes minimizan riesgo y maximizan feedback de usuarios reales. Objetivo: Entregar incremento funcional a usuarios y recoger feedback para próxima iteration.",
            "duration": "1 día (domingo o lunes temprano)",
            "activities": [
              "Preparar release notes: Documentar features nuevas, bug fixes, mejoras de performance para usuarios",
              "Ejecutar regression testing completo: Tests automatizados (unit, integration, UI) + testing exploratorio manual de flujos críticos",
              "Build de release: Generar .ipa (iOS) o .apk/.aab (Android) con firma de producción (no debug)",
              "Deploy a beta primero: TestFlight (iOS) o Play Store beta (Android) con 10-50 beta testers para validación final",
              "Monitorear crash reports: Firebase Crashlytics, Sentry, o App Store Connect para detectar bugs críticos en primeras 24h",
              "Recoger feedback de usuarios: In-app surveys, analytics (Firebase Analytics), reviews de App Store/Play Store",
              "Decisión de promover a producción: Si beta estable (zero crashes críticos, feedback positivo), promover a 100% usuarios",
              "Post-release monitoring: Monitorear métricas (MAU, retention, crash-free rate) por 48h para detectar issues",
              "40-hour week retrospective: Verificar que equipo no tuvo overtime crónico, ajustar velocity si fue over-committed"
            ],
            "inputs": [
              "Código refactorizado con tests pasando",
              "Release notes documentadas",
              "Beta testers disponibles (10-50 usuarios)",
              "CI/CD configurado para builds de release"
            ],
            "outputs": [
              "App en beta (TestFlight/Play Store beta) o producción",
              "Crash reports de primeras 24h (idealmente zero crashes)",
              "Feedback de usuarios (surveys, reviews, analytics)",
              "Métricas de release (MAU, retention, crash-free rate)"
            ],
            "deliverables": [
              {
                "name": "Released App (beta o producción)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Developers",
                  "Beta Testers",
                  "Cliente/PO"
                ]
              },
              {
                "name": "Release Notes (features, bug fixes, mejoras)",
                "template": "tpl-008",
                "required": true,
                "reviewedBy": [
                  "Cliente/PO",
                  "Developers"
                ]
              },
              {
                "name": "Post-Release Monitoring Report (crashes, métricas)",
                "template": "tpl-013",
                "required": true,
                "reviewedBy": [
                  "Developers"
                ]
              },
              {
                "name": "User Feedback Summary (surveys, reviews, analytics)",
                "template": "tpl-013",
                "required": false,
                "reviewedBy": [
                  "Cliente/PO"
                ]
              }
            ],
            "gate": {
              "name": "Release Success Gate",
              "criteria": [
                "Zero crashes críticos en primeras 24h de beta (crash-free rate >99%)",
                "Feedback de beta testers mayormente positivo (>80% satisfacción)",
                "Tests automatizados pasando (regression testing completo)",
                "Release notes aprobadas por cliente/PO (comunicación clara a usuarios)",
                "Métricas de release estables (no caída drástica de MAU o retention)",
                "40-hour week cumplido (equipo no en burnout, sostenible)"
              ],
              "decision": "PROMOTE TO PRODUCTION / ROLLBACK (si crashes críticos) / FIX & RE-RELEASE",
              "approvers": [
                "Cliente/PO",
                "Developers",
                "Beta Testers (feedback)"
              ]
            },
            "keyStakeholders": [
              "Developers",
              "Cliente/PO",
              "Beta Testers (10-50 usuarios)",
              "End Users (si release a producción)"
            ]
          }
        ],
        "iterationStrategy": "XP ejecuta iterations de 1 semana (lunes-domingo) que terminan con Small Release a beta o producción. Velocity típica 5-10 story points/semana para equipo 2-4 personas. TDD obligatorio: Red-Green-Refactor cycle múltiples veces al día garantiza >90% test coverage. Pair programming 30-50% del tiempo con rotación diaria para knowledge sharing (Driver + Navigator). Continuous Integration agresivo: Merge a main 3-5 veces/día con tests automatizados <3 min. Simple Design (YAGNI) mantiene código ligero. On-site Customer disponible por Slack/WhatsApp para responder preguntas en <2h. 40-hour week enforcement (no overtime crónico sostenible).",
        "whenToUse": [
          "Equipo muy pequeño (2-4 personas) sin overhead de ceremonias Scrum (Planning Game suficiente)",
          "Desarrollo personal, indie o side project (1 developer + 1 designer/PO)",
          "Aplicaciones móviles (iOS/Android) donde calidad de código es crítica (debugging móvil es lento, TDD previene bugs)",
          "Necesidad de releases frecuentes (semanales a App Store/Play Store o TestFlight/beta)",
          "Cliente/PO disponible diariamente (Slack, WhatsApp) para On-site Customer (respuestas <2h)",
          "Requisitos técnicos complejos donde TDD ayuda a garantizar correctitud (lógica de negocio, algoritmos)",
          "Equipo valora calidad técnica sobre velocidad pura (TDD + pair programming son más lentos pero producen código superior)",
          "Código legacy que necesita refactoring continuo (TDD permite refactorizar sin miedo a romper funcionalidad)",
          "Testing automatizado es factible (APIs, lógica de negocio testeable - no solo UI manual testing)",
          "Sin necesidad de roles formales ni ceremonias pesadas (equipo auto-organizado, todos hacen de todo)"
        ],
        "whenNotToUse": [
          "Equipo grande (>10 personas) - XP no escala bien sin framework adicional, usar Scrum Escalado",
          "Cliente/PO no disponible diariamente (On-site Customer es práctica obligatoria de XP)",
          "Pair Programming no es viable (equipo 100% remoto sin herramientas, o solo 1 developer sin pair)",
          "TDD no es posible (hardware embebido sin emulador, UI testing muy lento >5 min)",
          "Releases frecuentes no son posibles (regulaciones requieren aprobaciones lentas, ciclos de 6 meses)",
          "Equipo sin experiencia en TDD (curva de aprendizaje >6 meses, requiere training intensivo)",
          "Presión de deadline muy corto (TDD y pair programming son 30-50% más lentos inicialmente)",
          "Código no testeable (legacy monolítico sin inyección de dependencias, acoplamiento alto)",
          "Cultura organizacional anti-refactoring ('si funciona, no lo toques' - XP requiere refactoring continuo)",
          "Sin CI/CD disponible (tests manuales no escalan en XP que requiere merge 3-5 veces/día)"
        ],
        "advantages": [
          "Calidad de código extremadamente alta (TDD + pair programming + refactoring continuo = código superior)",
          "Test coverage >90% garantizado por TDD previene bugs en producción (menos hotfixes urgentes)",
          "Pair programming reduce bugs 40-60% mediante revisión en tiempo real durante escritura (no post-hoc)",
          "Small releases semanales minimizan riesgo (feedback rápido de usuarios, pivoting ágil si falla)",
          "Refactoring continuo evita deuda técnica acumulada (código siempre limpio, mantenible largo plazo)",
          "Collective ownership elimina silos de conocimiento (cualquiera puede trabajar en cualquier parte, no bus factor)",
          "Simple Design (YAGNI) facilita mantenimiento (menos código = menos bugs = menos complejidad)",
          "TDD facilita cambios mayores (tests garantizan no romper funcionalidad existente durante refactoring)",
          "40-hour week previene burnout (sostenible a largo plazo, equipo descansado escribe mejor código)",
          "On-site Customer reduce malentendidos de requisitos (feedback diario, clarificaciones inmediatas)"
        ],
        "disadvantages": [
          "Pair programming 50% más lento (2 personas, 1 tarea - pero compensa con menos bugs y knowledge sharing)",
          "TDD requiere disciplina y experiencia (curva de aprendizaje >6 meses para dominar Red-Green-Refactor)",
          "Overhead de testing alto (escribir tests toma 40-50% del tiempo de desarrollo total)",
          "No escala a equipos grandes (>10 personas, coordinación se vuelve difícil sin estructura adicional)",
          "Requiere cliente disponible diariamente (On-site Customer no siempre factible en organizaciones grandes)",
          "Refactoring continuo puede sentirse como 'no avanzar' (stakeholders impacientes ven poco progreso visible)",
          "Pair programming remoto es desafiante (requiere herramientas específicas como VS Code Live Share, latencia puede frustrar)",
          "Simple Design puede ser muy simple (riesgo de under-engineering, falta de abstracciones necesarias)",
          "Sin documentación formal generada (metaphor no es suficiente para onboarding de nuevos developers)",
          "Releases semanales pueden ser estresantes (testing de regresión completo cada semana, pressure constante)"
        ],
        "changeManagement": {
          "description": "Gestión de cambios flexible mediante Planning Game y refactoring facilitado por TDD.",
          "steps": [
            {
              "step": 1,
              "name": "Cliente presenta cambio en Planning Game",
              "description": "Cambios de requisitos se incorporan en próxima iteration mediante Planning Game. Cliente presenta nueva story o modificación de story existente, developers estiman impacto técnico."
            },
            {
              "step": 2,
              "name": "Developers estiman impacto técnico",
              "description": "Equipo analiza si cambio requiere refactoring significativo (arquitectura, API changes) o es incremental. Estiman story points considerando refactoring necesario."
            },
            {
              "step": 3,
              "name": "Re-priorizar stories en backlog",
              "description": "Cliente decide si cambio es más importante que stories previamente priorizadas. Planning Game permite re-negociar scope de iteration si cambio es urgente."
            },
            {
              "step": 4,
              "name": "Refactoring primero si necesario",
              "description": "Si cambio requiere refactoring arquitectónico grande (ej: cambiar data model), dedicar iteration completa a refactoring antes de implementar cambio. TDD asegura no romper funcionalidad durante refactoring."
            },
            {
              "step": 5,
              "name": "Implementar cambio con TDD",
              "description": "Escribir tests primero para nueva funcionalidad (Red), implementar código mínimo para pasar tests (Green), refactorizar si necesario (Refactor). TDD garantiza que cambio no rompe funcionalidad existente."
            },
            {
              "step": 6,
              "name": "Collective ownership permite flexibilidad",
              "description": "Cualquier developer puede implementar cambio (no dependen de 'dueño' del módulo). Pair programming si cambio es complejo asegura conocimiento distribuido."
            }
          ]
        },
        "tooling": [
          {
            "category": "Testing Frameworks (TDD obligatorio)",
            "tools": [
              "Jest (JavaScript/TypeScript TDD, fast execution)",
              "Pytest (Python TDD con fixtures potentes)",
              "XCTest (iOS native TDD framework)",
              "JUnit + Espresso (Android TDD + UI testing)",
              "React Native Testing Library (mobile cross-platform)"
            ]
          },
          {
            "category": "CI/CD (Continuous Integration <3 min)",
            "tools": [
              "GitHub Actions (CI/CD integrado, matrix builds para iOS/Android)",
              "CircleCI (optimizado para mobile, paralelización de tests)",
              "Bitrise (especializado en mobile CI/CD, iOS/Android)",
              "Fastlane (automatización de builds, screenshots, deploy a App Store/Play Store)"
            ]
          },
          {
            "category": "Pair Programming (remoto)",
            "tools": [
              "VS Code Live Share (pair programming en tiempo real, baja latencia)",
              "Tuple (pair programming tool optimizado para developers)",
              "Pop (screen sharing con audio de alta calidad)",
              "tmux + vim (pair programming en terminal para equipos técnicos)"
            ]
          },
          {
            "category": "Code Quality & Standards",
            "tools": [
              "ESLint + Prettier (JavaScript linting + formatting)",
              "SwiftLint (iOS coding standards)",
              "ktlint (Android Kotlin linting)",
              "Black (Python opinionated formatter)",
              "SonarQube (code quality, test coverage tracking)"
            ]
          },
          {
            "category": "Communication (On-site Customer)",
            "tools": [
              "Slack (async communication, <2h response time)",
              "WhatsApp (instant messaging para clarificaciones urgentes)",
              "Zoom (Planning Game semanal, screen sharing)"
            ]
          },
          {
            "category": "Mobile Specific",
            "tools": [
              "TestFlight (iOS beta distribution)",
              "Firebase App Distribution (Android beta)",
              "Firebase Crashlytics (crash reporting)",
              "Firebase Analytics (user behavior tracking)",
              "Instruments (iOS performance profiling)",
              "Android Profiler (Android performance)"
            ]
          }
        ],
        "references": [
          {
            "title": "Software Engineering (10th Edition) - Chapter 3: Agile Software Development",
            "author": "Ian Sommerville",
            "year": 2015,
            "source": "Pearson"
          },
          {
            "title": "Extreme Programming Explained: Embrace Change (1st Edition)",
            "author": "Kent Beck",
            "year": 1999,
            "source": "Addison-Wesley"
          },
          {
            "title": "Extreme Programming Explained: Embrace Change (2nd Edition)",
            "author": "Kent Beck, Cynthia Andres",
            "year": 2004,
            "source": "Addison-Wesley"
          },
          {
            "title": "Test Driven Development: By Example",
            "author": "Kent Beck",
            "year": 2002,
            "source": "Addison-Wesley"
          },
          {
            "title": "Refactoring: Improving the Design of Existing Code",
            "author": "Martin Fowler",
            "year": 2018,
            "source": "Addison-Wesley"
          }
        ]
      },
      "methodology": {
        "name": "Extreme Programming (XP)",
        "description": "Metodología ágil que lleva prácticas de ingeniería de software 'al extremo' (extreme) con énfasis en excelencia técnica, código de alta calidad mantenible y adaptación rápida a cambios de requisitos mediante feedback continuo. XP define 12 prácticas técnicas obligatorias agrupadas en 4 categorías: Planning (Planning Game, Small Releases), Design (Simple Design, Refactoring, Metaphor), Coding (Pair Programming, Collective Code Ownership, Coding Standards, Test-Driven Development), Testing/Integration (Continuous Integration, 40-hour week, On-site Customer). XP también define 5 valores fundamentales: Comunicación (face-to-face), Simplicidad (YAGNI - You Aren't Gonna Need It), Feedback (tests, customer), Coraje (refactor fearlessly), Respeto (entre equipo y stakeholders). Más prescriptiva que Scrum en prácticas técnicas específicas, pero menos formal en ceremonias y roles de gestión. Ideada para equipos pequeños (2-12 personas) que pueden trabajar co-localizados con acceso diario al cliente.",
        "origin": {
          "creator": "Kent Beck",
          "year": 1996,
          "context": "Desarrollado durante el proyecto C3 (Chrysler Comprehensive Compensation) en Chrysler Corporation usando el lenguaje Smalltalk. Kent Beck formalizó XP en el libro 'Extreme Programming Explained: Embrace Change' (1999, 2nd edition 2004). Motivado por frustración con overhead de metodologías pesadas (RUP, Waterfall) y necesidad de adaptarse rápidamente a cambios de requisitos en proyectos con alta incertidumbre. Ward Cunningham y Ron Jeffries fueron colaboradores clave en C3. XP fue una de las primeras metodologías ágiles formalizadas (pre-Agile Manifesto 2001)."
        },
        "principles": [
          "Test-Driven Development (TDD) obligatorio: escribir tests automatizados ANTES del código de producción (red-green-refactor cycle)",
          "Pair Programming: 2 developers trabajan en 1 computadora (driver escribe, navigator revisa), rotación frecuente para knowledge sharing y calidad",
          "Refactoring continuo: mantener código limpio y simple sin acumulación de deuda técnica (technical debt), refactorizar fearlessly gracias a suite de tests",
          "Simple Design (YAGNI - You Aren't Gonna Need It): no construir funcionalidad especulativa, solo lo necesario hoy (evita over-engineering)",
          "Collective Code Ownership: cualquier developer puede modificar cualquier parte del código (no hay 'dueños' de módulos), facilitado por tests y coding standards",
          "Continuous Integration (CI): integrar código al repositorio principal múltiples veces al día (mínimo 1x/día), con suite de tests ejecutándose automáticamente",
          "Small Releases: entregas frecuentes al cliente (semanal o incluso diariamente en casos extremos), iteraciones cortas de 1-2 semanas",
          "On-site Customer: representante del cliente disponible diariamente (idealmente full-time) para responder preguntas, priorizar features y dar feedback inmediato"
        ],
        "differentiators": [
          "vs Scrum: XP prescribe prácticas técnicas específicas obligatorias (TDD, pair programming, CI, refactoring), mientras Scrum solo define estructura de proceso (ceremonias/roles) y deja prácticas técnicas al equipo",
          "vs Waterfall: XP es iterativo con cambios de requisitos bienvenidos en cualquier momento, mientras Waterfall evita cambios mediante planificación upfront exhaustiva y change control formal",
          "vs RUP: XP promueve documentación mínima (código auto-documentado, tests como especificación), mientras RUP requiere documentación formal exhaustiva (SRS, SDD, traceability matrices)"
        ],
        "references": {
          "chapter": "chapter-3",
          "sections": [
            "3.2 Agile development techniques",
            "3.4 Extreme programming"
          ],
          "externalResources": [
            "Beck, K. (1999). Extreme Programming Explained: Embrace Change. Addison-Wesley",
            "Beck, K. (2004). Extreme Programming Explained: Embrace Change (2nd ed.). Addison-Wesley",
            "Beck, K., & Andres, C. (2004). Extreme Programming Explained: Embrace Change, Second Edition"
          ]
        }
      },
      "modeling": {
        "notations": [
          {
            "name": "CRC Cards (Class-Responsibility-Collaboration)",
            "description": "Técnica XP para diseño OO rápido (tarjetas con clase, responsabilidades, colaboradores).",
            "diagrams": [
              "CRC Cards (físicas o digitales)"
            ],
            "whenToUse": "XP Simple Design (diseño mínimo sin over-engineering). CRC cards facilitan diseño colaborativo en pair programming.",
            "tools": [
              "Físicas (post-its)",
              "Miro",
              "Google Jamboard",
              "Index cards"
            ]
          },
          {
            "name": "UML mínimo",
            "description": "Documentación mínima. Solo diagramas cuando código no es suficientemente claro.",
            "diagrams": [
              "Class Diagram (básico)",
              "Sequence Diagram (flujos complejos)"
            ],
            "whenToUse": "XP documentación mínima. Solo diagramas cuando código no es auto-explicativo.",
            "tools": [
              "Whiteboard",
              "Draw.io",
              "Mermaid",
              "PlantUML"
            ]
          },
          {
            "name": "Wireframes (Móvil)",
            "description": "Mockups de UI móvil para validar UX antes de implementar.",
            "diagrams": [
              "Wireframes",
              "Interactive Prototypes"
            ],
            "whenToUse": "Apps móviles (iOS/Android) requieren wireframes para validar flujos con on-site customer",
            "tools": [
              "Figma",
              "Sketch",
              "Balsamiq",
              "Adobe XD"
            ]
          }
        ],
        "primaryFocus": "Modelado mínimo (YAGNI). CRC cards para diseño OO, wireframes para UX móvil.",
        "references": {
          "chapter": "chapter-3",
          "sections": [
            "3.4 Extreme programming"
          ]
        }
      },
      "architecture": {
        "patterns": [
          {
            "name": "Monolito simple (Backend)",
            "description": "Arquitectura simple para apps móviles con backend API REST.",
            "advantages": [
              "Simplicidad (1 deployment, 1 base de datos)",
              "TDD fácil (no distributed testing)",
              "Simple Design (YAGNI: no over-engineer microservices para app pequeña)",
              "Deployment rápido (importante para small releases XP)"
            ],
            "disadvantages": [
              "Escalamiento limitado (vertical only)",
              "Deployment monolítico (todo o nada)"
            ],
            "whenToUse": "Apps móviles indie/personal (2-4 personas) con tráfico bajo-medio",
            "tradeoffs": "Simplicidad vs Escalabilidad"
          },
          {
            "name": "MVVM (Frontend Móvil)",
            "description": "Model-View-ViewModel para apps móviles (Flutter, React Native, SwiftUI).",
            "advantages": [
              "Separación de lógica de negocio y UI",
              "Testabilidad (ViewModel testeable sin UI, crítico para TDD de XP)",
              "Reactive programming (UI se actualiza automáticamente)",
              "Pair programming efectivo (logic en ViewModel, UI en View)"
            ],
            "disadvantages": [
              "Curva de aprendizaje (reactive programming)",
              "Boilerplate code (pero XP refactoring continuo lo minimiza)"
            ],
            "whenToUse": "Apps móviles modernas con UI compleja y necesidad de TDD",
            "tradeoffs": "Testabilidad y reactive UI vs Complejidad de boilerplate"
          },
          {
            "name": "BFF (Backend for Frontend)",
            "description": "Backend específico para móvil (agrega datos de múltiples servicios, optimiza payloads para móvil).",
            "advantages": [
              "Optimización para móvil (payloads pequeños, reduce roundtrips)",
              "Evolución independiente de backend móvil vs web",
              "Offline-first support (BFF puede cachear para offline)"
            ],
            "disadvantages": [
              "Duplicación de lógica (si no se usa BFF, móvil y web comparten mismo backend)"
            ],
            "whenToUse": "Apps móviles con necesidades específicas (offline-first, payloads optimizados, flujos móviles únicos)",
            "tradeoffs": "Optimización móvil vs Duplicación de lógica"
          }
        ],
        "style": "Monolito simple (backend API) + MVVM (frontend móvil)",
        "qualityAttributes": {
          "scalability": "Low-Medium - Apps indie no requieren escalamiento masivo. Vertical scaling suficiente.",
          "maintainability": "Very High - TDD, refactoring continuo, simple design, pair programming garantizan código limpio y mantenible.",
          "performance": "High - Apps móviles requieren performance (60 FPS UI, payloads optimizados). Small releases permiten optimización iterativa.",
          "security": "High - APIs móviles expuestas a internet. OAuth2 para autenticación. Certificate pinning contra MITM. Tests de seguridad en CI."
        },
        "references": {
          "chapter": "chapter-6",
          "sections": [
            "6.3 Application architectures"
          ]
        }
      },
      "timeline": [
        {
          "week": "Día 1",
          "phase": "Concepto",
          "tasks": [
            "Definir MVP (una funcionalidad core)",
            "Wireframes principales",
            "Setup de proyecto"
          ]
        },
        {
          "week": "1",
          "phase": "Primera Versión",
          "tasks": [
            "Implementar pantalla principal",
            "Modelo de datos básico",
            "Testing manual"
          ]
        },
        {
          "week": "2",
          "phase": "Funcionalidad Core",
          "tasks": [
            "Funcionalidad core completa",
            "UI polish básico",
            "TestFlight/Play Store Internal Testing"
          ]
        },
        {
          "week": "3",
          "phase": "Beta",
          "tasks": [
            "Feedback de beta testers",
            "Iteración basada en feedback",
            "Bug fixes"
          ]
        },
        {
          "week": "4+",
          "phase": "Lanzamiento e Iteración",
          "tasks": [
            "Primera release pública",
            "Marketing inicial",
            "Iteración basada en reviews y analytics"
          ]
        }
      ],
      "avoid": [
        "Sobre-ingeniería (YAGNI!)",
        "Muchas features en v1.0",
        "No testear con usuarios reales",
        "Ignorar lineamientos de Apple/Google",
        "No considerar permisos de usuario",
        "UI/UX descuidada"
      ],
      "templates": [
        "tpl-005",
        "tpl-008"
      ],
      "chapters": [
        2,
        3,
        5,
        6
      ]
    },
    "rec-009": {
      "id": "rec-009",
      "title": "Entretenimiento → Juegos",
      "path": [
        "Entretenimiento"
      ],
      "pathDescription": "Entretenimiento / Juegos → Creatividad y Experiencia Prioritarias",
      "process": {
        "name": "Hybrid Waterfall-Agile for Embedded/IoT",
        "type": "hybrid-waterfall-agile-embedded",
        "chapter": 2,
        "description": "Metodología híbrida para sistemas embebidos/IoT que combina Cascada upfront para diseño de hardware (no se puede cambiar post-fabricación) con desarrollo ágil iterativo para firmware/software (se puede actualizar con OTA). Balance entre predictibilidad de hardware (diseño completo antes de fabricación) y flexibilidad de firmware/software (iteraciones con testing en prototipo real, updates remotas post-deployment).",
        "why": [
          "Hardware requiere diseño completo upfront (costoso cambiar post-fabricación, rediseño de PCB = $50-100K)",
          "Firmware/software necesita iteraciones (debugging en hardware real, validación de sensores/actuadores físicos)",
          "OTA (Over-The-Air) updates permiten mejorar firmware post-deployment sin recall físico de dispositivos",
          "Certificaciones IoT (FCC/CE) requieren diseño final de hardware + firmware antes de aprobación",
          "Field testing con beta testers valida sistema en condiciones reales (no solo laboratorio)"
        ],
        "how": [
          "Fase 1 (Cascada, 8-12 semanas): Diseño hardware completo (schematics, PCB layout, componentes), prototipo físico, testing RF, certificaciones preliminares",
          "Fase 2 (Ágil, 16-24 semanas, 8-12 sprints): Firmware/software iterativo con sprints de 2 semanas, testing en prototipo físico cada sprint, OTA capability implementation",
          "Fase 3 (Cascada, 8-12 semanas): Integration testing hardware+firmware, field testing con 10-20 beta testers, certificaciones finales FCC/CE, manufacturing ramp-up"
        ],
        "phases": [
          {
            "id": "phase-hybrid-hw-design",
            "name": "Hardware Design (Waterfall Upfront)",
            "order": 1,
            "description": "Diseño completo de hardware antes de fabricación (no se puede iterar después). Schematics, PCB layout, selección de componentes, prototipo físico, testing de hardware, certificaciones preliminares. Objetivo: Hardware final validado antes de pasar a desarrollo de firmware.",
            "duration": "8-12 semanas",
            "activities": [
              "Diseño de schematics (circuit design): Microcontrolador, sensores, actuadores, power management, connectivity (WiFi, BLE, LoRa)",
              "PCB layout: Routing de señales, power planes, RF antenna design, mechanical constraints (carcasa, mounting holes)",
              "Selección de componentes: MCU (ESP32, STM32, nRF52), sensores (temperature, humidity, motion), radio (WiFi, BLE, LoRa), power (battery, charging circuit)",
              "Bill of Materials (BOM): Costos, lead times, supply chain (evitar componentes con stock limitado)",
              "Prototipo físico: PCB manufacturing (JLCPCB, PCBWay), assembly (SMT soldering), 3D printing de carcasa",
              "Testing de hardware: Voltaje, corriente, consumo energético (critical para battery life), temperatura (thermal testing), RF testing (antenna performance)",
              "Certificaciones preliminares: FCC/CE pre-compliance testing (RF chamber rental, EMI/EMC testing)",
              "Design freeze: Aprobar diseño final antes de fabricación en masa (cambios posteriores = rediseño costoso)"
            ],
            "inputs": [
              "Product requirements (funcionalidad del dispositivo IoT)",
              "Mechanical constraints (tamaño carcasa, mounting, IP rating si outdoor)",
              "Power budget (battery life target, ej: 1 año con CR2032)",
              "Connectivity requirements (WiFi, BLE, LoRa según rango y throughput)"
            ],
            "outputs": [
              "Schematics finales (circuit design aprobado)",
              "PCB layout Gerber files (para fabricación)",
              "BOM (Bill of Materials con costos y lead times)",
              "Prototipo físico funcional (5-10 unidades)",
              "Hardware testing report (voltaje, consumo, RF performance)",
              "Pre-compliance testing report (FCC/CE preliminary)"
            ],
            "deliverables": [
              {
                "name": "Schematics y PCB Gerber Files",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Hardware Engineer",
                  "Mechanical Engineer"
                ]
              },
              {
                "name": "Prototipo Físico (5-10 unidades)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Hardware Engineer",
                  "Firmware Engineer"
                ]
              },
              {
                "name": "Hardware Testing Report (voltaje, consumo, RF)",
                "template": "tpl-013",
                "required": true,
                "reviewedBy": [
                  "Hardware Engineer",
                  "QA Lead"
                ]
              },
              {
                "name": "Pre-Compliance Testing Report (FCC/CE)",
                "template": "tpl-013",
                "required": false,
                "reviewedBy": [
                  "Certification Consultant"
                ]
              }
            ],
            "gate": {
              "name": "Hardware Design Freeze Gate",
              "criteria": [
                "Schematics aprobados por Hardware Engineer (zero critical issues)",
                "Prototipo físico funcional validado (power-on, básica funcionalidad)",
                "Hardware testing passed (voltaje, consumo dentro de specs)",
                "RF performance aceptable (antenna gain, range según requirements)",
                "BOM con componentes disponibles (no components on allocation)",
                "Pre-compliance testing indica probabilidad alta de pasar FCC/CE final"
              ],
              "decision": "FREEZE DESIGN (proceed to firmware) / ITERATE (si hardware issues críticos)",
              "approvers": [
                "Hardware Engineer",
                "Product Owner",
                "Firmware Engineer"
              ]
            },
            "keyStakeholders": [
              "Hardware Engineer",
              "Mechanical Engineer (carcasa)",
              "Firmware Engineer",
              "Certification Consultant"
            ]
          },
          {
            "id": "phase-hybrid-fw-agile",
            "name": "Firmware/Software Development (Agile Iterative)",
            "order": 2,
            "description": "Desarrollo ágil de firmware/software con sprints de 2 semanas. Testing en prototipo físico cada sprint para validar integración hardware-firmware. OTA update capability para permitir updates remotas post-deployment. Objetivo: Firmware funcional completo testeado en hardware real.",
            "duration": "16-24 semanas (8-12 sprints de 2 semanas)",
            "activities": [
              "Sprint Planning: Seleccionar user stories de firmware/software (ej: 'Device wakes on motion sensor', 'Send telemetry to cloud every 5 min')",
              "Firmware development: C/C++, Rust, o Embedded Linux según MCU (ESP32 = ESP-IDF, STM32 = HAL, nRF52 = Zephyr RTOS)",
              "HAL (Hardware Abstraction Layer): Drivers para sensores, actuadores, radio (I2C, SPI, UART communication)",
              "Testing en prototipo físico: Flash firmware a prototipo, validar funcionalidad con sensores/actuadores reales (no simulación)",
              "Power optimization: Sleep modes, wake on interrupt, minimizar consumo para extender battery life",
              "OTA update implementation: Bootloader con dual partition (rollback si update falla), secure firmware signing",
              "Cloud integration (si aplica): MQTT, HTTP, CoAP para telemetry, AWS IoT Core, Azure IoT Hub, Google Cloud IoT",
              "App móvil/web (si aplica): Desarrollo en paralelo con Scrum para companion app (BLE pairing, dashboard, configuración)",
              "Sprint Review: Demo de firmware funcionando en prototipo físico (mostrar sensores/actuadores operando)",
              "Continuous Integration: CI/CD para firmware (GitHub Actions, PlatformIO CI para builds automatizados)"
            ],
            "inputs": [
              "Prototipo físico de Hardware Design phase",
              "Product backlog de firmware/software features",
              "Hardware datasheets (sensores, MCU, radio)",
              "Cloud backend API specs (si aplica)"
            ],
            "outputs": [
              "Firmware funcional con OTA capability (código C/C++/Rust)",
              "Firmware tested en prototipo físico (validado en hardware real)",
              "OTA update server configurado (AWS S3, Azure Blob, custom server)",
              "App móvil/web (si aplica) integrada con dispositivo vía BLE/WiFi",
              "Power consumption optimized (sleep modes implementados)"
            ],
            "deliverables": [
              {
                "name": "Firmware con OTA Capability (código fuente + binary)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Firmware Engineer",
                  "Hardware Engineer"
                ]
              },
              {
                "name": "Firmware Testing Report (validado en prototipo físico)",
                "template": "tpl-013",
                "required": true,
                "reviewedBy": [
                  "QA Lead",
                  "Firmware Engineer"
                ]
              },
              {
                "name": "OTA Update Server (configurado y testeado)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Backend Engineer",
                  "DevOps"
                ]
              },
              {
                "name": "Companion App (móvil/web si aplica)",
                "template": null,
                "required": false,
                "reviewedBy": [
                  "App Developer",
                  "Product Owner"
                ]
              }
            ],
            "gate": {
              "name": "Firmware Functional Complete Gate",
              "criteria": [
                "Firmware funciona en prototipo físico (100% user stories implementadas)",
                "OTA update capability validada (update + rollback funcionan)",
                "Power consumption dentro de target (battery life >target, ej: >6 meses)",
                "Cloud integration funcional (telemetry enviada correctamente si aplica)",
                "App móvil/web integrada (BLE pairing, dashboard funcionan si aplica)",
                "Zero bugs críticos conocidos (bugs menores aceptables)"
              ],
              "decision": "PROCEED TO INTEGRATION / FIX CRITICAL BUGS",
              "approvers": [
                "Firmware Engineer",
                "Product Owner",
                "QA Lead"
              ]
            },
            "keyStakeholders": [
              "Firmware Engineer",
              "Backend Engineer (cloud)",
              "App Developer (móvil/web)",
              "QA Lead"
            ]
          },
          {
            "id": "phase-hybrid-integration",
            "name": "Integration & Certification (Waterfall Final)",
            "order": 3,
            "description": "Integration testing de hardware+firmware, field testing con beta testers en condiciones reales, certificaciones finales FCC/CE con firmware final, manufacturing ramp-up. Objetivo: Sistema certificado listo para producción en masa.",
            "duration": "8-12 semanas",
            "activities": [
              "Integration testing: Validar hardware + firmware + cloud + app en conjunto (end-to-end testing)",
              "Field testing: Enviar 10-20 prototipos a beta testers (usuarios reales en condiciones reales: outdoor, indoor, temperatura, humedad)",
              "Crash reporting: Firebase Crashlytics, Sentry para capturar bugs en field testing (4-6 semanas de testing)",
              "Certificaciones finales FCC/CE: Submisión de hardware + firmware final a laboratorio certificado (6-8 semanas, $10-20K)",
              "Manufacturing ramp-up: Negociar con fabricante (MOQ, lead times, quality control), producir batch piloto (100-500 unidades)",
              "Packaging design: Caja, manual de usuario, etiquetas FCC/CE (compliance labeling)",
              "User documentation: Manual de instalación, troubleshooting, especificaciones técnicas",
              "Support setup: Helpdesk, knowledge base, RMA (Return Merchandise Authorization) process para defectos",
              "Production release: Aprobación final para manufacturing en masa (1000+ unidades)"
            ],
            "inputs": [
              "Prototipo con firmware funcional (Agile phase)",
              "Field testing feedback de beta testers",
              "Certificaciones preliminares (pre-compliance de Design phase)"
            ],
            "outputs": [
              "Sistema integrado validado (hardware + firmware + cloud + app)",
              "Field testing report (beta testers feedback, crash reports, battery life real)",
              "Certificaciones FCC/CE aprobadas (compliance certificates)",
              "Manufacturing batch piloto (100-500 unidades producidas)",
              "User documentation completa (manual, troubleshooting)"
            ],
            "deliverables": [
              {
                "name": "Integration Testing Report (end-to-end validado)",
                "template": "tpl-013",
                "required": true,
                "reviewedBy": [
                  "QA Lead",
                  "Product Owner"
                ]
              },
              {
                "name": "Field Testing Report (beta testers, 4-6 semanas)",
                "template": "tpl-013",
                "required": true,
                "reviewedBy": [
                  "Product Owner",
                  "QA Lead"
                ]
              },
              {
                "name": "FCC/CE Certificates (compliance aprobada)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Certification Consultant",
                  "Product Owner"
                ]
              },
              {
                "name": "Manufacturing Batch Piloto (100-500 unidades)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Manufacturing Engineer",
                  "QA Lead"
                ]
              },
              {
                "name": "User Documentation (manual, troubleshooting)",
                "template": "tpl-007",
                "required": true,
                "reviewedBy": [
                  "Technical Writer",
                  "Product Owner"
                ]
              }
            ],
            "gate": {
              "name": "Production Release Gate",
              "criteria": [
                "Integration testing passed (hardware + firmware + cloud + app funcionan end-to-end)",
                "Field testing exitoso (>90% beta testers satisfechos, battery life cumple target)",
                "FCC/CE certificates obtenidos (compliance aprobada)",
                "Manufacturing batch piloto sin defectos críticos (<1% defect rate)",
                "User documentation aprobada por Product Owner",
                "Support setup operativo (helpdesk, RMA process funcionando)"
              ],
              "decision": "APPROVE MASS PRODUCTION / FIX ISSUES / ITERATE",
              "approvers": [
                "Product Owner",
                "QA Lead",
                "Manufacturing Engineer",
                "Certification Consultant"
              ]
            },
            "keyStakeholders": [
              "QA Lead",
              "Beta Testers (10-20 usuarios)",
              "Manufacturing Engineer",
              "Certification Consultant",
              "Product Owner"
            ]
          }
        ],
        "iterationStrategy": "Híbrido con 3 fases: (1) Hardware Design (Cascada, 8-12 sem, NO iterativo - diseño completo upfront antes de fabricación), (2) Firmware/Software Development (Ágil, 16-24 sem, 8-12 sprints de 2 semanas - iterativo con testing en prototipo físico cada sprint), (3) Integration & Certification (Cascada, 8-12 sem, NO iterativo - validación formal end-to-end). Total: 32-48 semanas (8-12 meses). OTA updates post-deployment permiten mejorar firmware sin recall físico.",
        "whenToUse": [
          "Sistema embebido o IoT con hardware custom + firmware (no Raspberry Pi/Arduino commodity)",
          "Hardware no se puede cambiar después de fabricación (costoso rediseño de PCB)",
          "Firmware/software necesita iteraciones (debugging en hardware real, validación de sensores/actuadores)",
          "Certificaciones IoT requeridas (FCC para USA, CE para Europa, UL para seguridad eléctrica)",
          "OTA (Over-The-Air) updates factibles (firmware se puede actualizar remotamente via WiFi/cellular)",
          "Prototipo físico disponible para testing iterativo (PCB manufacturing, assembly)",
          "Equipo con expertise en hardware + firmware + embedded systems",
          "Timeline 8-12 meses aceptable (suficiente para diseño hardware + firmware ágil + certificaciones)",
          "Presupuesto para prototipado físico ($5-10K PCB + componentes) + certificaciones ($10-20K FCC/CE)",
          "Field testing con beta testers posible (validar en condiciones reales: outdoor, temperatura, humedad)"
        ],
        "whenNotToUse": [
          "Sistema solo software sin hardware custom (usar Ágil puro como Scrum o XP)",
          "Hardware commodity (Raspberry Pi, Arduino, ESP32 dev boards sin PCB custom, usar Ágil puro)",
          "Hardware puede cambiar fácilmente (prototipado rápido 3D printing sin PCB, usar Ágil puro)",
          "Sin OTA updates (firmware no se puede actualizar remotamente, muy restrictivo para IoT moderno)",
          "Equipo sin expertise en hardware (curva de aprendizaje muy alta >6 meses)",
          "Timeline <6 meses (no hay tiempo para diseño hardware upfront + firmware ágil + certificaciones)",
          "Sin presupuesto para prototipado físico (mínimo $5-10K para PCB manufacturing + componentes)",
          "Certificaciones no requeridas (producto interno o prototipo, usar Ágil puro)",
          "Sistema crítico para vida (medical devices Class II/III, usar Cascada puro con V&V formal, no híbrido)",
          "Sin field testing posible (imposible validar en condiciones reales, solo lab testing)"
        ],
        "advantages": [
          "Hardware diseñado upfront evita rediseño costoso post-fabricación (saving $50-100K en re-spins de PCB)",
          "Firmware ágil permite debugging en hardware real (iteraciones rápidas con prototipo físico)",
          "OTA updates permiten fixing de bugs post-deployment (sin recall físico de dispositivos)",
          "Field testing valida sistema en condiciones reales (no solo laboratorio: temperatura, humedad, RF interference)",
          "Certificaciones FCC/CE se obtienen con diseño final (no necesidad de re-certificar después)",
          "Balance entre predictibilidad (hardware) y flexibilidad (firmware iterativo)",
          "Testing iterativo en prototipo reduce riesgo de integration bugs (hardware-firmware validado cada sprint)",
          "Manufacturing ramp-up planificado (batch piloto antes de producción en masa minimiza riesgo)",
          "Apropiado para equipos multidisciplinarios (hardware, firmware, mechanical, RF engineers)",
          "Firmware se puede mejorar post-deployment (features nuevas con OTA updates sin tocar hardware)"
        ],
        "disadvantages": [
          "Hardware upfront es riesgo alto (si diseño tiene fallas críticas, costoso rediseñar PCB + re-certificar)",
          "Prototipado físico es costoso ($5-10K mínimo para PCB manufacturing + assembly + componentes)",
          "Certificaciones FCC/CE son lentas (6-8 semanas) y costosas ($10-20K por región)",
          "Testing en hardware real es lento (no se puede mockear sensores/actuadores fácilmente)",
          "OTA updates tienen riesgo (brick devices si update falla, necesita rollback capability robusto)",
          "Field testing logístico complejo (enviar 10-20 prototipos, recoger feedback, RMA si fallan)",
          "Requiere expertise multidisciplinario escaso (hardware, firmware, RF, mechanical engineering)",
          "Manufacturing ramp-up tiene lead time largo (8-12 semanas para producción en masa con fabricante)",
          "Timeline largo (8-12 meses mínimo) comparado con solo software (3-6 meses Ágil puro)",
          "Cambios de hardware mid-project son muy costosos (rediseño PCB + re-fabricación + re-certificación = $50-100K + 12 semanas)"
        ],
        "changeManagement": {
          "description": "Gestión de cambios estricta: hardware solo en Phase 1, firmware flexible en Phase 2-3.",
          "steps": [
            {
              "step": 1,
              "name": "Cambio en Hardware (solo Phase 1)",
              "description": "Cambios de hardware solo permitidos en Phase 1 (antes de design freeze). Después de fabricación de prototipo final, cambios requieren rediseño completo de PCB ($50-100K + 8-12 semanas lead time)."
            },
            {
              "step": 2,
              "name": "Cambio en Firmware/Software (cualquier momento)",
              "description": "Cambios de firmware permitidos en cualquier sprint de Phase 2 (Ágil). Prioritizar en backlog según valor de negocio. Post-deployment, cambios se pueden deployar con OTA updates."
            },
            {
              "step": 3,
              "name": "Impacto en Certificaciones",
              "description": "Cambios de hardware (PCB, componentes, antenna) o cambios de firmware que afectan RF requieren re-certificación FCC/CE completa (6-8 semanas + $10-20K). Cambios de firmware que no afectan RF no requieren re-certificación."
            },
            {
              "step": 4,
              "name": "OTA Update Post-Deployment",
              "description": "Cambios menores de firmware (bug fixes, optimizaciones) se pueden deployar con OTA updates remotas. Testing en staging environment primero (rollout gradual: 10% → 50% → 100% dispositivos)."
            },
            {
              "step": 5,
              "name": "Field Testing si Cambio Crítico",
              "description": "Cambios críticos de firmware (power management, RF communication) requieren re-testing con beta testers en field (4-6 semanas adicionales para validar en condiciones reales)."
            }
          ]
        },
        "tooling": [
          {
            "category": "Hardware Design",
            "tools": [
              "KiCAD, Altium Designer (PCB design, schematics)",
              "Oscilloscope, Multimeter, Logic Analyzer (hardware testing)",
              "RF chamber rental (FCC/CE pre-compliance testing)",
              "3D printer (carcasa prototyping), PCB manufacturing (JLCPCB, PCBWay)"
            ]
          },
          {
            "category": "Firmware Development",
            "tools": [
              "Embedded IDEs (Keil, IAR, PlatformIO, Arduino IDE)",
              "JTAG debugger, SWD (flashing y debugging firmware en MCU)",
              "Git/GitHub (version control firmware)",
              "CI/CD (GitHub Actions, PlatformIO CI para builds automatizados)"
            ]
          },
          {
            "category": "OTA Updates",
            "tools": [
              "AWS IoT Core, Azure IoT Hub, Google Cloud IoT (cloud backend)",
              "MQTT broker (Mosquitto, AWS IoT MQTT)",
              "OTA libraries (ESP32 OTA, Mbed Cloud, custom bootloader)"
            ]
          },
          {
            "category": "Testing & Monitoring",
            "tools": [
              "pytest (unit tests firmware con mocking de HAL)",
              "Firebase Crashlytics, Sentry (crash reporting field testing)",
              "Firebase Analytics (telemetry de dispositivos en field)",
              "Power Profiler Kit (Nordic nRF PPK para medir consumo energético)"
            ]
          },
          {
            "category": "App Development (si aplica)",
            "tools": [
              "React Native, Flutter (cross-platform móvil)",
              "BLE libraries (react-native-ble-plx, flutter_blue)",
              "Xcode (iOS), Android Studio (Android)"
            ]
          }
        ],
        "references": [
          {
            "title": "Software Engineering (10th Edition) - Chapter 2: Software Processes",
            "author": "Ian Sommerville",
            "year": 2015,
            "source": "Pearson"
          },
          {
            "title": "Software Engineering (10th Edition) - Chapter 3: Agile Software Development",
            "author": "Ian Sommerville",
            "year": 2015,
            "source": "Pearson"
          },
          {
            "title": "Embedded Systems Architecture: Explore architectural concepts and best practices",
            "author": "Daniele Lacamera",
            "year": 2018,
            "source": "Packt Publishing"
          }
        ]
      },
      "methodology": {
        "name": "Hybrid Waterfall-Agile (Embedded/IoT)",
        "description": "Metodología híbrida que combina desarrollo Waterfall upfront para hardware (diseño completo antes de fabricación en masa) con desarrollo Ágil iterativo para firmware/software (actualizable mediante OTA - Over-The-Air updates). Tres fases principales: (1) Hardware Design (Waterfall, 8-12 semanas): diseño completo de circuitos, PCB layout, selección de componentes, prototipo físico - esta fase NO puede iterarse después de manufactura en masa debido a costos prohibitivos de rediseño; (2) Firmware/Software Development (Ágil, 16-24 semanas): sprints iterativos de 2 semanas desarrollando firmware en hardware prototipo/EVT, con posibilidad de updates OTA post-deployment para bugfixes y nuevas features; (3) Integration & Certification (Waterfall, 8-12 semanas): testing de integración hardware-firmware, field testing en condiciones reales, certificaciones regulatorias FCC/CE con firmware final. Balance crítico entre predictibilidad (hardware) y flexibilidad (firmware/software).",
        "origin": {
          "creator": "Práctica de la industria de sistemas embebidos/IoT (sin creador único identificable)",
          "year": 2005,
          "context": "Emergió en la industria de consumer IoT (~2005-2010) cuando productos conectados (wearables, smart home, drones) necesitaban combinar restricciones de hardware físico (imposible cambiar post-manufactura sin recall costoso) con flexibilidad de firmware (bugs críticos se pueden patchear con OTA updates después de deployment). Popularizado por empresas como Nest, Fitbit, Xiaomi. Motivado por necesidad de reducir time-to-market (lanzar producto rápido con firmware MVP) mientras se mantiene capacidad de mejora continua post-deployment mediante OTA."
        },
        "principles": [
          "Hardware design upfront completo: schematics, PCB layout, BOM (Bill of Materials), prototipo funcional validado antes de manufactura en masa (no se puede cambiar después sin costos masivos)",
          "Firmware/software desarrollo iterativo: sprints de 2 semanas desarrollando y testeando firmware en hardware prototipo (EVT - Engineering Validation Test), con refactoring y mejora continua",
          "OTA (Over-The-Air) update capability obligatoria: firmware debe poder actualizarse remotamente post-deployment para bugfixes, security patches y nuevas features",
          "Certificaciones de hardware finales: FCC (USA), CE (Europa), IC (Canadá) realizadas con firmware final estabilizado antes de lanzamiento comercial",
          "Field testing con beta testers: validar producto en condiciones reales de uso (no solo lab testing) antes de producción en masa",
          "Hardware-software co-design: equipos de hardware y firmware trabajan colaborativamente desde fase de diseño para optimizar integración (evitar bottlenecks de última hora)"
        ],
        "differentiators": [
          "vs Waterfall puro: Firmware/software se desarrolla iterativamente (no todo es upfront), permitiendo adaptación a feedback de testing en hardware real",
          "vs Ágil puro: Hardware se diseña upfront completamente (no se puede iterar post-manufactura), sacrificando flexibilidad por viabilidad económica",
          "vs Espiral: No hay ciclos completos repetidos de análisis de riesgos + prototipo + desarrollo, sino fases híbridas con diferentes enfoques (Waterfall para HW, Ágil para FW)"
        ],
        "references": {
          "chapter": "chapter-2, chapter-3",
          "sections": [
            "2.1 Plan-driven and agile development",
            "3.2 Agile development techniques"
          ],
          "externalResources": [
            "Práctica común de la industria IoT/embedded - no hay paper académico seminal único",
            "White, E. (2011). Making Embedded Systems: Design Patterns for Great Software. O'Reilly Media"
          ]
        }
      },
      "modeling": {
        "notations": [
          {
            "name": "UML",
            "description": "UML para documentación formal de hardware-software co-design.",
            "diagrams": [
              "Component Diagram (hardware + firmware + software)",
              "Deployment Diagram (edge + cloud)",
              "State Machine Diagram (firmware states)"
            ],
            "whenToUse": "Sistemas embebidos requieren documentación formal de hardware-software co-design",
            "tools": [
              "Enterprise Architect",
              "Rhapsody (IBM)",
              "Visual Paradigm"
            ]
          },
          {
            "name": "Hardware Schematics",
            "description": "Diagramas de circuitos eléctricos (schematics) y PCB layout.",
            "diagrams": [
              "Schematic Diagram",
              "PCB Layout",
              "Block Diagram"
            ],
            "whenToUse": "Hardware design (Fase 1 Cascada) - diseño completo antes de fabricación",
            "tools": [
              "KiCAD",
              "Altium Designer",
              "Eagle",
              "Proteus"
            ]
          }
        ],
        "primaryFocus": "Modelado de hardware-software co-design, schematics de hardware, diagramas de deployment edge+cloud",
        "references": {
          "chapter": "chapter-6, chapter-21",
          "sections": [
            "6.5 Distributed systems architectures",
            "21.2 Embedded system design"
          ]
        }
      },
      "architecture": {
        "patterns": [
          {
            "name": "Edge Computing + Cloud",
            "description": "Procesamiento en edge (dispositivos IoT) + cloud (analytics, storage).",
            "advantages": [
              "Latencia baja (procesamiento en edge, crítico para real-time)",
              "Tolerancia a fallos (edge opera offline si cloud no disponible)",
              "Ahorro de ancho de banda (solo datos agregados a cloud)",
              "Privacidad (datos sensibles procesados localmente)"
            ],
            "disadvantages": [
              "Complejidad de sincronización edge-cloud",
              "Recursos limitados en edge (CPU, RAM, batería)",
              "Debugging difícil (edge devices en campo)"
            ],
            "whenToUse": "IoT con requisitos de latencia baja o conectividad intermitente (industrial, wearables, smart home)",
            "tradeoffs": "Latencia baja y tolerancia a fallos vs Complejidad de sincronización"
          },
          {
            "name": "Firmware Layered",
            "description": "Firmware en capas (HAL - Hardware Abstraction Layer, Middleware, Application).",
            "advantages": [
              "Portabilidad (cambiar hardware sin reescribir application)",
              "Testabilidad (mockear HAL para unit tests)",
              "Reusabilidad (HAL reutilizable en múltiples productos)"
            ],
            "disadvantages": [
              "Overhead de abstracción (latencia en sistemas real-time críticos)",
              "Memoria adicional (layers ocupan RAM/Flash)"
            ],
            "whenToUse": "Firmware que debe soportar múltiples hardware (ej: diferentes microcontroladores STM32, ESP32, nRF)",
            "tradeoffs": "Portabilidad vs Overhead de abstracción"
          }
        ],
        "style": "Distribuido (edge + cloud), firmware layered",
        "qualityAttributes": {
          "scalability": "High - Cloud escala horizontalmente. Edge distribuye carga (millones de dispositivos).",
          "maintainability": "Medium - Firmware complejo de debuggear. OTA updates facilitan mantenimiento post-deployment. Logging limitado en edge.",
          "performance": "High - Real-time constraints en firmware (RTOS). Edge computing reduce latencia. Optimización crítica (batería, CPU).",
          "security": "Very High - TLS para comunicación edge-cloud. Secure boot en firmware. Hardware security modules (HSM). OTA updates firmados."
        },
        "references": {
          "chapter": "chapter-21",
          "sections": [
            "21.2 Embedded system design",
            "21.3 Real-time system design"
          ]
        }
      },
      "timeline": [
        {
          "week": "1",
          "phase": "Concepto",
          "tasks": [
            "Game concept (¿qué lo hace único?)",
            "Mecánica core (1-2 principales)",
            "Referentes (juegos similares)",
            "Target audience"
          ]
        },
        {
          "week": "2",
          "phase": "Prototipo",
          "tasks": [
            "Prototipo jugable de mecánica core",
            "Gray-box (sin arte final)",
            "Playtest interno",
            "Decisión Go/No-Go: ¿Es divertido?"
          ]
        },
        {
          "week": "3-8",
          "phase": "Desarrollo Vertical",
          "tasks": [
            "Implementar 1 nivel completo",
            "Arte placeholder → arte final",
            "Audio básico",
            "Polish de la experiencia core"
          ]
        },
        {
          "week": "9-12",
          "phase": "Expansión",
          "tasks": [
            "Más niveles",
            "Features secundarias",
            "Testing con jugadores externos",
            "Balanceo (game balance)"
          ]
        },
        {
          "week": "13+",
          "phase": "Polish y Lanzamiento",
          "tasks": [
            "Bug fixing",
            "Optimización de performance",
            "Trailer y marketing",
            "Launch en plataforma target"
          ]
        }
      ],
      "avoid": [
        "Pulir antes de validar (arte final sin playtest)",
        "Feature creep (agregar todo lo que se te ocurre)",
        "No testear en hardware target",
        "Ignorar performance",
        "Código perfecto > gameplay divertido",
        "No balancear dificultad"
      ],
      "templates": [
        "tpl-005",
        "tpl-008"
      ],
      "chapters": [
        2,
        3,
        5,
        6
      ]
    },
    "rec-010": {
      "id": "rec-010",
      "title": "Procesamiento por Lotes",
      "path": [
        "Lotes"
      ],
      "pathDescription": "Procesamiento por Lotes → Grandes Volúmenes → Eficiencia Crítica",
      "process": {
        "name": "Cascada o Incremental (Pipel Pipeline-Oriented)",
        "type": "sequential-phases",
        "description": "Modelo en Cascada para sistemas de procesamiento por lotes (batch processing): enfocado en diseño anticipado del pipeline de procesamiento, optimización de performance y manejo de grandes volúmenes de datos. Apropiado cuando los procesos de negocio están bien definidos y la eficiencia es crítica.",
        "chapter": 2,
        "why": [
          "Requisitos estables (procesos de negocio establecidos)",
          "Planificación anticipada crítica para optimización",
          "Performance es requisito no funcional clave",
          "Sistema nuevo y definido → Cascada; complejo → Incremental",
          "Testing con volúmenes reales requiere sistema completo"
        ],
        "how": [
          "Fase 1: Análisis → Entender proceso actual y volúmenes",
          "Fase 2: Diseño del Pipeline → Optimizar para eficiencia y escalabilidad",
          "Fase 3: Implementación → Código performante con streaming",
          "Fase 4: Testing de Volumen → Validar con datos reales (GB, TB, PB)",
          "Fase 5: Deployment → Scheduling, monitoring y alertas"
        ],
        "phases": [
          {
            "id": "phase-analysis",
            "name": "Análisis del Proceso y Volumetría",
            "order": 1,
            "description": "Entender en profundidad el proceso de negocio actual, fuentes de datos, transformaciones requeridas y volúmenes esperados",
            "duration": "10-15% del proyecto (1-2 semanas)",
            "activities": [
              "Documentar proceso de negocio actual (AS-IS)",
              "Identificar todas las fuentes de datos (archivos, bases de datos, APIs)",
              "Definir transformaciones requeridas (lógica de negocio)",
              "Determinar outputs esperados (formatos, destinos)",
              "Estimar volúmenes actuales y proyectados (registros, GB, crecimiento anual)",
              "Identificar requisitos de frecuencia (diario, semanal, on-demand)",
              "Analizar restricciones de ventanas de tiempo (batch window)",
              "Identificar dependencias con otros procesos",
              "Definir SLAs (Service Level Agreements) de processing time"
            ],
            "inputs": [
              "Descripción del proceso de negocio",
              "Acceso a sistemas fuente (lectura)",
              "Estadísticas de volúmenes históricos",
              "Restricciones de infraestructura"
            ],
            "outputs": [
              "Documento de Análisis de Proceso (5-10 páginas)",
              "Modelo de datos entrada/salida",
              "Estimaciones de volúmenes (actuales y proyectados)",
              "Definición de SLAs (tiempo máximo de procesamiento)",
              "Identificación de casos edge (datos corruptos, volúmenes pico)"
            ],
            "deliverables": [
              {
                "name": "Documento de Análisis del Proceso",
                "template": "tpl-001",
                "required": true,
                "reviewedBy": [
                  "Experto de Negocio",
                  "Arquitecto de Datos"
                ]
              }
            ],
            "gate": {
              "name": "Analysis Approval",
              "criteria": [
                "Proceso de negocio entendido completamente",
                "Todas las fuentes de datos identificadas y accesibles",
                "Transformaciones definidas con lógica de negocio clara",
                "Volúmenes estimados con evidencia histórica",
                "SLAs acordados con stakeholders"
              ],
              "decision": "GO / CLARIFICAR REQUISITOS"
            },
            "keyStakeholders": [
              "Experto de Negocio",
              "Arquitecto de Datos",
              "Operaciones IT"
            ]
          },
          {
            "id": "phase-pipeline-design",
            "name": "Diseño del Pipeline de Procesamiento",
            "order": 2,
            "description": "Diseñar flujo de procesamiento optimizado para eficiencia, manejo de errores y escalabilidad",
            "duration": "15-20% del proyecto (2-3 semanas)",
            "activities": [
              "Diseñar pipeline ETL (Extract, Transform, Load) completo",
              "Definir stages del pipeline (extracción → transformación → carga → validación)",
              "Diseñar estrategia de procesamiento (batch vs streaming, tamaño de chunk)",
              "Diseñar manejo de errores y reintentos (retry logic, dead letter queue)",
              "Diseñar checkpointing para reinicio desde fallo",
              "Diseñar particionamiento de datos para paralelización",
              "Optimizar queries de base de datos (índices, particionamiento)",
              "Diseñar logging y auditoría (qué se registra, dónde, por cuánto tiempo)",
              "Definir métricas de performance (registros/segundo, GB/hora)",
              "Diseñar monitoreo y alertas"
            ],
            "inputs": [
              "Documento de Análisis aprobado",
              "Arquitectura de infraestructura disponible",
              "Estándares de desarrollo de la organización",
              "Herramientas disponibles (Apache Airflow, Apache Spark, etc.)"
            ],
            "outputs": [
              "Diagrama de flujo del pipeline (Diagrama de Actividad UML)",
              "Diseño de modelo de datos (tablas staging, transformación, output)",
              "Especificación de manejo de errores",
              "Diseño de checkpoints y estrategia de reinicio",
              "Plan de optimización de performance",
              "Especificación de logging y auditoría"
            ],
            "deliverables": [
              {
                "name": "Diseño del Pipeline ETL",
                "template": "tpl-006",
                "required": true,
                "reviewedBy": [
                  "Arquitecto de Datos",
                  "Equipo de Desarrollo"
                ]
              },
              {
                "name": "Diagrama de Flujo del Proceso",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Experto de Negocio",
                  "Arquitecto"
                ]
              }
            ],
            "gate": {
              "name": "Design Review",
              "criteria": [
                "Pipeline satisface requisitos funcionales",
                "Diseño optimizado para volúmenes esperados",
                "Manejo de errores robusto",
                "Estrategia de reinicio desde fallo definida",
                "Logging y auditoría cumplen requisitos de compliance"
              ],
              "decision": "GO / ITERAR DISEÑO"
            },
            "keyStakeholders": [
              "Arquitecto de Datos",
              "Equipo de Desarrollo",
              "Operaciones"
            ]
          },
          {
            "id": "phase-implementation",
            "name": "Implementación del Pipeline",
            "order": 3,
            "description": "Desarrollo del código de procesamiento con énfasis en eficiencia y robustez",
            "duration": "40-50% del proyecto (5-8 semanas)",
            "activities": [
              "Implementar extracción de datos (conectores a fuentes)",
              "Implementar transformaciones (lógica de negocio)",
              "Implementar carga de datos (escritura a destinos)",
              "Implementar checkpointing y reinicio",
              "Implementar manejo de errores (try-catch, retry, alertas)",
              "Implementar logging y auditoría",
              "Optimizar queries de base de datos",
              "Implementar procesamiento en batch (no row-by-row)",
              "Implementar paralelización (si volumen lo requiere)",
              "Testing unitario de cada stage del pipeline",
              "Testing de integración entre stages"
            ],
            "inputs": [
              "Diseño del pipeline aprobado",
              "Acceso a ambientes de desarrollo y staging",
              "Datos de prueba (subset de producción)",
              "Herramientas de desarrollo (Python, SQL, Airflow, etc.)"
            ],
            "outputs": [
              "Código fuente del pipeline versionado",
              "Scripts de deployment (DAGs de Airflow, cron jobs, etc.)",
              "Pruebas unitarias e integración",
              "Documentación técnica (README, diagramas)",
              "Scripts de configuración (variables de entorno, conexiones)"
            ],
            "deliverables": [
              {
                "name": "Código del Pipeline ETL",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Líder Técnico",
                  "Code Reviewer"
                ]
              },
              {
                "name": "Documentación Técnica",
                "template": "tpl-006",
                "required": true,
                "reviewedBy": [
                  "Equipo de Operaciones"
                ]
              }
            ],
            "gate": {
              "name": "Code Complete",
              "criteria": [
                "Todos los stages del pipeline implementados",
                "Pruebas unitarias pasando (cobertura >80%)",
                "Código revisado y aprobado",
                "Manejo de errores implementado y probado",
                "Logging y auditoría funcionando"
              ],
              "decision": "GO TO TESTING / FIX DEFECTS"
            },
            "keyStakeholders": [
              "Líder Técnico",
              "Equipo de Desarrollo"
            ]
          },
          {
            "id": "phase-volume-testing",
            "name": "Pruebas de Volumen y Performance",
            "order": 4,
            "description": "Testing exhaustivo con volúmenes reales y validación de performance",
            "duration": "20-25% del proyecto (3-4 semanas)",
            "activities": [
              "Preparar datasets de prueba (subsets de producción, anonimizados)",
              "Ejecutar pruebas con volúmenes reales (100%, 150%, 200% de volumen esperado)",
              "Medir performance (tiempo total, throughput en registros/segundo)",
              "Validar correctitud de outputs (comparar contra resultados esperados)",
              "Probar manejo de errores (inyectar datos corruptos, simular fallos de BD)",
              "Probar reinicio desde checkpoints (matar proceso a mitad y reiniciar)",
              "Probar procesamiento de volúmenes pico (black friday, fin de mes)",
              "Optimización de performance (índices, batch size, paralelización)",
              "Pruebas de regresión (asegurar que optimizaciones no rompan funcionalidad)",
              "Validación de logging y auditoría (revisar logs generados)"
            ],
            "inputs": [
              "Código del pipeline completo",
              "Datos de prueba (subset de producción, anonimizado)",
              "Ambiente de testing (similar a producción)",
              "Casos de prueba derivados de requisitos"
            ],
            "outputs": [
              "Reportes de pruebas de volumen (tiempo, throughput, errores)",
              "Resultados validados (comparación con outputs esperados)",
              "Reportes de pruebas de errores y reinicio",
              "Métricas de performance documentadas",
              "Optimizaciones implementadas y validadas"
            ],
            "deliverables": [
              {
                "name": "Reporte de Pruebas de Volumen",
                "template": "tpl-011",
                "required": true,
                "reviewedBy": [
                  "Líder Técnico",
                  "Experto de Negocio"
                ]
              },
              {
                "name": "Validación de Outputs",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Experto de Negocio"
                ]
              }
            ],
            "gate": {
              "name": "Performance Acceptance",
              "criteria": [
                "Performance satisface SLAs (tiempo de procesamiento dentro de ventana)",
                "Throughput adecuado para volúmenes proyectados",
                "Outputs correctos validados por experto de negocio",
                "Manejo de errores funciona correctamente",
                "Reinicio desde checkpoint funciona correctamente",
                "Logging y auditoría completos"
              ],
              "decision": "GO TO PRODUCTION / OPTIMIZE & RE-TEST"
            },
            "keyStakeholders": [
              "Líder Técnico",
              "Experto de Negocio",
              "Operaciones"
            ]
          },
          {
            "id": "phase-deployment",
            "name": "Deployment y Operacionalización",
            "order": 5,
            "description": "Despliegue a producción, configuración de scheduling y monitoreo",
            "duration": "10-15% del proyecto (1-2 semanas) + operación continua",
            "activities": [
              "Deployment de código a ambiente de producción",
              "Configurar scheduling (cron, Airflow scheduler, Task Scheduler)",
              "Configurar monitoreo (métricas de performance, alertas)",
              "Configurar alertas (fallo de job, tiempo excedido, errores críticos)",
              "Configurar dashboards (Grafana, Kibana, herramienta corporativa)",
              "Documentar procedimientos operacionales (runbook)",
              "Capacitar a equipo de operaciones (cómo monitorear, troubleshoot)",
              "Ejecutar primer run en producción (con supervisión)",
              "Validar outputs del primer run",
              "Handoff a operaciones (transferencia de responsabilidad)"
            ],
            "inputs": [
              "Pipeline probado y aprobado",
              "Ambiente de producción preparado",
              "Credenciales y permisos configurados",
              "Plan de deployment"
            ],
            "outputs": [
              "Pipeline operando en producción según schedule",
              "Monitoreo y alertas funcionando",
              "Dashboards operacionales",
              "Documentación operacional (runbook)",
              "Equipo de operaciones capacitado",
              "Primeros runs exitosos en producción"
            ],
            "deliverables": [
              {
                "name": "Runbook Operacional",
                "template": "tpl-006",
                "required": true,
                "reviewedBy": [
                  "Equipo de Operaciones"
                ]
              },
              {
                "name": "Dashboard de Monitoreo",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Operaciones",
                  "Management"
                ]
              }
            ],
            "gate": {
              "name": "Go-Live",
              "criteria": [
                "Pipeline deployado correctamente en producción",
                "Scheduling configurado y validado",
                "Monitoreo y alertas funcionando",
                "Primer run exitoso en producción",
                "Equipo de operaciones capacitado",
                "Runbook completo y revisado"
              ],
              "decision": "GO-LIVE / FIX & RE-DEPLOY"
            },
            "keyStakeholders": [
              "Operaciones",
              "Líder Técnico",
              "Management"
            ]
          }
        ],
        "whenToUse": [
          "✅ Procesamiento por lotes (batch) de grandes volúmenes de datos",
          "✅ Procesos de negocio bien definidos y estables",
          "✅ ETL (Extract, Transform, Load) entre sistemas",
          "✅ Procesamiento nocturno o periódico (diario, semanal)",
          "✅ Transformaciones de datos que no requieren interacción en tiempo real",
          "✅ Performance y eficiencia son requisitos críticos",
          "✅ Volúmenes grandes (GB, TB, PB) que requieren optimización",
          "✅ Necesidad de auditoría completa (qué se procesó, cuándo, resultado)",
          "✅ Procesamiento que puede fallar y reiniciarse desde checkpoint",
          "✅ Sistemas legacy que generan archivos planos o dumps de BD"
        ],
        "whenNotToUse": [
          "❌ Procesamiento en tiempo real o streaming (usar Kafka, Spark Streaming)",
          "❌ Procesos de negocio volátiles o mal entendidos",
          "❌ Necesidad de respuesta inmediata (usar sistemas transaccionales)",
          "❌ Volúmenes pequeños que no requieren optimización (procesamiento simple)",
          "❌ Interacción de usuario en tiempo real (usar APIs síncronas)",
          "❌ Procesamiento ad-hoc o exploratorio (usar notebooks: Jupyter, Databricks)",
          "❌ Eventos que deben procesarse inmediatamente (usar event-driven architecture)",
          "❌ Sistemas donde la latencia es crítica (<1 segundo)",
          "❌ Procesamiento que requiere feedback inmediato al usuario"
        ],
        "advantages": [
          "✅ Optimización anticipada de performance (diseño antes de implementar)",
          "✅ Manejo eficiente de grandes volúmenes (batch, streaming, paralelización)",
          "✅ Robustez mediante checkpointing y reinicio (tolera fallos)",
          "✅ Auditoría completa (trazabilidad de qué se procesó)",
          "✅ Scheduling automatizado (desatendido, ejecuta en horarios óptimos)",
          "✅ Monitoreo proactivo (alertas antes de que usuarios reporten problemas)",
          "✅ Costo-eficiencia (procesa offline, no requiere recursos 24/7)",
          "✅ Testing exhaustivo con volúmenes reales antes de producción",
          "✅ Separación de preocupaciones (extracción, transformación, carga separados)"
        ],
        "disadvantages": [
          "❌ Latencia alta (resultados disponibles horas/días después de generados los datos)",
          "❌ No apto para procesamiento en tiempo real",
          "❌ Ventanas de procesamiento limitadas (batch window: 2-4 horas típicamente)",
          "❌ Debugging complejo (logs de miles/millones de registros)",
          "❌ Testing completo requiere datos de producción (difícil replicar volumetría)",
          "❌ Cambios en proceso requieren rehacer todo el pipeline (no iterativo)",
          "❌ Requiere expertise en optimización de BD y procesamiento de datos",
          "❌ Monitoreo y alerting críticos (fallos pueden no detectarse hasta siguiente día)"
        ],
        "changeManagement": {
          "approach": "Change Control con Testing de Volumen Obligatorio",
          "description": "Cambios en pipeline de batch requieren aprobación y re-testing con volúmenes reales antes de deployment a producción",
          "process": [
            {
              "step": 1,
              "name": "Solicitud de Cambio",
              "action": "Documentar cambio propuesto con justificación de negocio o técnica",
              "responsible": "Desarrollador o Experto de Negocio",
              "artifacts": [
                "Change Request con descripción detallada"
              ],
              "timeframe": "1 día"
            },
            {
              "step": 2,
              "name": "Análisis de Impacto",
              "action": "Analizar impacto en performance, correctitud de outputs, dependencias",
              "responsible": "Líder Técnico",
              "artifacts": [
                "Análisis de impacto (performance, funcionalidad, riesgo)"
              ],
              "timeframe": "2-3 días"
            },
            {
              "step": 3,
              "name": "Aprobación",
              "action": "Comité de cambios revisa y aprueba/rechaza",
              "responsible": "Change Control Board (Líder Técnico, Experto de Negocio, Operaciones)",
              "artifacts": [
                "Decisión documentada con justificación"
              ],
              "timeframe": "1 semana (reunión semanal)"
            },
            {
              "step": 4,
              "name": "Implementación",
              "action": "Desarrollar cambio en ambiente de desarrollo",
              "responsible": "Desarrollador",
              "artifacts": [
                "Código modificado",
                "Pruebas unitarias actualizadas"
              ],
              "timeframe": "Según estimación"
            },
            {
              "step": 5,
              "name": "Testing de Volumen",
              "action": "OBLIGATORIO: Re-ejecutar pruebas de volumen completas en staging",
              "responsible": "QA/Desarrollador",
              "artifacts": [
                "Reporte de pruebas de volumen",
                "Validación de outputs"
              ],
              "timeframe": "3-5 días"
            },
            {
              "step": 6,
              "name": "Deployment a Producción",
              "action": "Deployment controlado con rollback plan",
              "responsible": "Operaciones",
              "artifacts": [
                "Pipeline actualizado en producción",
                "Runbook actualizado"
              ],
              "timeframe": "1 día (ventana de deployment)"
            },
            {
              "step": 7,
              "name": "Monitoreo Post-Deployment",
              "action": "Supervisión de primeros runs post-cambio",
              "responsible": "Operaciones + Líder Técnico",
              "artifacts": [
                "Logs de ejecución",
                "Validación de outputs"
              ],
              "timeframe": "1 semana (primeros 3-5 runs)"
            }
          ],
          "tools": [
            "Jira (tracking de cambios)",
            "Git (control de versiones)",
            "Apache Airflow (DAG versionado)",
            "Ambiente de Staging (réplica de producción)"
          ],
          "ccbComposition": [
            "Líder Técnico",
            "Experto de Negocio (valida correctitud de outputs)",
            "Operaciones (valida runbook y monitoreo)"
          ],
          "frequency": "Semanal o bi-semanal",
          "timeExpectation": "Cambios menores: 2 semanas. Cambios mayores: 4-6 semanas (incluye re-testing completo)"
        },
        "iterationStrategy": {
          "type": "none",
          "description": "Modelo secuencial sin iteraciones: diseño completo del pipeline antes de implementar, testing exhaustivo antes de producción"
        },
        "tooling": {
          "required": [
            "Lenguaje de scripting (Python, SQL)",
            "Base de datos (PostgreSQL, SQL Server, Oracle)",
            "Control de versiones (Git)",
            "Scheduler (Cron, Apache Airflow, Azure Data Factory)"
          ],
          "recommended": [
            "Apache Airflow (orchestration de pipelines)",
            "Apache Spark (procesamiento distribuido para volúmenes muy grandes)",
            "Pandas (procesamiento de datos en Python)",
            "Great Expectations (validación de calidad de datos)",
            "dbt (transformaciones SQL versionadas)",
            "Grafana / Kibana (dashboards de monitoreo)",
            "Sentry / Datadog (alertas)"
          ]
        },
        "references": {
          "chapter": "Capítulo 2",
          "sections": [
            "Sección 2.1.1: Modelo en Cascada",
            "Capítulo 6: Arquitectura de Software (Patrón Tubería y Filtro)"
          ],
          "relatedConcepts": [
            "concept-waterfall",
            "concept-pipeline-architecture",
            "concept-batch-processing"
          ]
        }
      },
      "methodology": {
        "name": "Waterfall Model (Plan-Driven Development)",
        "description": "Modelo secuencial lineal donde cada fase debe completarse antes de iniciar la siguiente. Cada fase tiene entradas, procesos y salidas bien definidos, con énfasis en planificación upfront, documentación exhaustiva y predictibilidad del cronograma y presupuesto. Apropiado para proyectos con requisitos bien definidos y estables desde el inicio, donde los cambios son costosos y deben minimizarse. El modelo fue originalmente propuesto por Winston Royce en 1970 como ejemplo de cómo NO hacer desarrollo (porque carecía de feedback loops), pero la industria lo adoptó como modelo estándar durante las siguientes décadas. Las fases típicas son: Requirements → Design → Implementation → Testing → Deployment → Maintenance, con verificación y validación formal al final de cada fase mediante gates de aprobación.",
        "origin": {
          "creator": "Winston W. Royce (adaptación de modelo original de ingeniería tradicional)",
          "year": 1970,
          "context": "Propuesto en el paper 'Managing the Development of Large Software Systems' presentado en IEEE WESCON. Irónicamente, Royce propuso el modelo como ejemplo de un enfoque deficiente (sin iteraciones ni feedback loops), pero la industria lo adoptó literalmente como estándar durante décadas, especialmente en proyectos gubernamentales y de defensa que requerían documentación exhaustiva y auditorías formales."
        },
        "principles": [
          "Fases secuenciales estrictas: Requirements → Design → Implementation → Testing → Deployment → Maintenance (cada fase debe completarse antes de la siguiente)",
          "Documentación formal exhaustiva en cada fase: SRS (Software Requirements Specification), SDD (Software Design Document), Test Plans, User Manuals, etc.",
          "Verificación y validación al final de cada fase mediante gates con criterios de entrada/salida (stage gates)",
          "Cambios son costosos y requieren volver a fases anteriores (change control formal con CCB - Change Control Board)",
          "Predictibilidad upfront: tiempo, costo y alcance estimados al inicio con alta precisión basada en requirements completos",
          "Entrega única al final del proyecto (big-bang deployment) después de completar todas las fases"
        ],
        "differentiators": [
          "vs Ágil: Waterfall prioriza documentación formal y planificación upfront exhaustiva, mientras Ágil prioriza working software incremental y adaptación continua a cambios",
          "vs Incremental: Waterfall entrega una sola vez al final (big-bang), mientras Incremental entrega múltiples veces con funcionalidad incremental",
          "vs Espiral: Waterfall no tiene gestión explícita de riesgos ni construcción de prototipos obligatorios, mientras Espiral centra cada ciclo en análisis de riesgos"
        ],
        "references": {
          "chapter": "chapter-2",
          "sections": [
            "2.1 Plan-driven and agile development",
            "2.2 The waterfall model"
          ],
          "externalResources": [
            "Royce, W. W. (1970). Managing the Development of Large Software Systems. Proceedings of IEEE WESCON",
            "Sommerville, I. (2016). Software Engineering (10th ed.), Chapter 2"
          ]
        }
      },
      "modeling": {
        "notations": [
          {
            "name": "UML",
            "description": "UML para documentar flujos de procesamiento batch y estructura de jobs.",
            "diagrams": [
              "Activity Diagram (flujos ETL)",
              "Class Diagram (estructura jobs)",
              "Deployment Diagram (infraestructura batch)"
            ],
            "whenToUse": "Documentar flujos complejos de ETL, dependencias entre jobs y estructura de datos procesados",
            "tools": [
              "Lucidchart",
              "PlantUML",
              "Visual Paradigm"
            ]
          },
          {
            "name": "BPMN (Business Process Model and Notation)",
            "description": "Notación estándar para modelado de procesos de negocio (swimlanes, eventos, gateways).",
            "diagrams": [
              "BPMN Process Diagram",
              "BPMN Collaboration Diagram"
            ],
            "whenToUse": "Sistemas batch que automatizan procesos de negocio complejos (procesamiento nómina, conciliación bancaria, reporting)",
            "tools": [
              "Camunda Modeler",
              "Bizagi",
              "Lucidchart",
              "Draw.io"
            ]
          }
        ],
        "primaryFocus": "Modelado de flujos de procesamiento batch, dependencias entre jobs y manejo de errores/reintento",
        "references": {
          "chapter": "chapter-5",
          "sections": [
            "5.4 Behavioral models"
          ]
        }
      },
      "architecture": {
        "patterns": [
          {
            "name": "Pipeline (Pipe-and-Filter)",
            "description": "Procesamiento en etapas secuenciales donde salida de una etapa es entrada de la siguiente (ETL pattern).",
            "advantages": [
              "Fácil agregar/remover etapas (modularidad)",
              "Cada etapa puede testearse independientemente",
              "Procesamiento paralelizable por etapa (múltiples workers por etapa)",
              "Reusabilidad de filtros (misma etapa en múltiples pipelines)"
            ],
            "disadvantages": [
              "Performance limitada por etapa más lenta (cuello de botella)",
              "Overhead de pasar datos entre etapas (serialización/deserialización)",
              "Debugging complejo (error en etapa N afecta etapa N+1)"
            ],
            "whenToUse": "ETL (Extract-Transform-Load), procesamiento de datos en múltiples pasos (parsear CSV → validar → transformar → cargar DB)",
            "tradeoffs": "Modularidad y testabilidad vs Performance (overhead de pasar datos entre etapas)"
          },
          {
            "name": "Batch Layer (Lambda Architecture)",
            "description": "Procesamiento batch separado de real-time (batch genera vistas pre-computadas, real-time para queries ad-hoc).",
            "advantages": [
              "Tolerancia a fallos (batch puede re-procesar histórico si hay errores)",
              "Escalabilidad (batch procesa grandes volúmenes offline sin afectar sistema productivo)",
              "Consistencia eventual (batch corrige errores de procesamiento real-time)"
            ],
            "disadvantages": [
              "Complejidad de mantener 2 pipelines (batch + real-time)",
              "Latencia alta (vistas batch se actualizan cada X horas, no real-time)",
              "Duplicación de lógica de negocio (batch y real-time pueden tener código similar)"
            ],
            "whenToUse": "Sistemas de reporting/analytics con grandes volúmenes (analytics de e-commerce, dashboards ejecutivos, data warehousing)",
            "tradeoffs": "Escalabilidad y tolerancia a fallos vs Latencia (vistas batch no son real-time)"
          }
        ],
        "style": "Batch/Offline processing (no hay usuarios interactivos esperando respuesta)",
        "qualityAttributes": {
          "scalability": "Very High - Escalamiento horizontal con workers paralelos. Procesamiento de millones de registros. Apache Spark, Hadoop para big data.",
          "maintainability": "Medium - Lógica de ETL puede volverse compleja. Importante documentar dependencias entre jobs (DAG graphs). Airflow/Luigi facilitan orquestación.",
          "performance": "Very High - Procesamiento optimizado para throughput (no latencia). Paralelización crítica. Batch windows nocturnos típicos.",
          "security": "Medium-High - Acceso a datos sensibles durante ETL. Encriptación en tránsito (TLS) y en reposo (disk encryption). Logs de auditoría."
        },
        "references": {
          "chapter": "chapter-6",
          "sections": [
            "6.4 Architectural patterns"
          ]
        }
      },
      "timeline": [
        {
          "week": "1-2",
          "phase": "Análisis",
          "tasks": [
            "Entender proceso de negocio actual",
            "Identificar fuentes de datos",
            "Definir outputs esperados",
            "Estimar volúmenes"
          ]
        },
        {
          "week": "3-4",
          "phase": "Diseño",
          "tasks": [
            "Diseño de flujo de procesamiento",
            "Modelo de datos",
            "Arquitectura de deployment",
            "Plan de performance"
          ]
        },
        {
          "week": "5-8",
          "phase": "Implementación",
          "tasks": [
            "Desarrollar ETL",
            "Testing con datos de prueba",
            "Optimización de queries"
          ]
        },
        {
          "week": "9-10",
          "phase": "Testing",
          "tasks": [
            "Testing con volúmenes reales",
            "Performance tuning",
            "Validación de outputs"
          ]
        },
        {
          "week": "11-12",
          "phase": "Deployment",
          "tasks": [
            "Configurar scheduling",
            "Setup de monitoreo",
            "Documentación operacional",
            "Capacitación a operadores"
          ]
        }
      ],
      "avoid": [
        "Procesar row-by-row (usar batch)",
        "Cargar todo en memoria (usar streaming)",
        "No considerar failover",
        "Sin logging/auditoría",
        "No testear con volúmenes reales",
        "Queries sin optimizar"
      ],
      "templates": [
        "tpl-001",
        "tpl-006",
        "tpl-010"
      ],
      "chapters": [
        2,
        5,
        6
      ]
    },
    "rec-011": {
      "id": "rec-011",
      "title": "Recolección de Datos → IoT",
      "path": [
        "IoT/Datos"
      ],
      "pathDescription": "Recolección de Datos → IoT/Sensores → Confiabilidad 24/7 → Condiciones Adversas",
      "process": {
        "name": "Incremental Development",
        "type": "incremental",
        "description": "Desarrollo iterativo con entregas incrementales de funcionalidad IoT, comenzando con MVP edge-only y escalando hacia integración cloud completa. Cada iteración entrega un sistema desplegable y funcional en producción real.",
        "chapter": 2,
        "phases": [
          {
            "id": "phase-iot-iter1",
            "name": "Iteración 1: MVP Edge-Only",
            "order": 1,
            "description": "Sistema básico embebido local sin dependencia de cloud. Valida hardware, firmware básico y control local.",
            "duration": "3-4 semanas",
            "activities": [
              "Implementar lectura de sensor básico (temperatura/humedad)",
              "Desarrollar lógica de control local (if-then rules sin cloud)",
              "Implementar actuador simple (LED, relay, motor)",
              "Crear interfaz serial/USB para debug y configuración",
              "Testing en condiciones controladas (laboratorio)",
              "Desplegar en 1-2 dispositivos piloto en campo"
            ],
            "inputs": [
              "Especificación de hardware (sensores, actuadores, MCU)",
              "Requisitos funcionales básicos (qué medir, qué controlar)",
              "Constraints de power y conectividad"
            ],
            "outputs": [
              "Firmware embebido funcional (FreeRTOS/Zephyr)",
              "Esquemático de PCB validado",
              "Documentación de troubleshooting básico"
            ],
            "deliverables": [
              {
                "name": "Dispositivo IoT funcional con sensor + actuador + lógica local",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Technical Lead",
                  "Product Owner"
                ]
              },
              {
                "name": "Código fuente versionado (Git)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Technical Lead"
                ]
              },
              {
                "name": "Manual de instalación básico",
                "template": "tpl-006",
                "required": true,
                "reviewedBy": [
                  "Product Owner"
                ]
              }
            ],
            "gate": {
              "name": "MVP Acceptance",
              "criteria": [
                "Dispositivo funciona 72h continuas sin fallas",
                "Lectura de sensor dentro de margen de error aceptable (<5%)",
                "Actuador responde correctamente a lógica local",
                "Consumo energético dentro de especificación"
              ],
              "decision": "GO / NO-GO / ITERAR"
            },
            "keyStakeholders": [
              "Embedded Engineer",
              "Hardware Engineer",
              "QA Tester"
            ]
          },
          {
            "id": "phase-iot-iter2",
            "name": "Iteración 2: Conectividad Cloud Básica",
            "order": 2,
            "description": "Agregar telemetría a cloud y dashboard de monitoreo en tiempo real. Valida conectividad, visualización y almacenamiento histórico.",
            "duration": "4-6 semanas",
            "activities": [
              "Implementar cliente MQTT para telemetría (pub/sub)",
              "Conectar a AWS IoT Core / Azure IoT Hub",
              "Crear dashboard web básico (datos en tiempo real con WebSockets)",
              "Implementar almacenamiento histórico (TimescaleDB/InfluxDB)",
              "Agregar manejo de conectividad intermitente (buffering local en flash)",
              "Testing con conexión WiFi/4G variable (desconexiones simuladas)",
              "Desplegar en 5-10 dispositivos en diferentes ubicaciones"
            ],
            "inputs": [
              "Firmware de Iteración 1 (estable)",
              "Infraestructura cloud aprovisionada (AWS/Azure account)",
              "Especificación de dashboard (KPIs a visualizar)"
            ],
            "outputs": [
              "Sistema de telemetría bidireccional (device → cloud, cloud → device)",
              "Dashboard web con gráficos en tiempo real",
              "Base de datos con histórico de 30 días"
            ],
            "deliverables": [
              {
                "name": "Sistema IoT con visualización remota de datos",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Product Owner",
                  "DevOps Lead"
                ]
              },
              {
                "name": "Documentación de API de telemetría",
                "template": "tpl-003",
                "required": true,
                "reviewedBy": [
                  "Backend Engineer"
                ]
              },
              {
                "name": "Runbook de troubleshooting de conectividad",
                "template": "tpl-006",
                "required": true,
                "reviewedBy": [
                  "DevOps"
                ]
              }
            ],
            "gate": {
              "name": "Cloud Integration Acceptance",
              "criteria": [
                "99% de mensajes MQTT entregados exitosamente en 24h",
                "Dashboard muestra datos con <5s de latencia",
                "Buffering local funciona correctamente ante desconexión de 1h",
                "Zero data loss en escenarios de desconexión y reconexión"
              ],
              "decision": "GO / FIX & RE-TEST"
            },
            "keyStakeholders": [
              "Backend Engineer",
              "Frontend Engineer",
              "DevOps",
              "Embedded Engineer"
            ]
          },
          {
            "id": "phase-iot-iter3",
            "name": "Iteración 3: Features Avanzadas",
            "order": 3,
            "description": "OTA updates, analytics avanzados, alertas y seguridad. Valida escalabilidad, seguridad y rollback automático.",
            "duration": "5-7 semanas",
            "activities": [
              "Implementar OTA firmware updates (Balena/AWS IoT Jobs con rollback)",
              "Agregar edge computing (predicciones ML on-device con TensorFlow Lite)",
              "Crear sistema de alertas configurables (umbrales, webhooks, emails)",
              "Implementar analytics avanzado (anomaly detection, predictive maintenance)",
              "Agregar autenticación y encriptación (TLS 1.3, device certificates X.509)",
              "Testing de rollback automático ante firmware corrupto o crasheante",
              "Desplegar en 50+ dispositivos con phased rollout (10% → 50% → 100%)"
            ],
            "inputs": [
              "Sistema de Iteración 2 (estable en producción)",
              "Modelos ML entrenados (edge-compatible, <500KB)",
              "Políticas de seguridad y compliance (encriptación, autenticación)"
            ],
            "outputs": [
              "Sistema de OTA updates con rollback automático",
              "Edge ML inference funcionando (<100ms latencia)",
              "Sistema de alertas con >95% accuracy"
            ],
            "deliverables": [
              {
                "name": "Sistema IoT con actualizaciones remotas y machine learning",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Technical Lead",
                  "Security Engineer"
                ]
              },
              {
                "name": "Documentación de security best practices",
                "template": "tpl-003",
                "required": true,
                "reviewedBy": [
                  "Security Engineer"
                ]
              },
              {
                "name": "Playbook de incident response (rollback, hotfixes)",
                "template": "tpl-006",
                "required": true,
                "reviewedBy": [
                  "DevOps",
                  "SRE"
                ]
              }
            ],
            "gate": {
              "name": "Advanced Features Acceptance",
              "criteria": [
                "OTA update exitoso en 100% de dispositivos de test (sin bricks)",
                "Rollback automático funciona ante firmware crasheante en <2 min",
                "Edge ML inference con >90% accuracy en dataset de validación",
                "Zero vulnerabilidades críticas en security audit",
                "Alertas generadas con <5% de falsos positivos"
              ],
              "decision": "GO / FIX SECURITY ISSUES"
            },
            "keyStakeholders": [
              "ML Engineer",
              "Security Engineer",
              "Embedded Engineer",
              "DevOps"
            ]
          },
          {
            "id": "phase-iot-iter4",
            "name": "Iteración 4: Escala y Optimización",
            "order": 4,
            "description": "Optimización de recursos, fleet management multi-dispositivo, observability completa y deployment a producción masiva.",
            "duration": "6-8 semanas",
            "activities": [
              "Optimizar consumo energético (sleep modes, duty cycles, wake-on-event)",
              "Implementar sincronización multi-dispositivo (mesh networks opcional)",
              "Agregar fleet management (grouping, bulk commands, shadowing)",
              "Crear herramientas de diagnóstico remoto (logs, metrics, health checks)",
              "Implementar logging y observability (Prometheus, Grafana, alertas SRE)",
              "Field testing en condiciones extremas (temperatura -20°C a 60°C, humedad 90%, vibración)",
              "Desplegar en producción masiva (1000+ dispositivos con monitoreo 24/7)"
            ],
            "inputs": [
              "Sistema de Iteración 3 (validado en 50+ dispositivos)",
              "SLOs definidos (uptime >99.5%, latency <100ms)",
              "Plan de escalamiento (1000+ dispositivos)"
            ],
            "outputs": [
              "Sistema optimizado con consumo <50% vs Iteración 3",
              "Fleet management dashboard (health, versions, comandos bulk)",
              "Observability completa (logs centralizados, métricas SRE)"
            ],
            "deliverables": [
              {
                "name": "Sistema IoT production-ready con miles de dispositivos",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Product Owner",
                  "SRE Lead"
                ]
              },
              {
                "name": "SRE runbook completo (on-call, incident response)",
                "template": "tpl-006",
                "required": true,
                "reviewedBy": [
                  "SRE Lead",
                  "DevOps"
                ]
              },
              {
                "name": "Documentación de escalamiento y disaster recovery",
                "template": "tpl-003",
                "required": true,
                "reviewedBy": [
                  "SRE Lead",
                  "Technical Lead"
                ]
              }
            ],
            "gate": {
              "name": "Production Ready",
              "criteria": [
                "Sistema funciona 99.5% uptime en 1 mes con 100+ dispositivos",
                "Consumo energético <50mA promedio (battery life >6 meses)",
                "Fleet management controla 1000+ dispositivos sin degradación",
                "Observability detecta incidentes en <5 min (MTTD <5min)",
                "Field testing exitoso en condiciones extremas sin fallas"
              ],
              "decision": "GO TO PRODUCTION / OPTIMIZE & RE-TEST"
            },
            "keyStakeholders": [
              "SRE Engineer",
              "DevOps",
              "Embedded Engineer",
              "QA Tester",
              "Support Team"
            ]
          }
        ],
        "whenToUse": [
          "✅ Sistemas IoT con sensores y actuadores distribuidos",
          "✅ Deployment en condiciones adversas (temperatura extrema, humedad, polvo)",
          "✅ Conectividad intermitente (WiFi/cellular no garantizada 100%)",
          "✅ Power management crítico (batería, solar, power limitado)",
          "✅ Necesidad de operación 24/7 sin mantenimiento frecuente",
          "✅ Acceso físico difícil post-deployment (campo abierto, alturas, zonas remotas)",
          "✅ Procesamiento Edge necesario (latencia, ancho de banda, privacidad)",
          "✅ Necesidad de OTA updates (firmware updates remotos)",
          "✅ Monitoreo y analytics en Cloud (dashboard, alertas, big data)",
          "✅ Escalabilidad requerida (decenas a miles de dispositivos)"
        ],
        "whenNotToUse": [
          "❌ Conectividad permanente y confiable disponible (usar sistemas Cloud tradicionales)",
          "❌ Power ilimitado (AC power siempre disponible) → optimización de power innecesaria",
          "❌ Acceso físico fácil y frecuente → OTA updates menos críticos",
          "❌ Procesamiento en tiempo real crítico (<100ms) → Edge computing puede no ser suficiente",
          "❌ Volúmenes muy pequeños (<10 dispositivos) → overhead de IoT platform puede no justificarse",
          "❌ Condiciones ambientales controladas (indoor, temperatura estable) → hardware consumer-grade suficiente",
          "❌ Prototipado rápido sin plan de producción → usar soluciones quick & dirty",
          "❌ Requisitos volátiles (hardware cambia frecuentemente) → hardware define arquitectura, difícil cambiar"
        ],
        "advantages": [
          "✅ Operación 24/7 sin mantenimiento frecuente",
          "✅ Power management optimizado (batería dura meses/años)",
          "✅ Resiliente a conectividad intermitente (buffering local)",
          "✅ Escalable (de 10 a 10,000 dispositivos con misma arquitectura)",
          "✅ OTA updates permite correcciones post-deployment",
          "✅ Edge computing reduce latencia y ancho de banda Cloud",
          "✅ Cloud backend centralizado para analytics y dashboard",
          "✅ Monitoreo proactivo (alertas antes de fallo total)",
          "✅ Diseño robusto valida uptime >99% en condiciones adversas"
        ],
        "disadvantages": [
          "❌ Debugging difícil post-deployment (logs limitados, acceso físico difícil)",
          "❌ Hardware fijo limita cambios arquitectónicos post-deployment",
          "❌ Field testing extensivo necesario (costoso y time-consuming)",
          "❌ Power management complejo (estados de sleep, wake-up, mediciones precisas)",
          "❌ Conectividad intermitente complica testing (simular desconexiones)",
          "❌ OTA updates riesgoso (brick device si falla, rollback crítico)",
          "❌ Seguridad compleja (dispositivos expuestos físicamente, TLS en hardware limitado)",
          "❌ Costo de hardware puede escalar con volumen (vs software puro)"
        ],
        "changeManagement": {
          "approach": "OTA Updates Controlados con Rollback Automático",
          "description": "Cambios de firmware se despliegan mediante OTA (Over-The-Air) updates con estrategia de phased rollout y rollback automático si falla",
          "process": [
            {
              "step": 1,
              "name": "Desarrollo y Testing en Lab",
              "action": "Desarrollar cambio de firmware y probar exhaustivamente en lab",
              "responsible": "Ingeniero de Firmware",
              "artifacts": [
                "Firmware actualizado",
                "Tests pasando"
              ],
              "timeframe": "Según complejidad del cambio"
            },
            {
              "step": 2,
              "name": "Field Testing con Pilotos",
              "action": "Deployment a subset de dispositivos (1-5% del total) en campo",
              "responsible": "Ingeniero de Firmware + Operaciones",
              "artifacts": [
                "Firmware deployado a pilotos",
                "Monitoreo activo"
              ],
              "timeframe": "1-2 semanas"
            },
            {
              "step": 3,
              "name": "Validación de Pilotos",
              "action": "Monitorear telemetría de pilotos (errores, crashes, power consumption)",
              "responsible": "Operaciones",
              "artifacts": [
                "Reporte de telemetría de pilotos"
              ],
              "timeframe": "3-7 días de monitoreo"
            },
            {
              "step": 4,
              "name": "Phased Rollout",
              "action": "Si pilotos OK, deployment incremental (10% → 50% → 100%)",
              "responsible": "Operaciones",
              "artifacts": [
                "Firmware deployado gradualmente"
              ],
              "timeframe": "1-2 semanas por fase"
            },
            {
              "step": 5,
              "name": "Monitoreo Post-Rollout",
              "action": "Monitoreo intensivo de todos los dispositivos actualizados",
              "responsible": "Operaciones",
              "artifacts": [
                "Dashboard de monitoreo",
                "Alertas configuradas"
              ],
              "timeframe": "1 semana post-100%"
            },
            {
              "step": 6,
              "name": "Rollback Automático (si falla)",
              "action": "Si >X% de dispositivos fallan, rollback automático a versión anterior",
              "responsible": "Sistema automático + Operaciones",
              "artifacts": [
                "Rollback ejecutado",
                "Post-mortem"
              ],
              "timeframe": "Automático (minutos a horas)"
            }
          ],
          "tools": [
            "AWS IoT Device Management / Azure IoT Hub (OTA updates)",
            "Grafana (monitoreo de telemetría)",
            "PagerDuty / Datadog (alertas)",
            "Git (versionado de firmware)"
          ],
          "ccbComposition": [
            "Arquitecto de IoT",
            "Ingeniero de Firmware",
            "Operaciones"
          ],
          "frequency": "On-demand, típicamente mensual o trimestral para updates no-críticos",
          "timeExpectation": "Cambios menores: 3-4 semanas desde dev hasta 100% rollout. Cambios críticos: más rápido con mayor riesgo"
        },
        "iterationStrategy": "Cada iteración dura 3-8 semanas y entrega un sistema desplegable en producción real. Feedback de usuarios piloto en iteraciones 1-2 (telemetría, usabilidad) guía priorización de features en iteraciones 3-4. Despliegue escalonado (2 → 10 → 50 → 1000+ dispositivos) minimiza riesgo de bugs críticos en producción masiva. Rollback a iteración anterior es posible ante fallas críticas.",
        "tooling": {
          "required": [
            "Firmware development (C/C++ para microcontrollers, Python para Raspberry Pi)",
            "Cloud IoT platform (AWS IoT Core, Azure IoT Hub, GCP IoT Core)",
            "Time-Series Database (InfluxDB, TimescaleDB, AWS Timestream)",
            "Dashboard (Grafana, custom webapp)"
          ],
          "recommended": [
            "MQTT Broker (AWS IoT, Mosquitto, HiveMQ)",
            "OTA Update framework (AWS IoT Jobs, Mender, balena)",
            "Monitoring (Grafana, Datadog, Prometheus)",
            "Edge ML (TensorFlow Lite, Edge Impulse) para processing avanzado",
            "Security (TLS, device certificates, hardware security module)"
          ]
        },
        "references": {
          "chapter": "Capítulo 2",
          "sections": [
            "Sección 2.1.1: Modelo en Cascada (adaptado para IoT)",
            "Capítulo 6: Arquitectura de Software (Cliente-Servidor, Edge + Cloud)"
          ],
          "relatedConcepts": [
            "concept-edge-computing",
            "concept-iot-architecture",
            "concept-embedded-systems"
          ]
        },
        "why": [
          "Validación temprana con hardware real en iteración 1",
          "Feedback de usuarios piloto guía desarrollo de features",
          "Despliegue escalonado (2 → 10 → 50 → 1000+) minimiza riesgos",
          "Cada iteración entrega sistema funcional desplegable"
        ],
        "how": [
          "Iteración 1 (3-4 sem): MVP Edge-Only → 1-2 dispositivos",
          "Iteración 2 (4-6 sem): Cloud + Dashboard → 5-10 dispositivos",
          "Iteración 3 (5-7 sem): OTA + ML + Seguridad → 50+ dispositivos",
          "Iteración 4 (6-8 sem): Fleet Management + Escala → 1000+ dispositivos"
        ]
      },
      "methodology": {
        "name": "Waterfall Model (Plan-Driven Development)",
        "description": "Modelo secuencial lineal donde cada fase debe completarse antes de iniciar la siguiente. Cada fase tiene entradas, procesos y salidas bien definidos, con énfasis en planificación upfront, documentación exhaustiva y predictibilidad del cronograma y presupuesto. Apropiado para proyectos con requisitos bien definidos y estables desde el inicio, donde los cambios son costosos y deben minimizarse. El modelo fue originalmente propuesto por Winston Royce en 1970 como ejemplo de cómo NO hacer desarrollo (porque carecía de feedback loops), pero la industria lo adoptó como modelo estándar durante las siguientes décadas. Las fases típicas son: Requirements → Design → Implementation → Testing → Deployment → Maintenance, con verificación y validación formal al final de cada fase mediante gates de aprobación.",
        "origin": {
          "creator": "Winston W. Royce (adaptación de modelo original de ingeniería tradicional)",
          "year": 1970,
          "context": "Propuesto en el paper 'Managing the Development of Large Software Systems' presentado en IEEE WESCON. Irónicamente, Royce propuso el modelo como ejemplo de un enfoque deficiente (sin iteraciones ni feedback loops), pero la industria lo adoptó literalmente como estándar durante décadas, especialmente en proyectos gubernamentales y de defensa que requerían documentación exhaustiva y auditorías formales."
        },
        "principles": [
          "Fases secuenciales estrictas: Requirements → Design → Implementation → Testing → Deployment → Maintenance (cada fase debe completarse antes de la siguiente)",
          "Documentación formal exhaustiva en cada fase: SRS (Software Requirements Specification), SDD (Software Design Document), Test Plans, User Manuals, etc.",
          "Verificación y validación al final de cada fase mediante gates con criterios de entrada/salida (stage gates)",
          "Cambios son costosos y requieren volver a fases anteriores (change control formal con CCB - Change Control Board)",
          "Predictibilidad upfront: tiempo, costo y alcance estimados al inicio con alta precisión basada en requirements completos",
          "Entrega única al final del proyecto (big-bang deployment) después de completar todas las fases"
        ],
        "differentiators": [
          "vs Ágil: Waterfall prioriza documentación formal y planificación upfront exhaustiva, mientras Ágil prioriza working software incremental y adaptación continua a cambios",
          "vs Incremental: Waterfall entrega una sola vez al final (big-bang), mientras Incremental entrega múltiples veces con funcionalidad incremental",
          "vs Espiral: Waterfall no tiene gestión explícita de riesgos ni construcción de prototipos obligatorios, mientras Espiral centra cada ciclo en análisis de riesgos"
        ],
        "references": {
          "chapter": "chapter-2",
          "sections": [
            "2.1 Plan-driven and agile development",
            "2.2 The waterfall model"
          ],
          "externalResources": [
            "Royce, W. W. (1970). Managing the Development of Large Software Systems. Proceedings of IEEE WESCON",
            "Sommerville, I. (2016). Software Engineering (10th ed.), Chapter 2"
          ]
        }
      },
      "modeling": {
        "notations": [
          {
            "name": "UML",
            "description": "UML para arquitectura distribuida de dispositivos IoT y cloud backend.",
            "diagrams": [
              "Component Diagram (microservicios/dispositivos)",
              "Sequence Diagram (IoT device → cloud)",
              "Deployment Diagram (edge + cloud)"
            ],
            "whenToUse": "Sistemas IoT distribuidos con edge computing y cloud backend",
            "tools": [
              "Lucidchart",
              "PlantUML",
              "Visual Paradigm"
            ]
          },
          {
            "name": "C4 Model",
            "description": "Modelo de 4 niveles (Context, Container, Component, Code) para documentar arquitectura moderna.",
            "diagrams": [
              "C4 Context Diagram (sistema + actores)",
              "C4 Container Diagram (apps, DBs, message brokers)"
            ],
            "whenToUse": "Sistemas IoT complejos con múltiples containers (edge devices, cloud services, databases, message queues)",
            "tools": [
              "Structurizr",
              "Draw.io",
              "Mermaid",
              "C4-PlantUML"
            ]
          }
        ],
        "primaryFocus": "Arquitectura distribuida de dispositivos IoT, edge computing y cloud backend con message queues",
        "references": {
          "chapter": "chapter-6",
          "sections": [
            "6.2 Architectural design decisions",
            "6.5 Distributed systems architectures"
          ]
        }
      },
      "architecture": {
        "patterns": [
          {
            "name": "Event-Driven (Pub-Sub)",
            "description": "Comunicación asíncrona mediante eventos. Dispositivos IoT publican eventos (telemetry), servicios cloud subscriben y procesan.",
            "advantages": [
              "Desacoplamiento (devices no conocen consumers, facilita agregar consumers)",
              "Escalabilidad (múltiples consumers pueden procesar eventos en paralelo)",
              "Tolerancia a fallos (message broker persiste eventos si consumer está caído)",
              "Real-time processing (eventos procesados al llegar, no batch)"
            ],
            "disadvantages": [
              "Complejidad de debugging (flujo asíncrono difícil de trazar, necesita distributed tracing)",
              "Eventual consistency (no hay garantía de orden estricto entre consumers)",
              "Overhead de message broker (latencia adicional, costo de Kafka/RabbitMQ/AWS SQS)"
            ],
            "whenToUse": "IoT con miles de dispositivos enviando telemetry en paralelo (sensores industriales, smart city, wearables)",
            "tradeoffs": "Escalabilidad y desacoplamiento vs Complejidad de debugging y eventual consistency"
          },
          {
            "name": "Microservices",
            "description": "Arquitectura de servicios pequeños independientes, cada uno con su propia base de datos y deployment.",
            "advantages": [
              "Escalamiento independiente por servicio (horizontal scaling granular)",
              "Tecnologías heterogéneas (Python para ML, Go para telemetry, Java para transacciones)",
              "Deployment independiente (actualizar un servicio sin afectar otros)",
              "Resiliencia (fallo de un servicio no tumba todo el sistema)"
            ],
            "disadvantages": [
              "Complejidad operacional (múltiples deployments, monitoring distribuido)",
              "Network latency (servicios se comunican por red, no memoria compartida)",
              "Distributed transactions difíciles (eventual consistency, sagas)",
              "Debugging complejo (tracing distribuido necesario)"
            ],
            "whenToUse": "Sistemas grandes con múltiples equipos, funcionalidades independientes y necesidad de escalamiento diferenciado",
            "tradeoffs": "Escalabilidad independiente y deployment ágil vs Complejidad operacional"
          }
        ],
        "style": "Distribuido (edge + cloud), event-driven con microservices",
        "qualityAttributes": {
          "scalability": "Very High - Escalamiento horizontal de microservices y message brokers (Kafka partitions). Millones de dispositivos IoT. Auto-scaling en cloud.",
          "maintainability": "Medium - Microservices facilitan cambios aislados, pero debugging distribuido es complejo. Observabilidad crítica (Prometheus, Grafana, Jaeger).",
          "performance": "Very High - Event-driven permite procesamiento real-time. Edge computing reduce latencia (procesamiento local). Message brokers optimizados para throughput.",
          "security": "Very High - TLS para comunicación devices-cloud. Autenticación por certificados (X.509). Encriptación end-to-end. Device identity management. OTA updates firmados."
        },
        "references": {
          "chapter": "chapter-6",
          "sections": [
            "6.4 Architectural patterns",
            "6.5 Distributed systems architectures"
          ]
        }
      },
      "timeline": [
        {
          "week": "1-2",
          "phase": "Especificación",
          "tasks": [
            "Definir sensores y actuadores",
            "Requisitos de comunicación y power",
            "Condiciones ambientales",
            "Especificación de protocolos"
          ]
        },
        {
          "week": "3-4",
          "phase": "Diseño",
          "tasks": [
            "Arquitectura edge + cloud",
            "Protocolo de comunicación",
            "FSM del dispositivo",
            "Modelo de datos"
          ]
        },
        {
          "week": "5-8",
          "phase": "Prototipo",
          "tasks": [
            "Prototipo de hardware",
            "Firmware básico",
            "Backend básico",
            "Testing en lab"
          ]
        },
        {
          "week": "9-12",
          "phase": "Desarrollo",
          "tasks": [
            "Firmware completo",
            "Backend completo",
            "Dashboard",
            "OTA updates"
          ]
        },
        {
          "week": "13-16",
          "phase": "Field Testing",
          "tasks": [
            "Deployment en condiciones reales",
            "Monitoring 24/7",
            "Ajustes basados en telemetría",
            "Documentación"
          ]
        }
      ],
      "avoid": [
        "No considerar power management",
        "Dependencia total de conectividad",
        "No planear actualizaciones remotas",
        "Testing solo en condiciones ideales",
        "Sin plan de recuperación de errores"
      ],
      "templates": [
        "tpl-001",
        "tpl-003",
        "tpl-006"
      ],
      "chapters": [
        2,
        5,
        6
      ]
    },
    "rec-012": {
      "id": "rec-012",
      "title": "Sistema de Sistemas",
      "path": [
        "Sistema de Sistemas"
      ],
      "pathDescription": "Sistema de Sistemas → Múltiples Subsistemas → Integración Crítica",
      "process": {
        "name": "RUP with Integration Focus (System of Systems)",
        "type": "iterative-phased-integration",
        "chapter": 2,
        "description": "Framework RUP adaptado para Sistema de Sistemas donde múltiples subsistemas independientes deben integrarse. Énfasis en Elaboration extendida para diseñar contratos de APIs, estrategia de integración (SOA, message bus) y testing end-to-end. Construction incluye desarrollo paralelo de subsistemas con puntos de sincronización para validar integraciones.",
        "why": [
          "Sistema de Sistemas requiere arquitectura de integración robusta desde el inicio (API contracts, message schemas)",
          "RUP estructura desarrollo en fases macro que aseguran que arquitectura de integración es viable antes de Construction",
          "Testing end-to-end crítico para validar que subsistemas colaboran correctamente",
          "Desarrollo paralelo de subsistemas maximiza productividad (múltiples equipos trabajando simultáneamente)",
          "Deployment escalonado minimiza blast radius de bugs críticos en producción"
        ],
        "how": [
          "Ejecutar 4 fases RUP (Inception, Elaboration extendida, Construction paralelo, Transition escalonado)",
          "10-15 iteraciones totales: Inception (1-2), Elaboration (3-4), Construction (4-6), Transition (2-3)",
          "Elaboration diseña contratos de APIs (OpenAPI) y message schemas (Avro/Protobuf)",
          "Construction desarrolla subsistemas en paralelo con integration testing al final de cada iteración",
          "Transition despliega subsistemas de forma escalonada (no big-bang) para minimizar riesgo"
        ],
        "phases": [
          {
            "id": "phase-sos-inception",
            "name": "Inception (Concepción)",
            "order": 1,
            "description": "Establecer viabilidad del Sistema de Sistemas, identificar subsistemas componentes y sus interfaces de integración de alto nivel. Objetivo: Definir alcance del ecosystem y decidir si proyecto es factible.",
            "duration": "3-6 semanas (1-2 iteraciones)",
            "activities": [
              "Identificar subsistemas componentes (ej: subsistema A=CRM, B=Inventario, C=Logística, D=Finanzas)",
              "Crear System Context Diagram (diagrama de contexto mostrando subsistemas y sus interacciones)",
              "Definir 15-25 casos de uso end-to-end (cross-subsystem workflows: orden de compra → facturación → envío)",
              "Realizar análisis de integraciones críticas (APIs REST, message queues, eventos, data sync)",
              "Identificar subsistemas legacy existentes vs nuevos a desarrollar (buy vs build decisions)",
              "Crear Vision Document del ecosystem (objetivos, stakeholders por subsistema, restricciones de integración)",
              "Identificar riesgos de integración críticos (incompatibilidad de tecnologías, latencia, seguridad)",
              "Milestone: Lifecycle Objective - Decisión go/no-go basada en viabilidad de integración"
            ],
            "inputs": [
              "Solicitud de proyecto o RFP para ecosystem",
              "Documentación de subsistemas legacy existentes (si aplica)",
              "Restricciones de integración conocidas (firewalls, VPNs, compliance)"
            ],
            "outputs": [
              "System Context Diagram (C4 Model nivel 1)",
              "Subsystems Catalog (listado de subsistemas con responsabilidades)",
              "Initial Use Case Model (15-25 casos de uso cross-subsystem)",
              "Integration Risk Assessment (top 10 riesgos de integración)",
              "Vision Document del ecosystem"
            ],
            "deliverables": [
              {
                "name": "System Architecture Overview (diagrama de alto nivel)",
                "template": "tpl-004",
                "required": true,
                "reviewedBy": [
                  "Enterprise Architect",
                  "Integration Architect"
                ]
              },
              {
                "name": "Subsystems Identification Document",
                "template": "tpl-001",
                "required": true,
                "reviewedBy": [
                  "Enterprise Architect",
                  "Subsystem Owners"
                ]
              },
              {
                "name": "Vision Document v1.0 (ecosystem-wide)",
                "template": "tpl-001",
                "required": true,
                "reviewedBy": [
                  "Sponsor",
                  "Subsystem Owners"
                ]
              },
              {
                "name": "Go/No-Go Decision Document",
                "template": "tpl-015",
                "required": true,
                "reviewedBy": [
                  "Sponsor",
                  "CTO"
                ]
              }
            ],
            "gate": {
              "name": "Lifecycle Objective Milestone",
              "criteria": [
                "Subsistemas identificados con interfaces preliminares definidas",
                "Top 5 riesgos de integración tienen estrategias de mitigación preliminares",
                "Vision Document aprobado por stakeholders de todos los subsistemas",
                "Presupuesto aprobado para Elaboration (fase más larga y costosa)",
                "Sponsor firma decisión go para continuar"
              ],
              "decision": "GO / NO-GO / REDEFINE SCOPE",
              "approvers": [
                "Enterprise Architect",
                "Sponsor",
                "Subsystem Owners",
                "CTO"
              ]
            },
            "keyStakeholders": [
              "Enterprise Architect",
              "Business Analyst",
              "Subsystem Owners",
              "Integration Architect"
            ]
          },
          {
            "id": "phase-sos-elaboration",
            "name": "Elaboration (Elaboración Extendida)",
            "order": 2,
            "description": "Diseñar arquitectura de integración completa: contratos de APIs, message schemas, estrategia de sincronización de datos, error handling cross-subsystem. Fase más crítica para Sistema de Sistemas. Objetivo: Architecture Baseline que asegure interoperabilidad.",
            "duration": "12-16 semanas (3-4 iteraciones de 4 semanas)",
            "activities": [
              "Diseñar API contracts para cada interfaz entre subsistemas (OpenAPI/Swagger specs, versioning strategy)",
              "Definir message schemas para eventos asíncronos (Avro, Protobuf, JSON schemas con validación)",
              "Seleccionar estrategia de integración: SOA (API Gateway como Kong/Apigee), Event-Driven (Kafka/RabbitMQ), Hybrid",
              "Crear Architecture Decision Records (ADRs) para decisiones críticas: REST vs gRPC, sync vs async, orchestration vs choreography",
              "Implementar spike técnico de integración (proof-of-concept: subsistema A llama API de B, B publica evento a C)",
              "Diseñar data synchronization strategy (eventual consistency, SAGA pattern, distributed transactions)",
              "Definir error handling cross-subsystem (circuit breakers, retries, compensating transactions)",
              "Crear security architecture (OAuth2, API keys, mutual TLS, encryption in-transit)",
              "Testing del spike: latencia end-to-end, fault tolerance (qué pasa si subsistema B cae), data consistency",
              "Milestone: Lifecycle Architecture - Arquitectura de integración aprobada y validada con spike"
            ],
            "inputs": [
              "System Context Diagram (Inception)",
              "Subsystems Catalog",
              "Integration Risk Assessment"
            ],
            "outputs": [
              "Integration Architecture Document (IAD con diagramas de secuencia, deployment, componentes)",
              "API Contracts (OpenAPI specs versionados para cada interfaz)",
              "Message Schemas (Avro/Protobuf schemas versionados)",
              "Integration Spike (código ejecutable demostrando integración end-to-end)",
              "Security Architecture Document (autenticación, autorización, encryption)",
              "Data Sync Strategy Document (consistency model, conflict resolution)"
            ],
            "deliverables": [
              {
                "name": "Integration Architecture Document (IAD)",
                "template": "tpl-004",
                "required": true,
                "reviewedBy": [
                  "Integration Architect",
                  "Enterprise Architect"
                ]
              },
              {
                "name": "API Contract Specifications (OpenAPI 3.0)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Integration Architect",
                  "Subsystem Tech Leads"
                ]
              },
              {
                "name": "Integration Spike (GitHub repo con demo end-to-end)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Integration Architect",
                  "DevOps Lead"
                ]
              },
              {
                "name": "Architecture Decision Records (ADRs)",
                "template": "tpl-004",
                "required": true,
                "reviewedBy": [
                  "Enterprise Architect",
                  "Technical Leads"
                ]
              },
              {
                "name": "NFRs for Integration (latencia, throughput, fault tolerance)",
                "template": "tpl-005",
                "required": true,
                "reviewedBy": [
                  "Integration Architect",
                  "QA Lead"
                ]
              }
            ],
            "gate": {
              "name": "Lifecycle Architecture Milestone",
              "criteria": [
                "API contracts aprobados por owners de todos los subsistemas involucrados",
                "Integration spike valida arquitectura propuesta (latencia, fault tolerance, consistency)",
                "Security architecture aprobada por Security Team y Compliance",
                "Top 5 riesgos de integración mitigados o con plan claro",
                "Estimaciones de Construction refinadas con ±20% accuracy (integración es costosa)",
                "Architecture Review Board (ARB) aprueba arquitectura de integración"
              ],
              "decision": "GO / REFINE ARCHITECTURE / NO-GO",
              "approvers": [
                "Integration Architect",
                "Enterprise Architect",
                "Subsystem Tech Leads",
                "Security Lead",
                "Sponsor"
              ]
            },
            "keyStakeholders": [
              "Integration Architect",
              "API Developers",
              "DevOps (infrastructure)",
              "Security Engineer",
              "DBA (data sync)"
            ]
          },
          {
            "id": "phase-sos-construction",
            "name": "Construction (Construcción Paralela)",
            "order": 3,
            "description": "Desarrollo paralelo de subsistemas por equipos independientes + iteraciones de integration testing. Objetivo: Producir ecosystem completo con subsistemas integrados y testeados end-to-end.",
            "duration": "16-24 semanas (4-6 iteraciones de 4 semanas)",
            "activities": [
              "Iteración 1-2 (Core Subsystems): Equipos independientes desarrollan subsistemas A, B, C en paralelo. Al final de iteración: integration testing de interfaces críticas (A↔B, B↔C)",
              "Iteración 3-4 (Secondary Subsystems + Full Integration): Desarrollar subsistemas D, E. Integration testing end-to-end de workflows completos (cross-subsystem)",
              "Iteración 5-6 (Hardening + Performance): Bug fixing cross-subsystem, performance tuning end-to-end (latencia, throughput), security hardening (penetration testing de APIs)",
              "Sincronización entre equipos: Daily sync meeting de Integration Architect con Tech Leads de subsistemas (resolver conflictos de contratos, breaking changes)",
              "Continuous Integration Testing: Pipeline de CI/CD ejecuta integration tests automatizados después de cada merge (validar que cambios en A no rompen B)",
              "Contract testing (Pact, Spring Cloud Contract) para validar que implementaciones respetan API contracts",
              "End-to-end testing: Selenium/Cypress para workflows completos cross-subsystem (simular usuario real navegando ecosystem)",
              "Milestone: Initial Operational Capability - Ecosystem completo funcional en staging"
            ],
            "inputs": [
              "Integration Architecture Document (Elaboration)",
              "API Contracts y Message Schemas",
              "Integration Spike validado"
            ],
            "outputs": [
              "Subsistemas A, B, C, D, E implementados y desplegados en staging",
              "Integration Test Suite (contract tests, integration tests, end-to-end tests)",
              "Performance Test Report (latencia end-to-end, throughput, scalability)",
              "Security Audit Report (penetration testing de APIs, OWASP Top 10)",
              "Deployment Package (Docker images, Kubernetes manifests, API Gateway configs)"
            ],
            "deliverables": [
              {
                "name": "Integrated System in Staging (todos los subsistemas comunicándose)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Integration Architect",
                  "Tech Leads"
                ]
              },
              {
                "name": "Integration Test Coverage Report (>70% coverage de interfaces)",
                "template": "tpl-013",
                "required": true,
                "reviewedBy": [
                  "QA Lead",
                  "Integration Architect"
                ]
              },
              {
                "name": "Performance Benchmarks (latencia <500ms P95, throughput sustentable)",
                "template": "tpl-013",
                "required": true,
                "reviewedBy": [
                  "Performance Engineer",
                  "Integration Architect"
                ]
              },
              {
                "name": "API Documentation (Swagger UI, Postman collections)",
                "template": "tpl-007",
                "required": true,
                "reviewedBy": [
                  "Integration Architect",
                  "Tech Writers"
                ]
              },
              {
                "name": "Operations Manual (deployment, troubleshooting, monitoring)",
                "template": "tpl-006",
                "required": true,
                "reviewedBy": [
                  "DevOps Lead",
                  "SRE"
                ]
              }
            ],
            "gate": {
              "name": "Initial Operational Capability Milestone",
              "criteria": [
                "Todos los subsistemas críticos (A, B, C) integrados y comunicándose correctamente",
                "Integration tests pasando >95% (contract tests + integration tests + end-to-end)",
                "Performance cumple NFRs (latencia <500ms P95 end-to-end, throughput >500 req/s)",
                "Security audit aprobado (zero vulnerabilidades críticas en APIs)",
                "Zero bugs críticos cross-subsystem, <5 bugs high priority conocidos",
                "Aprobación de Integration Architect y Tech Leads de subsistemas para iniciar UAT"
              ],
              "decision": "GO TO UAT / FIX CRITICAL ISSUES / ITERATE",
              "approvers": [
                "Integration Architect",
                "Tech Leads (subsistemas A-E)",
                "QA Lead",
                "Security Lead",
                "Product Owner"
              ]
            },
            "keyStakeholders": [
              "Development Teams (5-10 equipos paralelos)",
              "Integration Testing Team",
              "DevOps Engineers",
              "API Gateway Admin"
            ]
          },
          {
            "id": "phase-sos-transition",
            "name": "Transition (Transición Escalonada)",
            "order": 4,
            "description": "Deployment escalonado de subsistemas a producción (no big-bang), UAT cross-subsystem, training de usuarios por subsistema, establecimiento de soporte distribuido. Objetivo: Ecosystem operando en producción con usuarios reales.",
            "duration": "8-12 semanas (2-3 iteraciones de 4 semanas)",
            "activities": [
              "Ejecutar UAT cross-subsystem con 30-50 usuarios piloto (representantes de cada subsistema)",
              "Iteración 1 (UAT + Bug Fixing): Usuarios piloto prueban workflows end-to-end, reportan bugs. Equipos de subsistemas fijan bugs en paralelo",
              "Deployment escalonado a producción: Semana 1 (subsistema A), Semana 2 (A+B), Semana 3 (A+B+C), Semana 4 (ecosystem completo)",
              "Razón del deployment escalonado: Minimizar blast radius de bugs críticos, validar integración en producción antes de agregar más subsistemas",
              "Data migration coordinada: Migrar datos de legacy systems a subsistemas nuevos de forma sincronizada (evitar inconsistencias)",
              "Training por subsistema: Capacitar usuarios de A, luego B, luego C (training acumulativo para workflows cross-subsystem)",
              "Establecer soporte distribuido: L1/L2 por subsistema + Integration Support Team (L3) para bugs cross-subsystem",
              "Monitoreo end-to-end: Distributed tracing (Jaeger, Zipkin) para tracear requests cross-subsystem, alertas SRE",
              "Milestone: Product Release - Ecosystem completo operando en producción con >99% uptime"
            ],
            "inputs": [
              "Integrated System en staging (Construction)",
              "Integration Test Suite pasando",
              "Performance y Security validados"
            ],
            "outputs": [
              "Ecosystem en producción con 100% subsistemas desplegados",
              "UAT Acceptance Document (firmado por usuarios piloto de cada subsistema)",
              "Training Materials Package (por subsistema + workflows cross-subsystem)",
              "Distributed Support Model (L1/L2 por subsistema, L3 integration team)",
              "Post-Deployment Monitoring Dashboard (distributed tracing, SLOs, alertas)"
            ],
            "deliverables": [
              {
                "name": "Production Ecosystem (live con usuarios reales en todos los subsistemas)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Operations Manager",
                  "Product Owners"
                ]
              },
              {
                "name": "UAT Acceptance Report (aprobado por Product Owners de subsistemas)",
                "template": "tpl-013",
                "required": true,
                "reviewedBy": [
                  "Product Owners",
                  "Sponsor"
                ]
              },
              {
                "name": "Operations Manual (deployment escalonado, rollback, incident response)",
                "template": "tpl-006",
                "required": true,
                "reviewedBy": [
                  "SRE",
                  "DevOps Lead"
                ]
              },
              {
                "name": "Distributed Tracing Dashboard (Jaeger UI con traces end-to-end)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "SRE",
                  "Integration Architect"
                ]
              },
              {
                "name": "Lessons Learned Document (retrospectiva del proyecto de integración)",
                "template": "tpl-015",
                "required": true,
                "reviewedBy": [
                  "Integration Architect",
                  "Sponsor"
                ]
              }
            ],
            "gate": {
              "name": "Product Release Milestone",
              "criteria": [
                "UAT aprobado por >90% usuarios piloto (workflows cross-subsystem funcionan correctamente)",
                "Deployment escalonado completado sin rollback (todos los subsistemas en producción)",
                "Data migration completada con 100% integridad (validación cross-subsystem)",
                "Training completado para >95% usuarios de cada subsistema",
                "Ecosystem operando con >99% uptime por 14 días continuos (SLO cumplido)",
                "Distributed tracing funcionando (traces end-to-end visibles en Jaeger)",
                "Support distribuido operando con <4h response time (L1/L2/L3)",
                "Sign-off formal de Product Owners de todos los subsistemas y Sponsor"
              ],
              "decision": "PROJECT SUCCESS / ITERATE / STAGED ROLLBACK",
              "approvers": [
                "Product Owners (subsistemas A-E)",
                "Sponsor",
                "Integration Architect",
                "Operations Manager",
                "Support Lead"
              ]
            },
            "keyStakeholders": [
              "End Users (por subsistema)",
              "Support Teams (distribuido)",
              "Operations Team",
              "Training Team",
              "Integration Architect"
            ]
          }
        ],
        "iterationStrategy": "RUP adaptado para Sistema de Sistemas ejecuta 10-15 iteraciones totales: Inception (1-2), Elaboration (3-4), Construction (4-6), Transition (2-3). Elaboration es más larga porque diseño de integración (API contracts, message schemas) es crítico y costoso de cambiar después. Construction usa desarrollo paralelo (equipos independientes por subsistema) con puntos de sincronización para integration testing. Transition escalonado minimiza riesgo de big-bang deployment.",
        "whenToUse": [
          "Sistema de Sistemas con múltiples subsistemas independientes que deben integrarse (smart city, ecosystem empresarial)",
          "Cada subsistema tiene equipo independiente (5-10 personas) y ciclo de desarrollo propio",
          "Necesidad crítica de interoperabilidad (subsistemas deben comunicarse correctamente)",
          "Múltiples tecnologías heterogéneas (Java, .NET, Python) requieren estrategia de integración clara (SOA, API Gateway)",
          "Subsistemas legacy existentes que deben integrarse con subsistemas nuevos",
          "Alto riesgo de integración (latencia end-to-end, fault tolerance, data consistency son críticos)",
          "Regulaciones requieren auditoría de APIs y security en integraciones (healthcare, finance)",
          "Escalabilidad independiente de subsistemas (subsistema A puede escalar sin afectar B)",
          "Equipos distribuidos geográficamente (necesitan contratos de APIs claros para coordinarse)",
          "Presupuesto grande (>$1M) para soportar equipos múltiples y tooling de integración (API Gateway, message bus)"
        ],
        "whenNotToUse": [
          "Sistema monolítico sin subsistemas independientes (RUP tradicional o Incremental puro mejor)",
          "Equipo único pequeño (<20 personas) sin necesidad de desarrollo paralelo",
          "Subsistemas están fuertemente acoplados (no tienen interfaces claras, RUP overhead innecesario)",
          "Requisitos de integración desconocidos o experimentales (Ágil puro o Espiral mejor para explorar)",
          "Presupuesto limitado (<$300K, overhead de Elaboration extendida muy caro)",
          "Plazos muy cortos (<9 meses, no hay tiempo para Elaboration extendida + Construction paralelo)",
          "Sin expertise en arquitectura de integración (APIs, SOA, message queues, distributed systems)",
          "Cambios frecuentes de contratos de APIs esperados (friction con formalidad de RUP)",
          "Sin necesidad de fault tolerance cross-subsystem (sistema simple no requiere complejidad de integration testing)",
          "Cultura organizacional ágil con aversión a documentación formal de APIs"
        ],
        "advantages": [
          "API contracts y message schemas definidos en Elaboration evitan breaking changes costosos en Construction (saving 40-50% tiempo de integration debugging)",
          "Desarrollo paralelo de subsistemas maximiza productividad (5 equipos trabajando simultáneamente)",
          "Integration testing continuo detecta bugs cross-subsystem temprano (cada iteración)",
          "Deployment escalonado minimiza blast radius de bugs críticos (no big-bang failure)",
          "Arquitectura de integración robusta (SOA, API Gateway, message bus) facilita escalabilidad independiente",
          "Contract testing (Pact) asegura que cambios en subsistema A no rompen B sin validación",
          "Distributed tracing (Jaeger) permite troubleshooting de issues end-to-end en producción",
          "Apropiado para equipos distribuidos geográficamente (contratos claros permiten coordinación asíncrona)",
          "Escalamiento independiente de subsistemas según demanda (A puede escalar 10x mientras B permanece estable)",
          "Fault isolation: Falla de subsistema B no derriba ecosystem completo (circuit breakers, retries)"
        ],
        "disadvantages": [
          "Elaboration extendida (12-16 semanas) retrasa inicio de Construction (stakeholders impacientes)",
          "Overhead de coordinación entre equipos muy alto (daily sync, conflict resolution de APIs)",
          "Integration testing complejo y costoso (requiere infrastructure dedicada, test data sync)",
          "Deployment escalonado prolonga Transition (8-12 semanas vs 4-6 en sistema monolítico)",
          "Debugging cross-subsystem muy difícil (requiere distributed tracing, logs centralizados)",
          "Cambios en API contracts requieren coordinación de múltiples equipos (breaking change = re-deploy de A y B)",
          "Tooling costoso (API Gateway >$50K/año, Kafka cluster, distributed tracing infrastructure)",
          "Riesgo de inconsistencia de datos entre subsistemas (eventual consistency es difícil de debuggear)",
          "Performance end-to-end puede ser impredecible (latencia acumulada de N subsistemas)",
          "Requiere expertise avanzada en distributed systems (no todos los equipos tienen este skillset)"
        ],
        "changeManagement": {
          "description": "Gestión de cambios con impacto cross-subsystem mediante versioning de APIs. Cambios en API contracts son críticos porque afectan múltiples subsistemas. Usar semantic versioning (v1, v2, v3) para APIs y deprecation policy (v1 deprecated, v2 current, v3 beta). Breaking changes requieren aprobación de Integration Architect + owners de subsistemas afectados.",
          "steps": [
            {
              "step": 1,
              "name": "Change Request con Cross-Subsystem Impact Analysis",
              "description": "Todo cambio que afecta API contracts o message schemas requiere CR con: subsistemas impactados, breaking vs non-breaking change, plan de migración."
            },
            {
              "step": 2,
              "name": "API Versioning Strategy",
              "description": "Breaking changes requieren nueva versión de API (v1 → v2). Mantener v1 deprecated por 6-12 meses mientras consumidores migran. Non-breaking changes (nuevos fields opcionales) no requieren versioning."
            },
            {
              "step": 3,
              "name": "Integration Architect Review",
              "description": "Integration Architect revisa CR y coordina con Tech Leads de subsistemas afectados. Decisión: Aprobar (con plan de migración), Rechazar (muy costoso), Defer to Next Release."
            },
            {
              "step": 4,
              "name": "Contract Testing Pre-Merge",
              "description": "Implementar cambio en branch. Ejecutar contract tests (Pact) para validar que cambio no rompe consumidores existentes. Si rompe: blocking merge hasta migración de consumidores."
            },
            {
              "step": 5,
              "name": "Coordinated Deployment",
              "description": "Breaking changes requieren deployment coordinado: (1) Desplegar v2 de API provider (mantener v1 activa), (2) Migrar consumidores a v2 (phased rollout), (3) Deprecar v1 después de 6 meses."
            },
            {
              "step": 6,
              "name": "End-to-End Regression Testing",
              "description": "Después de deployment, ejecutar end-to-end tests de workflows cross-subsystem para validar que integración sigue funcionando correctamente."
            }
          ]
        },
        "tooling": [
          {
            "category": "Integration Infrastructure",
            "tools": [
              "API Gateway (Kong, Apigee, AWS API Gateway para routing, rate limiting, auth)",
              "Message Bus (Kafka, RabbitMQ para eventos asíncronos cross-subsystem)",
              "Service Mesh (Istio, Linkerd para traffic management, observability)"
            ]
          },
          {
            "category": "API Design & Testing",
            "tools": [
              "OpenAPI 3.0, Swagger para API contract specifications versionadas",
              "Pact, Spring Cloud Contract para contract testing (validar compatibilidad)",
              "Postman, WireMock para API mocking y testing independiente"
            ]
          },
          {
            "category": "Observability",
            "tools": [
              "Distributed Tracing (Jaeger, Zipkin, AWS X-Ray para troubleshooting end-to-end)",
              "Monitoring (Prometheus, Grafana, Datadog para métricas cross-subsystem)",
              "Centralized Logging (ELK Stack, Splunk para logs agregados)"
            ]
          },
          {
            "category": "Development & CI/CD",
            "tools": [
              "Git/GitHub/GitLab para version control multi-repo (1 repo por subsistema)",
              "CI/CD (Jenkins, GitHub Actions con integration testing automatizado)",
              "Kubernetes para orchestration de múltiples subsistemas"
            ]
          },
          {
            "category": "Documentation",
            "tools": [
              "Swagger UI, Redoc, Stoplight para API documentation self-service",
              "Confluence para Architecture Decision Records (ADRs) y Integration Architecture Document"
            ]
          }
        ],
        "references": [
          {
            "title": "Software Engineering (10th Edition) - Chapter 2.4: Rational Unified Process",
            "author": "Ian Sommerville",
            "year": 2015,
            "source": "Pearson"
          },
          {
            "title": "Software Engineering (10th Edition) - Chapter 6.3: Application Architectures",
            "author": "Ian Sommerville",
            "year": 2015,
            "source": "Pearson"
          },
          {
            "title": "Building Microservices: Designing Fine-Grained Systems",
            "author": "Sam Newman",
            "year": 2021,
            "source": "O'Reilly Media"
          },
          {
            "title": "Enterprise Integration Patterns",
            "author": "Gregor Hohpe, Bobby Woolf",
            "year": 2003,
            "source": "Addison-Wesley"
          }
        ]
      },
      "methodology": {
        "name": "Rational Unified Process (RUP)",
        "description": "Framework de proceso híbrido que combina 4 fases secuenciales macro (Inception, Elaboration, Construction, Transition) con desarrollo iterativo incremental dentro de cada fase. Énfasis en diseño de arquitectura robusta desde la fase de Elaboration (Architecture Baseline) para evitar refactoring arquitectónico costoso en fases posteriores, y uso extensivo de UML (Unified Modeling Language) para modelado visual de requisitos, diseño y arquitectura. RUP define 9 disciplinas (Requirements, Analysis & Design, Implementation, Test, Deployment, Configuration & Change Management, Project Management, Environment, Business Modeling) que se trabajan con diferente intensidad en cada fase, siguiendo una curva de esfuerzo específica. Cada fase termina con un milestone crítico que determina si el proyecto puede avanzar a la siguiente fase. RUP es altamente configurable (no es prescriptivo) y puede adaptarse desde proyectos pequeños hasta sistemas empresariales masivos.",
        "origin": {
          "creator": "Philippe Kruchten, Ivar Jacobson, Grady Booch (Rational Software Corporation, adquirida por IBM en 2003)",
          "year": 1998,
          "context": "Evolucionó del Rational Objectory Process (adquisición de Objectory AB de Ivar Jacobson en 1995) combinado con metodologías de Grady Booch. Desarrollado para proyectos empresariales grandes que necesitaban estructura y predictibilidad de Waterfall pero con flexibilidad de iteraciones para manejar cambios de requisitos. Muy popular en la década de 2000s (especialmente en banca, gobierno, telecomunicaciones) antes del auge masivo de metodologías Ágiles post-2010."
        },
        "principles": [
          "4 fases secuenciales macro con milestones críticos: Inception (Lifecycle Objective), Elaboration (Lifecycle Architecture), Construction (Initial Operational Capability), Transition (Product Release)",
          "Iteraciones time-boxed dentro de cada fase (típicamente 2-4 semanas por iteración, 2-4 iteraciones por fase)",
          "Architecture-centric: diseño de arquitectura baseline en Elaboration es crítico y debe estabilizarse antes de Construction (evita refactoring costoso después)",
          "Use case driven: casos de uso (UML use case diagrams) son artefacto central de captura de requisitos funcionales",
          "9 disciplinas con intensidad variable por fase (ej: Requirements alta en Inception/Elaboration, Implementation alta en Construction)",
          "Risk-driven: riesgos técnicos y de negocio se identifican y mitigan temprano en Inception/Elaboration (similar a Spiral pero estructurado en fases)",
          "Iterativo e incremental: cada iteración produce un incremento ejecutable (aunque deployment final es en Transition)"
        ],
        "differentiators": [
          "vs Waterfall puro: RUP tiene iteraciones dentro de cada fase con entregas incrementales, mientras Waterfall es estrictamente secuencial sin iteraciones",
          "vs Ágil puro (Scrum/XP): RUP es más pesado en documentación formal, planificación upfront y diseño arquitectónico exhaustivo, mientras Ágil minimiza documentación y favorece emergent design",
          "vs Scrum: RUP define 4 fases macro con milestones específicos y 9 disciplinas, mientras Scrum solo define sprints uniformes sin estructura macro de fases ni disciplinas"
        ],
        "references": {
          "chapter": "chapter-2",
          "sections": [
            "2.4 The Rational Unified Process",
            "2.3 Incremental development and delivery"
          ],
          "externalResources": [
            "Kruchten, P. (2003). The Rational Unified Process: An Introduction (3rd ed.). Addison-Wesley",
            "Jacobson, I., Booch, G., & Rumbaugh, J. (1999). The Unified Software Development Process. Addison-Wesley"
          ]
        }
      },
      "modeling": {
        "notations": [
          {
            "name": "UML",
            "description": "UML para modelado de subsistemas independientes y sus interacciones.",
            "diagrams": [
              "Component Diagram (subsistemas)",
              "Package Diagram (módulos)",
              "Deployment Diagram (infraestructura distribuida)"
            ],
            "whenToUse": "Sistemas de sistemas requieren modelado de subsistemas independientes y sus interacciones",
            "tools": [
              "Enterprise Architect",
              "IBM Rational",
              "Visual Paradigm"
            ]
          },
          {
            "name": "SysML (Systems Modeling Language)",
            "description": "Extensión de UML para ingeniería de sistemas (hardware + software + procesos).",
            "diagrams": [
              "Block Definition Diagram",
              "Internal Block Diagram",
              "Parametric Diagram"
            ],
            "whenToUse": "Sistemas de sistemas complejos con hardware, software y procesos integrados (aeroespaciales, defensa)",
            "tools": [
              "Cameo Systems Modeler",
              "Enterprise Architect",
              "MagicDraw"
            ]
          }
        ],
        "primaryFocus": "Modelado de subsistemas independientes, interfaces entre subsistemas y arquitectura de integración",
        "references": {
          "chapter": "chapter-19",
          "sections": [
            "19.2 System architectures",
            "19.3 Systems integration"
          ]
        }
      },
      "architecture": {
        "patterns": [
          {
            "name": "Microservices",
            "description": "Arquitectura de servicios pequeños independientes, cada uno con su propia base de datos y deployment.",
            "advantages": [
              "Escalamiento independiente por servicio (horizontal scaling granular)",
              "Tecnologías heterogéneas (Python para ML, Go para telemetry, Java para transacciones)",
              "Deployment independiente (actualizar un servicio sin afectar otros)",
              "Resiliencia (fallo de un servicio no tumba todo el sistema)"
            ],
            "disadvantages": [
              "Complejidad operacional (múltiples deployments, monitoring distribuido)",
              "Network latency (servicios se comunican por red, no memoria compartida)",
              "Distributed transactions difíciles (eventual consistency, sagas)",
              "Debugging complejo (tracing distribuido necesario)"
            ],
            "whenToUse": "Sistemas de sistemas con subsistemas independientes y necesidad de escalamiento diferenciado",
            "tradeoffs": "Escalabilidad independiente y deployment ágil vs Complejidad operacional"
          },
          {
            "name": "Service Mesh",
            "description": "Capa de infraestructura para gestionar comunicación entre microservicios (service discovery, load balancing, circuit breaker).",
            "advantages": [
              "Resiliencia (circuit breaker previene cascading failures)",
              "Observabilidad (tracing distribuido, metrics)",
              "Security (mTLS entre servicios)",
              "Traffic management (canary deployments, A/B testing)"
            ],
            "disadvantages": [
              "Complejidad operacional (configuración de Istio, Linkerd)",
              "Overhead de latencia (proxy sidecar en cada servicio)",
              "Curva de aprendizaje alta"
            ],
            "whenToUse": "Sistemas de sistemas con decenas de microservicios comunicándose (necesidad de governance centralizado)",
            "tradeoffs": "Resiliencia y observabilidad vs Complejidad operacional"
          },
          {
            "name": "Event-Driven (Choreography vs Orchestration)",
            "description": "Subsistemas se comunican mediante eventos (choreography: cada servicio decide qué hacer, orchestration: orquestador central coordina).",
            "advantages": [
              "Desacoplamiento de subsistemas",
              "Escalabilidad (procesamiento asíncrono)",
              "Flexibilidad para agregar nuevos subsistemas"
            ],
            "disadvantages": [
              "Debugging complejo (flujo distribuido)",
              "Eventual consistency",
              "Orquestación puede convertirse en single point of failure"
            ],
            "whenToUse": "Sistemas de sistemas donde subsistemas son independientes y deben reaccionar a eventos de otros subsistemas",
            "tradeoffs": "Desacoplamiento vs Complejidad de debugging"
          }
        ],
        "style": "Distribuido (múltiples subsistemas independientes), SOA o microservices con service mesh",
        "qualityAttributes": {
          "scalability": "Very High - Subsistemas escalan independientemente. Arquitectura distribuida soporta alta carga.",
          "maintainability": "Medium - Múltiples subsistemas dificultan coordinación. Service mesh ayuda con observabilidad.",
          "performance": "Medium - Latencia de red entre subsistemas. Caching distribuido (Redis) crítico.",
          "security": "Very High - Autenticación/autorización en cada subsistema. mTLS para comunicación inter-servicio."
        },
        "references": {
          "chapter": "chapter-19",
          "sections": [
            "19.2 System architectures",
            "19.3 Systems integration"
          ]
        }
      },
      "timeline": [
        {
          "week": "Mes 1",
          "phase": "Inicio",
          "tasks": [
            "Identificar todos los subsistemas",
            "Stakeholder mapping",
            "Arquitectura de alto nivel",
            "Definir equipos y responsabilidades"
          ]
        },
        {
          "week": "Mes 2-3",
          "phase": "Elaboración",
          "tasks": [
            "DEFINIR TODAS LAS INTERFACES",
            "Especificaciones de API (OpenAPI)",
            "Protocolos de comunicación",
            "Modelo de datos compartido",
            "Plan de integración"
          ]
        },
        {
          "week": "Mes 4-12",
          "phase": "Construcción",
          "tasks": [
            "Desarrollo paralelo de subsistemas",
            "Mock servers para desarrollo",
            "Integration testing continuo",
            "Weekly integration meetings"
          ]
        },
        {
          "week": "Mes 13-15",
          "phase": "Transición",
          "tasks": [
            "Integración completa",
            "End-to-end testing",
            "Performance testing del sistema completo",
            "Deployment escalonado"
          ]
        }
      ],
      "avoid": [
        "Big Bang Integration (integrar todo al final)",
        "Interfaces no documentadas",
        "No versionar APIs",
        "Cambios de interface sin coordinación",
        "No testear integración temprano"
      ],
      "templates": [
        "tpl-001",
        "tpl-003",
        "tpl-006",
        "tpl-009"
      ],
      "chapters": [
        2,
        5,
        6
      ]
    },
    "rec-013": {
      "id": "rec-013",
      "title": "Web/SaaS → Startup → Sin Cliente (RIESGO)",
      "path": [
        "Web/SaaS",
        "Startup",
        "Sin Cliente"
      ],
      "pathDescription": "Sistema Web/SaaS → Startup → Cliente NO Disponible (⚠️ RIESGO)",
      "warning": "⚠️ Desarrollar startup sin cliente disponible es muy riesgoso. Considera validación frecuente con early adopters.",
      "process": {
        "name": "Hybrid Waterfall-Incremental for Regulated Systems",
        "type": "hybrid-waterfall-incremental-regulated",
        "chapter": 2,
        "description": "Metodología híbrida para sistemas críticos regulados que combina Cascada upfront (requirements + design formal, documentación regulatoria completa) con desarrollo incremental iterativo (implementación en iteraciones de 3-4 semanas con trazabilidad completa mantenida) y V&V final formal. Balance entre compliance regulatorio (documentación exhaustiva, trazabilidad, auditorías independientes) y flexibilidad (iteraciones permiten detección temprana de defectos y ajustes controlados sin sacrificar trazabilidad).",
        "why": [
          "Regulaciones (FDA, SOX, HIPAA, DO-178C) requieren documentación formal upfront (SRS, SDD, traceability matrix completados antes de coding)",
          "V&V (Verification & Validation) independiente obligatorio por regulaciones (equipo separado de development valida sistema)",
          "Trazabilidad completa requerida (100% requisitos ligados a diseño, código y tests - auditable por inspectores)",
          "Implementación iterativa permite detección temprana de defectos (testing continuo cada 3-4 semanas reduce fixing cost 10x vs encontrar defectos en V&V final)",
          "Change control formal previene cambios no autorizados (governance estricto protege integridad del sistema regulado)"
        ],
        "how": [
          "Fase 1 (Cascada, 12-16 semanas): Requirements Engineering formal (SRS IEEE 830), Traceability Matrix, High-Level Design, Risk Analysis (FMEA), aprobación regulatoria preliminar (FDA 510(k), SOX controls)",
          "Fase 2 (Incremental, 20-28 semanas, 5-7 iteraciones): Desarrollo iterativo con iteraciones de 3-4 semanas (más largas que Scrum por overhead de documentación), cada iteración entrega código + tests + documentación actualizada + traceability matrix actualizada",
          "Fase 3 (Cascada, 8-12 semanas): V&V formal (equipo independiente), auditoría de trazabilidad, UAT con protocolos formales, auditorías regulatorias (FDA inspection, SOX audit), deployment controlado"
        ],
        "phases": [
          {
            "id": "phase-hybrid-req-design",
            "name": "Requirements & Design (Waterfall Formal)",
            "order": 1,
            "description": "Requirements Engineering formal y High-Level Design completo antes de implementación. Documentación regulatoria exhaustiva, traceability matrix, risk analysis (FMEA), aprobación regulatoria preliminar. Objetivo: SRS y HLD aprobados por regulador antes de escribir código.",
            "duration": "12-16 semanas",
            "activities": [
              "Requirements Engineering formal: Capturar 100% requisitos funcionales y no funcionales en SRS (Software Requirements Specification IEEE 830)",
              "Stakeholder interviews: Usuarios finales, compliance officers, reguladores (FDA, auditors) para requisitos completos",
              "Traceability Matrix creation: Requisito ID → Diseño ID → Código módulo → Test Case ID (trazabilidad completa desde inicio)",
              "High-Level Design (HLD): Arquitectura del sistema (capas, componentes, interfaces), security architecture (encryption, access control), compliance controls (audit logging, data retention)",
              "Risk Analysis (FMEA - Failure Mode and Effects Analysis): Identificar modos de falla, impacto, probabilidad, mitigación (crítico para FDA)",
              "Regulatory documentation: FDA 510(k) submission (medical software), SOX controls documentation (financial), HIPAA compliance documentation (health data)",
              "Aprobación preliminar: Revisión de SRS y HLD por regulador (FDA pre-submission meeting, SOX auditor review)",
              "Design reviews: Formal reviews de HLD con arquitecto, security team, compliance officer (sign-off obligatorio)"
            ],
            "inputs": [
              "Regulatory requirements (FDA 21 CFR Part 11, SOX Section 404, HIPAA Security Rule)",
              "Business requirements (funcionalidad del sistema)",
              "Compliance constraints (data retention policies, audit logging, access control)"
            ],
            "outputs": [
              "Software Requirements Specification (SRS IEEE 830, 100-200 páginas)",
              "Traceability Matrix inicial (requisitos → diseño, empty code/test columns)",
              "High-Level Design Document (HLD con arquitectura, security, compliance)",
              "Risk Analysis Report (FMEA con modos de falla, mitigación)",
              "Regulatory submission preliminar (FDA 510(k), SOX controls documentation)"
            ],
            "deliverables": [
              {
                "name": "Software Requirements Specification (SRS IEEE 830)",
                "template": "tpl-002",
                "required": true,
                "reviewedBy": [
                  "Business Analyst",
                  "Compliance Officer",
                  "Product Owner"
                ]
              },
              {
                "name": "Traceability Matrix (requisitos → diseño)",
                "template": "tpl-014",
                "required": true,
                "reviewedBy": [
                  "QA Lead",
                  "Compliance Officer"
                ]
              },
              {
                "name": "High-Level Design Document (HLD)",
                "template": "tpl-004",
                "required": true,
                "reviewedBy": [
                  "Software Architect",
                  "Security Lead",
                  "Compliance Officer"
                ]
              },
              {
                "name": "Risk Analysis Report (FMEA)",
                "template": "tpl-014",
                "required": true,
                "reviewedBy": [
                  "Risk Manager",
                  "Compliance Officer"
                ]
              },
              {
                "name": "Regulatory Submission Preliminar (FDA 510(k) o SOX controls)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Compliance Officer",
                  "Regulatory Affairs"
                ]
              }
            ],
            "gate": {
              "name": "Requirements & Design Approval Gate",
              "criteria": [
                "SRS aprobado por stakeholders (100% requisitos capturados y firmados)",
                "Traceability Matrix creada (100% requisitos tienen ID único)",
                "HLD aprobado por Software Architect y Security Lead",
                "FMEA completado (todos los modos de falla identificados con mitigación)",
                "Regulatory submission preliminar aceptada (FDA pre-submission meeting positivo o SOX auditor review passed)",
                "Design reviews completados con sign-off de compliance officer"
              ],
              "decision": "APPROVE (proceed to implementation) / REVISE (si regulador requiere cambios)",
              "approvers": [
                "Compliance Officer",
                "Software Architect",
                "Product Owner",
                "Regulatory Affairs",
                "QA Lead"
              ]
            },
            "keyStakeholders": [
              "Business Analyst",
              "Compliance Officer",
              "Software Architect",
              "Security Lead",
              "Regulatory Affairs (FDA liaison, SOX auditor)"
            ]
          },
          {
            "id": "phase-hybrid-incremental-impl",
            "name": "Implementation (Incremental with Traceability)",
            "order": 2,
            "description": "Desarrollo incremental con iteraciones de 3-4 semanas (más largas que Scrum por overhead de documentación). Cada iteración entrega código + unit tests + integration tests + documentación actualizada + traceability matrix actualizada. Code reviews obligatorios con sign-off. Objetivo: Sistema completo con trazabilidad 100% mantenida.",
            "duration": "20-28 semanas (5-7 iteraciones de 3-4 semanas)",
            "activities": [
              "Iteration Planning: Seleccionar subset de requisitos de SRS para iteración (priorizar por riesgo y dependencias)",
              "Detailed Design: Diseño detallado de módulos (SDD - Software Design Document) antes de coding",
              "Implementation: Codificar módulos con trazabilidad (comentarios en código ligan requisito ID → código)",
              "Unit Testing: Tests unitarios con trazabilidad (cada test ligado a requisito en traceability matrix, test ID generado)",
              "Code Review obligatorio: Peer review formal con checklist (coding standards, security, compliance) y sign-off de reviewer",
              "Integration Testing: Tests de integración entre módulos con trazabilidad (test cases documentados)",
              "Traceability Matrix update: Actualizar matriz con código implementado y tests ejecutados (requisito → diseño → código → test)",
              "Documentation update: Actualizar SDD, user manuals, release notes cada iteración",
              "Change Control: Cambios de requisitos requieren Change Request formal con impacto análisis (CCB approval)",
              "Iteration Review: Demo de incremento funcional + review de traceability matrix actualizada (compliance check)"
            ],
            "inputs": [
              "SRS aprobado (Requirements phase)",
              "HLD aprobado (Design phase)",
              "Traceability Matrix inicial",
              "FMEA (riesgos a mitigar en código)"
            ],
            "outputs": [
              "Código implementado con trazabilidad (comentarios ligan requisito ID)",
              "Unit tests + integration tests con trazabilidad (test ID → requisito ID)",
              "Traceability Matrix actualizada (requisito → diseño → código → test completo)",
              "Software Design Document (SDD) actualizado iteración a iteración",
              "Code review sign-offs (cada módulo aprobado formalmente)"
            ],
            "deliverables": [
              {
                "name": "Source Code con trazabilidad (comentarios requisito ID)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Tech Lead",
                  "Code Reviewer"
                ]
              },
              {
                "name": "Test Suite (unit + integration tests con trazabilidad)",
                "template": "tpl-013",
                "required": true,
                "reviewedBy": [
                  "QA Lead",
                  "Compliance Officer"
                ]
              },
              {
                "name": "Traceability Matrix Updated (requisito → código → test)",
                "template": "tpl-014",
                "required": true,
                "reviewedBy": [
                  "QA Lead",
                  "Compliance Officer"
                ]
              },
              {
                "name": "Software Design Document (SDD) actualizado",
                "template": "tpl-004",
                "required": true,
                "reviewedBy": [
                  "Software Architect",
                  "Tech Lead"
                ]
              },
              {
                "name": "Code Review Sign-offs (peer review formal)",
                "template": "tpl-012",
                "required": true,
                "reviewedBy": [
                  "Tech Lead",
                  "Code Reviewers"
                ]
              }
            ],
            "gate": {
              "name": "Implementation Complete Gate",
              "criteria": [
                "100% requisitos de SRS implementados (código completo)",
                "100% unit tests + integration tests pasando (zero failed tests)",
                "Traceability Matrix 100% completa (cada requisito tiene código + test ligado)",
                "Code reviews completados con sign-off (100% módulos revisados)",
                "SDD actualizado (diseño detallado documentado)",
                "Zero defectos críticos conocidos (defectos menores aceptables con workaround documentado)"
              ],
              "decision": "PROCEED TO V&V / FIX CRITICAL DEFECTS",
              "approvers": [
                "Tech Lead",
                "QA Lead",
                "Compliance Officer",
                "Product Owner"
              ]
            },
            "keyStakeholders": [
              "Development Team (8-15 developers)",
              "QA Engineers",
              "Code Reviewers",
              "Compliance Officer (oversight)",
              "Tech Lead"
            ]
          },
          {
            "id": "phase-hybrid-vv-cert",
            "name": "V&V & Certification (Waterfall Formal)",
            "order": 3,
            "description": "Verification & Validation formal por equipo independiente (no development team). Auditoría de trazabilidad completa, UAT con protocolos formales, auditorías regulatorias (FDA inspection, SOX audit), deployment controlado. Objetivo: Sistema certificado y aprobado por regulador para producción.",
            "duration": "8-12 semanas",
            "activities": [
              "Verification & Validation (V&V) independiente: Equipo separado de development ejecuta test plan completo (system testing, regression testing)",
              "Auditoría de trazabilidad: Validar que 100% requisitos tienen tests que pasan (traceability matrix completa y correcta)",
              "UAT (User Acceptance Testing) formal: Usuarios finales ejecutan test protocols (scripts formales con expected results, sign-off obligatorio)",
              "Security testing: Penetration testing, vulnerability scanning (OWASP Top 10, compliance con security standards)",
              "Performance testing: Load testing, stress testing (validar NFRs de SRS: latencia, throughput, uptime)",
              "Auditorías regulatorias: FDA inspection (software validation, 21 CFR Part 11), SOX audit (IT controls, segregation of duties), HIPAA compliance review (PHI protection)",
              "Defect fixing: V&V team reporta defectos, development team fixea, regression testing completo post-fix",
              "Deployment controlado: Phased rollout (10% usuarios → 50% → 100% en 4 semanas), rollback plan documentado",
              "Post-deployment monitoring: Monitoring de errores, crashes, performance por 30 días (validar estabilidad)",
              "Final approval: Sign-off de compliance officer, regulatory affairs, product owner (project closure)"
            ],
            "inputs": [
              "Código completo con tests (Implementation phase)",
              "Traceability Matrix 100% completa",
              "SDD, SRS actualizados",
              "UAT test protocols (definidos en Requirements phase)"
            ],
            "outputs": [
              "V&V Test Report (equipo independiente, system testing completo)",
              "Traceability Audit Report (100% requisitos validados)",
              "UAT Acceptance Document (usuarios finales sign-off)",
              "Regulatory Audit Reports (FDA inspection passed, SOX audit passed, HIPAA compliance passed)",
              "Production Deployment Report (phased rollout, monitoring post-deployment)"
            ],
            "deliverables": [
              {
                "name": "V&V Test Report (equipo independiente)",
                "template": "tpl-013",
                "required": true,
                "reviewedBy": [
                  "V&V Lead (independiente)",
                  "Compliance Officer"
                ]
              },
              {
                "name": "Traceability Audit Report (100% validado)",
                "template": "tpl-014",
                "required": true,
                "reviewedBy": [
                  "Compliance Officer",
                  "QA Lead"
                ]
              },
              {
                "name": "UAT Acceptance Document (usuarios sign-off)",
                "template": "tpl-013",
                "required": true,
                "reviewedBy": [
                  "Product Owner",
                  "Key Users"
                ]
              },
              {
                "name": "Regulatory Audit Reports (FDA, SOX, HIPAA)",
                "template": null,
                "required": true,
                "reviewedBy": [
                  "Regulatory Affairs",
                  "Compliance Officer"
                ]
              },
              {
                "name": "Production Deployment Report (phased rollout, monitoring)",
                "template": "tpl-013",
                "required": true,
                "reviewedBy": [
                  "DevOps Lead",
                  "Product Owner"
                ]
              }
            ],
            "gate": {
              "name": "Production Release Certification Gate",
              "criteria": [
                "V&V testing passed (zero critical defects, <5 minor defects aceptables)",
                "Traceability audit passed (100% requisitos validados con tests pasando)",
                "UAT acceptance signed-off (>95% usuarios finales aprueban)",
                "Regulatory audits passed (FDA inspection aprobado, SOX audit clean, HIPAA compliance validated)",
                "Deployment controlado exitoso (phased rollout sin rollback, <0.1% error rate)",
                "Post-deployment monitoring estable (30 días sin incidentes críticos)",
                "Final sign-off de compliance officer y regulatory affairs"
              ],
              "decision": "CERTIFY FOR PRODUCTION / FIX DEFECTS / ROLLBACK",
              "approvers": [
                "Compliance Officer",
                "Regulatory Affairs",
                "V&V Lead (independiente)",
                "Product Owner",
                "Key Users"
              ]
            },
            "keyStakeholders": [
              "V&V Team (independiente, 3-5 QA engineers)",
              "Compliance Officer",
              "Regulatory Affairs (FDA liaison, SOX auditor)",
              "Key Users (UAT)",
              "DevOps Lead"
            ]
          }
        ],
        "iterationStrategy": "Híbrido con 3 fases: (1) Requirements & Design (Cascada formal, 12-16 sem, NO iterativo - SRS y HLD completos upfront con aprobación regulatoria), (2) Implementation (Incremental, 20-28 sem, 5-7 iteraciones de 3-4 semanas - iterativo pero con trazabilidad mantenida, documentación actualizada cada iteración), (3) V&V & Certification (Cascada formal, 8-12 sem, NO iterativo - validación independiente, auditorías regulatorias, deployment controlado). Total: 40-56 semanas (10-14 meses). Change management controlado: cambios de requisitos requieren re-aprobación regulatoria.",
        "whenToUse": [
          "Sistema crítico regulado (FDA software médico, SOX financial systems, HIPAA healthcare, DO-178C aviación)",
          "Documentación formal obligatoria por regulación (SRS, SDD, traceability matrix requeridos por ley)",
          "Trazabilidad completa requerida (100% requisitos ligados a código y tests - auditable por inspectores)",
          "Auditorías regulatorias periódicas (FDA inspection cada 2 años, SOX audit anual, HIPAA compliance reviews)",
          "V&V (Verification & Validation) independiente requerido (equipo separado de development valida sistema)",
          "Requisitos mayormente estables (cambios controlados, no frecuentes ni volátiles)",
          "Alto impacto de fallas (salud humana, datos financieros, seguridad crítica)",
          "Timeline 10-14 meses aceptable (suficiente para 3 fases con documentación exhaustiva)",
          "Presupuesto para overhead de documentación y auditorías (30-40% del tiempo + $50-100K auditorías)",
          "Equipo con experiencia en desarrollo regulado (conocimiento de FDA, SOX, HIPAA, compliance)"
        ],
        "whenNotToUse": [
          "Sistema no regulado (sin FDA, SOX, HIPAA, usar Ágil puro como Scrum o XP)",
          "Sin necesidad de documentación formal (startup, prototipo, producto interno, usar Scrum)",
          "Requisitos muy volátiles (cambios frecuentes no permitidos en sistemas regulados - friction con governance)",
          "Sin presupuesto para overhead de documentación (30-40% del tiempo en docs + $50-100K auditorías)",
          "Timeline <6 meses (no hay tiempo para Requirements formal + Implementation incremental + V&V formal)",
          "Equipo sin experiencia en compliance (curva de aprendizaje muy alta >6 meses para dominar FDA/SOX/HIPAA)",
          "Sin V&V independiente disponible (regulaciones lo requieren, no puede ser mismo dev team)",
          "Stakeholders no dispuestos a esperar (esperan velocidad de Ágil puro 6-9 meses, no 10-14 meses)",
          "Sistema de bajo riesgo (fallas no tienen impacto crítico en salud/finanzas/seguridad)",
          "Sin aprobación regulatoria preliminar (FDA 510(k) puede tardar 6-12 meses antes de coding)"
        ],
        "advantages": [
          "Compliance regulatorio garantizado (documentación formal cumple FDA 21 CFR Part 11, SOX 404, HIPAA Security Rule)",
          "Trazabilidad completa facilita auditorías (100% requisitos ligados a tests - inspectores validan fácilmente)",
          "V&V independiente detecta defectos que dev team pasa por alto (fresh eyes, perspectiva crítica)",
          "Iteraciones permiten ajustes controlados sin perder trazabilidad (detección temprana de defectos, fixing cost 10x menor)",
          "Risk analysis upfront (FMEA) minimiza fallas críticas (modos de falla identificados antes de coding)",
          "Change control formal previene cambios no autorizados (governance estricto protege integridad)",
          "Code reviews obligatorios mejoran calidad (peer review con sign-off formal reduce defectos 40-60%)",
          "Deployment controlado minimiza riesgo (phased rollout 10%→50%→100% con rollback plan)",
          "Auditorías pasadas facilitan re-certificaciones futuras (documentación reutilizable para compliance anual)",
          "Balance entre predictibilidad (Cascada) y detección temprana de defectos (Incremental)"
        ],
        "disadvantages": [
          "Overhead de documentación muy alto (30-40% del tiempo en SRS, SDD, traceability matrix, test protocols)",
          "Timeline largo (10-14 meses) comparado con Ágil puro (6-9 meses para mismo sistema)",
          "Costoso debido a V&V independiente ($50-100K adicionales para equipo separado + auditorías regulatorias)",
          "Cambios de requisitos son lentos (requieren re-aprobación regulatoria 4-6 semanas + impacto análisis)",
          "Iteraciones más largas que Scrum (3-4 semanas vs 1-2 semanas) por overhead de documentación y traceability",
          "Requiere expertise en compliance escaso (no todos los equipos tienen experiencia en FDA/SOX/HIPAA)",
          "Aprobación regulatoria preliminar puede tardar 6-12 meses (FDA 510(k) submission antes de coding)",
          "V&V formal al final puede descubrir defectos tardíos (costoso fixing si arquitectura tiene issues fundamentales)",
          "Burocracia puede generar frustración en dev team (documentación excesiva vista como overhead sin valor)",
          "Sin flexibilidad para pivoting rápido (regulaciones no permiten cambios drásticos mid-project)"
        ],
        "changeManagement": {
          "description": "Change control formal con re-aprobación regulatoria si cambio afecta safety/security.",
          "steps": [
            {
              "step": 1,
              "name": "Change Request Formal con justificación regulatoria",
              "description": "Todo cambio de requisitos requiere CR formal con: justificación (por qué cambio es necesario para compliance o funcionalidad), impacto en traceability, tests afectados, documentación a actualizar."
            },
            {
              "step": 2,
              "name": "Impact Analysis multi-dimensional",
              "description": "Analizar impacto en: (1) Traceability matrix (requisitos afectados, tests a re-ejecutar), (2) Código (módulos a modificar, refactoring necesario), (3) Documentación (SRS, SDD, user manuals a actualizar), (4) Regulatory approval (cambio afecta safety/security? Requiere re-aprobación FDA/SOX?)."
            },
            {
              "step": 3,
              "name": "Change Control Board (CCB) Approval",
              "description": "CCB (Product Owner + QA Lead + Compliance Officer + Regulatory Affairs) revisa CR. Decisión: Aprobar (si impacto aceptable), Rechazar (si muy costoso o riesgoso), Defer to Next Release (si no es crítico)."
            },
            {
              "step": 4,
              "name": "Re-aprobación regulatoria si safety/security afectado",
              "description": "Si cambio afecta safety (modos de falla nuevos) o security (access control, encryption), requiere amendment a regulatory submission (FDA 510(k) amendment, SOX controls update). Timeline: 4-6 semanas + $10-20K."
            },
            {
              "step": 5,
              "name": "Implementation en próxima iteración con trazabilidad",
              "description": "Implementar cambio en próxima iteración disponible. Actualizar traceability matrix (requisito nuevo/modificado → diseño → código → test). Code review obligatorio con sign-off."
            },
            {
              "step": 6,
              "name": "Regression Testing completo + V&V update",
              "description": "Ejecutar regression testing completo (cambio puede romper funcionalidad existente). Actualizar V&V test plans con nuevos test cases. Re-ejecutar tests afectados en V&V phase."
            }
          ]
        },
        "tooling": [
          {
            "category": "Requirements & Traceability",
            "tools": [
              "IBM DOORS, Jama Connect, Helix RM (requirements management con trazabilidad)",
              "Traceability Matrix tools (requisito → diseño → código → test)",
              "Visure Requirements (alternativa a DOORS para FDA/IEC 62304)"
            ]
          },
          {
            "category": "Documentation",
            "tools": [
              "Confluence, SharePoint (versionado de SRS, SDD, test protocols)",
              "LaTeX, Markdown (documentación técnica versionada en Git)",
              "DocuSign (sign-offs electrónicos de compliance officer, regulatory affairs)"
            ]
          },
          {
            "category": "Testing",
            "tools": [
              "JUnit, Pytest, NUnit (unit testing con trazabilidad - test ID → requisito ID)",
              "Selenium, Cypress (integration testing, UAT automation)",
              "JIRA Test Management, Zephyr (test case management con trazabilidad)"
            ]
          },
          {
            "category": "Compliance & Risk",
            "tools": [
              "GxP tools (MasterControl, Veeva Vault para FDA compliance)",
              "FMEA tools (Relyence, XFMEA para risk analysis)",
              "SOX compliance tools (AuditBoard, Workiva para IT controls)"
            ]
          },
          {
            "category": "Code Review & CI/CD",
            "tools": [
              "GitHub, GitLab (version control con approval workflows para sign-off obligatorio)",
              "SonarQube (code quality, static analysis para compliance)",
              "Jenkins, GitHub Actions (CI/CD con trazabilidad de builds, test execution)"
            ]
          },
          {
            "category": "ALM & Auditing",
            "tools": [
              "IBM Rational DOORS/DNG (ALM completo para regulated systems)",
              "PTC Windchill (ALM para medical devices)",
              "Jama Connect (ALM con FDA/IEC 62304 templates)"
            ]
          }
        ],
        "references": [
          {
            "title": "Software Engineering (10th Edition) - Chapter 2: Software Processes",
            "author": "Ian Sommerville",
            "year": 2015,
            "source": "Pearson"
          },
          {
            "title": "Software Engineering (10th Edition) - Chapter 24: Critical Systems Engineering",
            "author": "Ian Sommerville",
            "year": 2015,
            "source": "Pearson"
          },
          {
            "title": "IEC 62304: Medical Device Software - Software Life Cycle Processes",
            "author": "International Electrotechnical Commission",
            "year": 2006,
            "source": "IEC Standard"
          },
          {
            "title": "FDA Guidance: General Principles of Software Validation",
            "author": "U.S. Food and Drug Administration",
            "year": 2002,
            "source": "FDA Guidance Document"
          }
        ]
      },
      "methodology": {
        "name": "Hybrid Waterfall-Incremental (Regulated Systems)",
        "description": "Metodología híbrida para sistemas críticos regulados que combina desarrollo Waterfall upfront (requirements/design formal con documentación para aprobación regulatoria) con desarrollo Incremental iterativo (implementación en iteraciones de 3-4 semanas con trazabilidad completa) y V&V (Verification & Validation) final formal. Tres fases principales: (1) Requirements & Design (Waterfall, 12-16 semanas): SRS formal, HLD, traceability matrix, FMEA (Failure Mode and Effects Analysis), documentación para FDA 510(k) o equivalente; (2) Implementation (Incremental, 20-28 semanas): 5-7 iteraciones implementando funcionalidad incremental con traceability actualizada continuamente, change control formal para cambios de requisitos; (3) V&V & Certification (Waterfall, 8-12 semanas): testing de V&V independiente, auditorías regulatorias (FDA inspection, SOX audit, HIPAA compliance). Balance entre compliance regulatorio estricto (documentación, trazabilidad, auditorías) y flexibilidad de desarrollo iterativo (detección temprana de defectos, refinamiento de diseño).",
        "origin": {
          "creator": "Práctica de la industria regulada (dispositivos médicos FDA, sistemas financieros SOX, healthcare HIPAA, aviación DO-178C)",
          "year": 2000,
          "context": "Emergió en industrias reguladas (~2000-2010) bajo presión por acelerar time-to-market sin sacrificar compliance. Regulaciones como FDA 21 CFR Part 11 (electronic records/signatures), IEC 62304 (medical device software lifecycle), DO-178C (aviación), SOX (finanzas) requieren documentación formal exhaustiva, trazabilidad completa requisito-diseño-código-test y auditorías independientes. Waterfall puro era muy lento y detectaba defectos demasiado tarde (costosos de fixear). Híbrido permite iteraciones controladas documentadas que mantienen compliance mientras reducen riesgo técnico tempranamente."
        },
        "principles": [
          "Requirements/Design formal upfront con aprobación regulatoria preliminar: SRS, HLD, traceability matrix baseline antes de comenzar implementación",
          "Traceability matrix completa y actualizada continuamente: cada requisito trazable a diseño → código → test case → test result (bidirectional traceability)",
          "Desarrollo iterativo pero rigurosamente documentado: cada iteración actualiza design docs, traceability matrix, risk analysis (no es 'código y ya')",
          "V&V (Verification & Validation) independiente: equipo separado del development team realiza testing formal, ejecuta test protocols, documenta deviaciones",
          "Change control formal estricto: cambios de requisitos requieren impact analysis, re-aprobación de stakeholders/reguladores, actualización de traceability",
          "Auditorías regulatorias finales: FDA inspection (510k, PMA), SOX audit, HIPAA compliance assessment con documentación completa y evidencia de testing"
        ],
        "differentiators": [
          "vs Waterfall puro: Implementación se hace iterativamente (no big-bang), permitiendo detección temprana de defectos de integración y refinamiento de diseño técnico",
          "vs Ágil puro: Documentación formal exhaustiva y traceability completa son obligatorias (no 'working software over comprehensive documentation'), con change control estricto",
          "vs RUP: Mayor énfasis en compliance regulatorio específico (FDA, SOX, HIPAA) con templates de documentación, procesos de auditoría y V&V independiente obligatoria"
        ],
        "references": {
          "chapter": "chapter-2, chapter-24",
          "sections": [
            "2.1 Plan-driven and agile development",
            "24.3 Safety and dependability requirements",
            "24.4 Safety engineering"
          ],
          "externalResources": [
            "FDA 21 CFR Part 11 - Electronic Records; Electronic Signatures",
            "IEC 62304:2006 - Medical device software - Software life cycle processes",
            "DO-178C - Software Considerations in Airborne Systems and Equipment Certification",
            "ISO 13485 - Medical devices - Quality management systems"
          ]
        }
      },
      "modeling": {
        "notations": [
          {
            "name": "UML formal",
            "description": "UML con trazabilidad completa a requisitos (cada diagrama referencia requisitos en SRS).",
            "diagrams": [
              "Use Case (requisitos trazables)",
              "Class",
              "Sequence",
              "State Machine (todos con trazabilidad a requisitos)"
            ],
            "whenToUse": "FDA/SOX requieren trazabilidad completa (cada diagrama debe referenciar requisitos en SRS)",
            "tools": [
              "IBM Rational",
              "DOORS (trazabilidad)",
              "Polarion"
            ]
          },
          {
            "name": "Traceability Matrix",
            "description": "Matriz que liga requisitos → diseño → código → tests.",
            "diagrams": [
              "Traceability Matrix (tabla o diagrama)",
              "Requirements Coverage Matrix"
            ],
            "whenToUse": "Regulaciones requieren demostrar que cada requisito está implementado y testeado (FDA 21 CFR Part 11, IEC 62304)",
            "tools": [
              "IBM DOORS",
              "Jama Connect",
              "Polarion",
              "Excel con macros"
            ]
          },
          {
            "name": "FMEA (Failure Mode and Effects Analysis)",
            "description": "Análisis de modos de falla (qué puede fallar, impacto, probabilidad, detección, mitigación).",
            "diagrams": [
              "FMEA Table",
              "FTA (Fault Tree Analysis)",
              "HAZOP"
            ],
            "whenToUse": "Sistemas críticos requieren análisis de riesgos formal (FDA, IEC 62304, ISO 26262)",
            "tools": [
              "Relyence",
              "XFMEA",
              "RAM Commander",
              "Excel"
            ]
          }
        ],
        "primaryFocus": "Modelado formal con trazabilidad completa (requisitos → diseño → código → tests) y análisis de riesgos (FMEA)",
        "references": {
          "chapter": "chapter-24",
          "sections": [
            "24.2 Dependability engineering",
            "24.3 Safety and dependability requirements"
          ]
        }
      },
      "architecture": {
        "patterns": [
          {
            "name": "Layered (con auditoría)",
            "description": "Arquitectura en capas con logging y auditoría exhaustiva en cada capa.",
            "advantages": [
              "Trazabilidad de acciones (quién hizo qué y cuándo, FDA 21 CFR Part 11)",
              "Separación de concerns con auditoría integrada",
              "Facilita compliance con regulaciones (logs inmutables)",
              "Debugging facilitado por logs exhaustivos"
            ],
            "disadvantages": [
              "Overhead de logging (performance, storage significativos)",
              "Complejidad de gestión de logs (rotación, archivado, búsqueda)"
            ],
            "whenToUse": "Sistemas regulados que requieren auditoría completa (FDA 21 CFR Part 11, SOX, HIPAA)",
            "tradeoffs": "Trazabilidad y auditoría completa vs Overhead de logging"
          },
          {
            "name": "Redundancy Patterns (High Availability)",
            "description": "Redundancia de componentes críticos (active-active, active-passive, N+1) para alta disponibilidad.",
            "advantages": [
              "Alta disponibilidad (99.9%+ uptime, crítico en healthcare/finanzas)",
              "Tolerancia a fallos (failover automático en segundos)",
              "Mantenimiento sin downtime (rolling updates)",
              "Cumple requisitos de sistemas críticos (no single point of failure)"
            ],
            "disadvantages": [
              "Costo de infraestructura (servidores/componentes redundantes)",
              "Complejidad de configuración y failover (testing de failover necesario)",
              "Sincronización de estado entre réplicas (consistency challenges)"
            ],
            "whenToUse": "Sistemas críticos donde downtime no es aceptable (healthcare, finanzas, control industrial)",
            "tradeoffs": "Alta disponibilidad y tolerancia a fallos vs Costo de infraestructura"
          }
        ],
        "style": "Monolito modular o SOA (con redundancia y auditoría completa)",
        "qualityAttributes": {
          "scalability": "Medium - Prioridad es compliance y disponibilidad, no escalamiento masivo. Vertical scaling suficiente con redundancia N+1.",
          "maintainability": "High - Documentación formal exhaustiva (SRS, SDD, traceability matrix) facilita mantenimiento. Change control estricto garantiza estabilidad.",
          "performance": "Medium - Overhead de logging y auditoría. Optimización secundaria a compliance y safety. Latencia aceptable en sistemas críticos.",
          "security": "Very High - Controles estrictos (autenticación multi-factor, autorización granular, encriptación AES-256, auditoría completa). Cumple FDA 21 CFR Part 11, HIPAA, SOX."
        },
        "references": {
          "chapter": "chapter-24",
          "sections": [
            "24.4 Safety assurance",
            "24.5 Security and dependability"
          ]
        }
      },
      "timeline": [
        {
          "week": "1-2",
          "phase": "Research + MVP",
          "tasks": [
            "Investigación de mercado",
            "Landing page + waitlist",
            "MVP mínimo",
            "Setup analytics"
          ]
        },
        {
          "week": "3-4",
          "phase": "Early Adopters",
          "tasks": [
            "Lanzar a waitlist",
            "Onboarding de usuarios",
            "Recolectar feedback",
            "Medir engagement"
          ]
        },
        {
          "week": "5-8",
          "phase": "Iteración",
          "tasks": [
            "Features basadas en datos",
            "A/B testing",
            "Optimización de conversión",
            "User interviews"
          ]
        },
        {
          "week": "9+",
          "phase": "Product-Market Fit",
          "tasks": [
            "Escalar lo que funciona",
            "Acquisition channels",
            "Retención",
            "Monetización"
          ]
        }
      ],
      "avoid": [
        "Construir sin validar asunciones",
        "No medir TODO",
        "Ignorar feedback de early adopters",
        "No tener landing page desde día 1",
        "Perfeccionismo sin usuarios",
        "No definir métricas de éxito"
      ],
      "templates": [
        "tpl-004",
        "tpl-005",
        "tpl-008"
      ],
      "chapters": [
        2,
        3,
        6
      ]
    }
  }
}